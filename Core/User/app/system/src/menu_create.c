/*
 * @Author: your name
 * @Date: 2021-05-07 11:31:06
 * @LastEditTime: 2021-07-20 10:54:47
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \STM32F429(7inches)\App\app\system\src\menu_create.c
 */
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "menu_create.h"
#include "menu_modify.h"
#include "menu_p.h"
#include "main.h"
#include "menu.h"
#include "touch.h"
#include "utility.h"
#include "register.h"
#include "function.h"
#include "uart.h"
#include "color.h"
#include "communication.h"
#include "ds2460.h"
#include "disk_oper.h"
#include "Bor_patfun.h"
#include "Mit_patfun.h"
#include "Patfun.h"
#include "viewPattern.h"
#include "Toast.h"
#define USBTF USB //USB//TF

#define GoHome PREG[283]

extern U16 SheetPage;
extern volatile U32 g_temp_pno;
extern volatile U8 g_init_flag;
extern volatile U8 g_modifyflag;
extern MachineInfo g_Mac;
extern volatile U8 g_ImageDis;
extern volatile U8 g_NoEndCode;
extern volatile S16 g_pf_absdis;
extern volatile S32 g_xabspos, g_yabspos, g_uabspos, g_vabspos;
extern volatile S16 g_tmpox, g_tmpoy;
extern volatile U16 g_savetimes;
extern volatile U16 g_Tsavetimes;
extern volatile U32 g_jog_stpoint;
extern volatile U32 g_jog_enpoint;
extern volatile U32 g_jog_point;
// extern volatile S8 g_pf_Set_Offest;
volatile S8 g_pf_Set_Offest; //修改
extern volatile U8 g_reorigin;
extern volatile U16 g_selectdisno;
extern volatile U8 coldstart;
extern volatile U8 g_code_para;
extern volatile U16 g_tmp_PfootValSet;
extern volatile U8 g_disppicflag;
extern volatile U8 g_MboardUSB;
extern volatile U8 g_disk_memory;
extern volatile U8 g_UdZhouFlag;
extern volatile U16 g_array4[386][2];
extern volatile U16 g_array5[630][2];
extern volatile U8 g_tExCode;
extern volatile U8 g_ExCode;
extern volatile U8 g_curExCode;
extern volatile U8 g_savemodify;
extern volatile U8 g_BorSTflag;
extern volatile U8 g_ntohome;
extern volatile U8 g_needtohome;
extern volatile U8 g_endtype;
extern volatile S16 g_maxX;
extern volatile S16 g_minX;
extern volatile S16 g_maxY;
extern volatile S16 g_minY;
extern volatile U16 g_curPinAng;     //当前状态针角度值
extern volatile U16 g_pointPinAng;   //针数对应角度值
extern volatile U16 g_curSetPara1;   //当前状态设置一参数
extern volatile U16 g_pointSetPara1; //针数对应设置二参数值
extern volatile U16 g_curSetPara2;   //当前状态设置二参数
extern volatile U16 g_pointSetPara2; //针数对应设置二参数值
extern volatile U8 g_modedat;
extern volatile U16 g_mode1dat[3];
extern volatile S16 g_mode2dat[5];
extern const U16 draw_code[][2];
extern const U16 pat_code[];
extern volatile U8 g_BorAddFuns; //插入附加功能 每一个位代表一个功能
extern volatile U8 g_BorDelFuns; //删除附加功能 每一个位代表一个功能
extern volatile U8 g_DoTrim;     // 删除剪线标志 1是删除, 0 是无删除
extern volatile U16 g_Ptya;      //寸动调速值	2010.4.6
extern volatile U16 g_point_num; //控制点数
extern volatile U8 g_jogfunction;
extern volatile U8 g_jogfunction1;
extern volatile U32 g_jognumber;
extern volatile U8 g_input_method;    //输入模式 0-空送 1-点 2-直线 3-折线 4-圆 5-圆弧 6-曲线
extern volatile U8 g_para_offset;     //多重缝 0-无多重缝 1-同向空送多重缝 2-逆向空送多重缝 3-离边 4-同向缝纫多重缝 5-逆向缝纫多重缝
extern volatile U8 g_direction;       //多重缝方向
extern volatile U8 g_distance;        //多重缝距离
extern volatile U8 g_times;           //多重缝次数
extern volatile U8 g_zig_zag;         //Z字缝
extern volatile U8 g_zig_width;       //Z缝宽度
extern volatile U8 g_zig_pitch;       //Z缝针距
extern volatile U8 g_zig_direction;   //Z缝方向
extern volatile U8 g_bt_mode;         //倒缝
extern volatile U8 g_repeat;          //重叠缝次数
extern volatile U8 g_r_stitch;        //重叠缝针数
extern volatile U8 g_srt_bt;          //前端倒缝次数
extern volatile U8 g_s_stitch;        //前端倒缝针数
extern volatile U8 g_ent_bt;          //后端倒缝次数
extern volatile U8 g_e_stitch;        //后端倒缝针数
extern volatile U32 g_ct_status_flag; //打板状态标志
extern volatile U8 g_ct_insert_flag;  //打板插入标志
extern volatile U8 g_feed_flag;       //打板空送标志
extern volatile U32 g_feedc;          //当前针
extern volatile U32 g_feedsum;        //总针
extern volatile U32 g_feedpat;
extern volatile U8 g_code_mode;
extern volatile U8 g_feed_sew;                                    // 前一针的空送或缝纫标志
extern volatile S16 g_dxpos, g_dypos;                             //x,y坐标变化值
extern volatile S16 g_oxpos, g_oypos, g_oxpos_temp, g_oypos_temp; //x,y坐标实际值
extern volatile S16 g_disxpos, g_disypos;                         //x,y坐标实际值
extern volatile S16 g_tmpoxpos, g_tmpoypos;
extern volatile S16 g_temp_oxpos, g_temp_oypos;
extern volatile U8 g_dopfoot;
extern volatile U16 g_draw_p;
extern volatile U16 g_line_p;
extern volatile U32 g_pat_p;
extern volatile U16 g_temp_draw_p;
extern volatile U16 g_temp_line_p;
extern volatile U32 g_temp_pat_p;
extern volatile U16 g_line_sum;
extern volatile U8 g_editflag;
extern volatile S8 g_lf_dis_modify;
extern volatile S8 g_pf_dis_modify;
extern volatile U8 g_pf_modify_mode;
extern volatile U8 g_oldspeed;
extern volatile U8 g_speed; // 打版时选择的速度级别H MH ML L		20151211
extern volatile U8 g_pitch;
extern volatile U8 g_lineforceValSetNow; // 当前缝纫面线张力值
extern volatile U8 g_mitdotack;
extern volatile U8 g_originf; // 花样结束点位置标志 0：不在原点位置 1: 在原点位置
extern volatile U8 g_num_mov_key;
extern volatile S8 g_pf_dis;     //中压脚修正值 offest
extern volatile S16 g_pf_absval; //中压脚当前绝对值(包括基准值)
extern volatile U8 g_pf_mode;    //中压脚	1:有设置 0：无设置
extern volatile S16 g_pf_bdis;
extern volatile U16 g_pinAng;
extern volatile U8 g_zrota;
extern volatile U8 g_jogmode;
extern OLDPAT1 g_dispat1;
//volatile U8  g_isBAT;	//打板跳缝标志
extern volatile U8 g_lineforceValSet; // 面线张力基准值
extern volatile U8 g_fbmac;
extern volatile U8 g_blkInset;
extern volatile U8 g_nolimt;
extern volatile U32 g_blkInsetlen;
extern volatile U16 g_ctAddpins;
extern volatile U8 g_selectmode;
extern volatile U16 g_temp_point_num;
extern volatile U8 g_ModToCt;
extern volatile U8 g_modifyflag1;
extern SEW_CHECK g_sewcheck;
extern volatile U8 g_zhouDown;
extern volatile S16 g_modcordflag;

extern volatile U16 g_oldselectdisno;
extern volatile U16 g_Fileno;       //存储了主界面的花样文件号，
extern volatile U16 g_selectnumber; //选中序号
extern volatile U8 g_NoReadPatf;    //不读取花样标志  1-不读取花样数据 2-强制重读一次花样数据
extern volatile S16 g_modcordx;
extern volatile S16 g_modcordy;
extern volatile U32 g_max_feedsum;
extern volatile U32 g_min_feedsum;
extern volatile U8 g_IsLocal;  //标记使用快速定位功能
extern volatile U8 g_errLocal; //图形显示界面异常标志
extern volatile U8 g_ImgMove;
extern volatile U8 g_CodeEn;
extern volatile U8 g_backSREG_f; // 备份SERG数据标志
extern volatile U8 g_backHREG_f; // 备份HERG数据标志

// 打版时输入针距0-12.7		20151211
volatile U16 g_temp_clr_flag;
volatile U8 g_GreatPatType = PAT_MIT;    //生成花样的类型
volatile S16 g_dxpos1, g_dypos1;         //x,y坐标变化值
volatile U8 g_home_2flag;                // 第二原点标志
volatile S16 g_home_2xpos, g_home_2ypos; // 第二原点位置坐标
volatile U8 g_jogonflag;                 //跳针设置界面-快速移动
volatile U8 g_jogmethod;                 //跳针设置界面-跳针方法
volatile U32 g_jognumber;                //跳针设置界面-跳针针数
volatile S8 g_pf_moddis;                 // offest
extern volatile S16 g_temp_PfootOffVal;
volatile S8 g_lineforceOffest;     // 面线张力设置偏移值
volatile S16 g_inoxpos, g_inoypos; //x,y坐标实际值(打板插入点)

volatile U32 g_Ctendaddr, g_Ctstaddr; //兄弟款花样打板起始，结束地址
volatile U32 g_CtPatLen;              //生成打板数据长度 8b

volatile U8 g_IsPfcmd = 0; //中压脚指令

volatile U8 g_updata_pf_valflg; //更新中压脚标志
volatile U8 g_DrawOcclude = 0;  //图形是否封闭标志,0 是封闭,其他是不封闭

volatile U8 g_signflag;

volatile U8 g_UpdataBorDelFuns = 0; //
extern volatile U8 g_enctTackCode;  //区段自动追加重叠缝使能

extern volatile OVLP g_autoOvlp; //区段追加重叠缝参数

volatile S8 g_pfootsetOffest;
volatile U16 g_Ctsavetimes;
extern volatile U16 g_curPTtype; //当前花样类型

volatile U8 g_cttohome;

extern volatile U8 g_readcovnflag;
extern volatile U8 g_readcovnflag1;

volatile U16 g_exType;
volatile U16 g_exFeedSp;    //移送速
volatile U16 g_exRestart;   //重启动
volatile U16 g_exThickness; //物料厚
volatile U16 g_exClweight;  //压板重

Point g_ovalPoints[15] = {{-50, 0}, {-40, 17}, {-23, 26}, {-4, 29}, {4, 29}, {23, 26}, {40, 17}, {50, 0}, {40, -17}, {23, -26}, {4, -29}, {-4, -29}, {-23, -26}, {-40, -17}, {-50, 0}};

U16 getModLfNo(U8 inNo)
{
    U8 outNo = 0, outDat = 0;
    U8 i = 0, j = 0;
    if (LREG[LFNOMAX] == 0)
    {
        return 0;
    }
    for (i = 0; i < 10; i++)
    {
        if (LREG[LFNO0 + i])
        {
            if (j == inNo)
            {
                outNo = i;
                outDat = LREG[LFNO0 + i] & 0xff;
                return ((outNo << 8) + outDat);
            }
            j++;
        }
    }
    return 0;
}

#define P_MINDIS 50
U8 getctNearPointPos(s16 inx, S16 iny, S16 *outx, S16 *outy)
{
    U32 i;
    ISEWADD sewInfo = {0};
    ISEWCMD sewIcmd = {0};
    U16 dat;
    U8 xx, yy;
    S16 xpos = 0, ypos = 0;
    U16 tmindis;
    U8 f, res = 0;

    if (g_GreatPatType == PAT_MIT)
    {
#if PATRULES_ORG_OFFSET
        if (SREG[3] == 7) //新增-修改原点位置
        {
            xpos = (S16)(SREG[6]);
            ypos = (S16)(SREG[7]);
        }
#endif
        tmindis = P_MINDIS * P_MINDIS;
        for (i = 0; i < g_feedsum; i++)
        {
            dat = SREG[52000 + i * 2] & 0x00ff;
            if ((dat == 0x61) || (dat == 0x41) || (dat == 0x21) || (dat == 0x1) || (dat == 0x1b) || (dat == 0x3))
            {
                dat = SREG[g_patd.pat_add + i * 2 + 1];
                xx = dat & 0xff;
                yy = ((U32)(dat >> 8)) & 0xff;
                if (xx >= 0x80)
                {
                    xx -= 0x80;
                    xpos -= xx;
                }
                else
                {
                    xpos += xx;
                }
                if (yy >= 0x80)
                {
                    yy -= 0x80;
                    ypos -= yy;
                }
                else
                {
                    ypos += yy;
                }
                if ((inx - xpos) * (inx - xpos) + (iny - ypos) * (iny - ypos) < tmindis)
                {
                    *outx = xpos;
                    *outy = ypos;
                    tmindis = (inx - xpos) * (inx - xpos) + (iny - ypos) * (iny - ypos);
                    res = 1;
                }
            }
        }
    }
    else if (g_GreatPatType == PAT_SEW)
    {
        tmindis = 2 * P_MINDIS * 2 * P_MINDIS;
        f = Bor_AnaInfo((U16 *)SREG, g_CtPatLen, &sewInfo);
        if (f == 0)
            return res;

        xpos = g_patd.orgX;
        ypos = g_patd.orgY;

        for (i = 0; i < sewInfo.ptsize / 2;)
        {
            f = Bor_DrawCmd((U16 *)&SREG[i + sewInfo.pataddr], &sewIcmd);
            if (f)
            {
                if (sewIcmd.cmd == 0xff00)
                { //结束
                    break;
                }
                else if (((sewIcmd.cmd & 0xf000) == 0x2000) || ((sewIcmd.cmd & 0xf000) == 0x6000))
                {
                    xpos += sewIcmd.dx;
                    ypos += sewIcmd.dy;
                    if ((inx - xpos) * (inx - xpos) + (iny - ypos) * (iny - ypos) < tmindis)
                    {
                        *outx = xpos;
                        *outy = ypos;
                        tmindis = (inx - xpos) * (inx - xpos) + (iny - ypos) * (iny - ypos);
                        res = 1;
                    }
                }
                i += sewIcmd.off;
            }
            else
                i++;
        }
    }

    return res;
}

//--------------------------------------------------------------------
U16 cmdAny(U16 cmd)
{
    U16 dat = 0;
    if ((cmd & 0xf000) == 0x2000)
    { //移送
        dat = 0;
    }
    else if ((cmd & 0xf000) == 0x6000)
    { //缝纫
        dat = 1;
    }
    else
    {
        switch (cmd & 0xff00)
        {
        case 0xf000:
            dat = 0xf0;
            break; //中压脚
        case 0xf100:
            dat = 0x3a;
            break; //线张力
        case 0xf300:
            dat = 0xf3;
            break; //暂停开
        case 0xfb00:
            dat = 0xfb;
            break;   //一级减速指令
        case 0xfc00: //备选代码1指令
            if (cmd == 0xfc01)
                dat = 0x05;
            else if (cmd == 0xfc02)
                dat = 0xb;
            else if (cmd == 0xfc04)
                dat = 0xc;
            else if (cmd == 0xfc08)
                dat = 0xd;
            else if (cmd == 0xfc10)
                dat = 0x11d;
            else if (cmd == 0xfc20)
                dat = 0x11d;
            else if (cmd == 0xfc40)
                dat = 0x21d;
            else if (cmd == 0xfc80)
                dat = 0x31d;
            else
                dat = 0xfc;
            break;
        case 0xfd00:
            dat = 0x2;
            break; //剪线指令
        case 0xf400:
            dat = 0x7;
            break; //跳缝指令
        case 0xfe00:
            if (cmd & 0x01)
                dat = 0x14; //下暂停
            else
                dat = 0x4; //上暂停
            break;
        case 0xec00:
            dat = 0x3c;
            break; //针跟随
        case 0xea00:
            dat = 0x3d;
            break; //功能一
        case 0xeb00:
            dat = 0x3e;
            break; //功能二
        case 0xee00:
            dat = 0xee;
            break; //速度
        default:
            break;
        }
    }

    if (g_oldspeed == 0)
        g_oldspeed = 0x60;
    else if (g_oldspeed == 1)
        g_oldspeed = 0x40;
    else if (g_oldspeed == 2)
        g_oldspeed = 0x20;
    else
        g_oldspeed = 0x0;

    return dat;
}

#define KEY_INPUT_SCRNSVR 1 //1 屏保
#define KEY_INPUT_BACK 2    //2 返回
#define KEY_INPUT_ENTER 3   //3 确认
#define KEY_INPUT_PFOOT 4   //4 抬压脚
#define KEY_INPUT_PINUP 5   //5 针上升下降
#define KEY_INPUT_CLRX 6    //6 保留
#define KEY_INPUT_CLR 7     //7 新建
#define KEY_INPUT_PFBASE 8  //8 压脚继承
#define KEY_INPUT_LFBASE 9  //9 松线继承

#define KEY_INPUT_H 10   //10 高速
#define KEY_INPUT_MD1 11 //11 中高速
#define KEY_INPUT_MD2 12 //12 中低速
#define KEY_INPUT_L 13   //13 低速

#define KEY_INPUT_CLEAN 14 //14 清除1位
#define KEY_INPUT_UP 15    //15 +1
#define KEY_INPUT_DOWN 16  //16 -1
#define KEY_INPUT_0 17     //17 0
#define KEY_INPUT_1 18     //18 1
#define KEY_INPUT_2 19     //19 2
#define KEY_INPUT_3 20     //20 3
#define KEY_INPUT_4 21     //21 4
#define KEY_INPUT_5 22     //22 5
#define KEY_INPUT_6 23     //23 6
#define KEY_INPUT_7 24     //24 7
#define KEY_INPUT_8 25     //25 8
#define KEY_INPUT_9 26     //26 9

#define KEY_INPUT_MAX 27

#define RECT_INPUT_PFBASE 1  //1 压脚继承
#define RECT_INPUT_LFBASE 2  //2 松线继承
#define RECT_INPUT_SPEED 3   //3 速度
#define RECT_INPUT_PIN_TIT 4 //4 针距-标题
#define RECT_INPUT_PIN_STR 5 //5 针距-内容

#define RECT_INPUT_MAX 6

void Menu_CtInput(void)
{

    U32 i /*, j, k*/;

    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息

    /****按键相关参数end****/

    /****标志位相关参数begin****/
    U8 dis_updata1 = 1; //速度按键刷新
    U8 dis_updata2 = 1; //保留新建按键刷新
    U8 dis_updata3 = 1; //压脚继承按键刷新
    U8 dis_updata4 = 1; //松线继承按键刷新
    U8 dis_updata5 = 1; //刷新针距数据

    U16 temp_pitch, dat;
    U8 temp_speed, ch;
    U8 f;
    U32 n, ii;
    S8 lforceval; // 2013.4.8
    U8 pfbaseflag = 0, lfbaseflag = 1;
    U8 pfootf = 0xff;
    U8 needlef = 0xff;
    U16 tmpBorcmd;
    S8 tmpBorpooft, Borpfdis;
    S8 tmpsetPf = 0;  //中压脚基准值
    U8 tmpsetLf = 60; //张力线基准值
    U32 BorPFaddr = 0, BorLFaddr = 0;
    U8 excode = 0;
    /****标志位相关参数end***/

    const U8 keynum = {KEY_INPUT_MAX};

    const KEYPAD keyd[] = {
        {0, 0, 0, 0},

        {0, 0, 128, 32},                     //1 屏保
        {TYPE_X1, TYPE_Y4, KEY_X1, KEY_Y1},  //2 返回
        {TYPE_X11, TYPE_Y4, KEY_X1, KEY_Y1}, //3 确认
        {TYPE_X9, TYPE_Y4, KEY_X1, KEY_Y1},  //4 抬压脚
        {TYPE_X10, TYPE_Y4, KEY_X1, KEY_Y1}, //5 针上升下降
        {138, TYPE_Y3, KEY_X1, KEY_Y1},      //6 保留
        {282, TYPE_Y3, KEY_X1, KEY_Y1},      //7 新建
        {138, 207, KEY_X1, KEY_Y1},          //8 压脚继承
        {282, 207, KEY_X1, KEY_Y1},          //9 松线继承

        {138, 332, KEY_X1, KEY_Y1}, //10 高速
        {210, 332, KEY_X1, KEY_Y1}, //11 中高速
        {282, 332, KEY_X1, KEY_Y1}, //12 中低速
        {354, 332, KEY_X1, KEY_Y1}, //13 低速

        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 4, KEY_X2, KEY_Y2},                             //14 清除1位
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},       //15 +1
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2}, //16 -1
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},                             //17 0
        {TYPE_X15, TYPE_Y13, KEY_X2, KEY_Y2},                                                         //18 1
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13, KEY_X2, KEY_Y2},                                   //19 2
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13, KEY_X2, KEY_Y2},                             //20 3
        {TYPE_X15, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},                                   //21 4
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},             //22 5
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},       //23 6
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},                             //24 7
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},       //25 8
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2}, //26 9

    };

    const tydDisSrcIndex keybmpind[] = {
        //title_counter
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},        //1 屏保
        {{KEY_Silver}, {0}, {241, 242}, {2, 0, 0, 0}, {0}}, //2 返回
        {{KEY_Silver}, {0}, {71}, {3, 0, 0, 0}, {0}},       //3 确认

        {{KEY_Silver}, {0}, {17, 19}, {19, 4, 0, 0}, {0}},                                     //4 抬压脚
        {{KEY_Silver}, {0}, {21, 23}, {20, 5, 0, 0}, {0}},                                     //5 针上升下降
        {{KEY_Silver, KEY_Blue}, {Color_Black}, {293, 294}, {6, 0, 0, 0}, {30}},               //6 保留
        {{KEY_Silver, KEY_Blue}, {Color_Black}, {291, 292}, {7, 0, 0, 0}, {29}},               //7 新建
        {{KEY_Silver, KEY_Blue}, {Color_Black, Color_White}, {14, 15}, {17, 8, 0, 0}, {17}},   //8 压脚继承
        {{KEY_Silver, KEY_Blue}, {Color_Black, Color_White}, {303, 304}, {18, 9, 0, 0}, {18}}, //9 松线继承

        {{KEY_Silver, KEY_Blue}, {0}, {295, 296}, {10, 0, 0, 0}, {0}}, //10 高速
        {{KEY_Silver, KEY_Blue}, {0}, {297, 298}, {11, 0, 0, 0}, {0}}, //11 中高速
        {{KEY_Silver, KEY_Blue}, {0}, {299, 300}, {12, 0, 0, 0}, {0}}, //12 中低速
        {{KEY_Silver, KEY_Blue}, {0}, {301, 302}, {13, 0, 0, 0}, {0}}, //13 低速

        {{KEY_Silver}, {0}, {113}, {14, 0, 0, 0}, {0}}, //14 清除1位
        {{KEY_Silver}, {0}, {199}, {15, 0, 0, 0}, {0}}, //15 +1
        {{KEY_Silver}, {0}, {201}, {16, 0, 0, 0}, {0}}, //16 -1
        {{KEY_Silver}, {0}, {91}, {0, 0, 0, 0}, {0}},   //17 0
        {{KEY_Silver}, {0}, {92}, {0, 0, 0, 0}, {0}},   //18 1
        {{KEY_Silver}, {0}, {93}, {0, 0, 0, 0}, {0}},   //19 2
        {{KEY_Silver}, {0}, {94}, {0, 0, 0, 0}, {0}},   //20 3
        {{KEY_Silver}, {0}, {95}, {0, 0, 0, 0}, {0}},   //21 4
        {{KEY_Silver}, {0}, {96}, {0, 0, 0, 0}, {0}},   //22 5
        {{KEY_Silver}, {0}, {97}, {0, 0, 0, 0}, {0}},   //23 6
        {{KEY_Silver}, {0}, {98}, {0, 0, 0, 0}, {0}},   //24 7
        {{KEY_Silver}, {0}, {99}, {0, 0, 0, 0}, {0}},   //25 8
        {{KEY_Silver}, {0}, {100}, {0, 0, 0, 0}, {0}},  //26 9

    };

    const RECTPAD rect[] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {0}},
        {130, 179, TYPE_SIZE12, TYPE_SIZE14, {Color_Black}, {Color_Black, Color_White}, {23}}, //1 压脚继承
        {274, 179, TYPE_SIZE12, TYPE_SIZE14, {Color_Black}, {Color_Black, Color_White}, {24}}, //2 松线继承
        {130, 304, 296, TYPE_SIZE14, {Color_Black}, {Color_Black, Color_White}, {21}},         //3 速度

        {TYPE_X15, TYPE_Y3, TYPE_SIZE9, TYPE_SIZE5, {Color_KeyBlue}, {Color_White}, {22}},                               //4 针距-标题
        {TYPE_X15 + TYPE_SIZE9 + SAFE_DIST5, TYPE_Y3, TYPE_SIZE14, TYPE_SIZE5, {Color_DeepSkyBlue}, {Color_Black}, {0}}, //5 针距-内容
    };

    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_INPUT); //设置当前文字显示雷人在P1页面，对应41.bin
    InitScreen();
    initViewStatus();
    updateViewStatus();

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    pfbaseflag = (P_ZTM == 0) ? 0 : 1;
    //读取当前中压脚基准值
    f = Read_D(D_Address[SYS] + SYS_PFOOTSET, 1, (U16 *)(&YREG[SYS_PFOOTSET]));
    if (f == 0)
    {
        pno = MENU_RWHELP;
        hleppara = 15;
        return;
    }
    g_pfootd.base = YREG[SYS_PFOOTSET];
    g_pfootd.oldbase = g_pfootd.base;
    //读取当前张力基准值
    f = Read_D(D_Address[SYS] + SYS_LFORCESET, 1, (U16 *)(&YREG[SYS_LFORCESET]));
    if (f == 0)
    {
        pno = MENU_RWHELP;
        hleppara = 15;
        return;
    }
    g_tdtensiond.base = YREG[SYS_LFORCESET];
    g_tdtensiond.oldbase = g_tdtensiond.base;
    if ((g_tdtensiond.base > LF_ABS_MAX) || (g_tdtensiond.base < LF_ABS_MIN))
        g_tdtensiond.base = LF_ABS_MIN;

    g_pinAng = 0;
    temp_speed = g_speed;
    temp_pitch = g_pitch;
    if (plastno != MENU_CURSOR)
        temp_speed = 0x60;
    else if ((temp_speed != 0x20) && (temp_speed != 0x40) && (temp_speed != 0x60))
        temp_speed = 0;
    if (temp_pitch > LOOSEN_MAX || temp_pitch == 0)
        temp_pitch = 30;

    if (F_FILETYPE == PAT_SEW)
    {
        g_init_flag = 1;
    }
    if (g_init_flag == 0)
    {
        g_temp_clr_flag = 1;
    }

    //	gGreatPatType = gBatType;  //默认为上一次保存的类型
    //	g_GreatPatType = F_FILETYPE;	//默认进来时的花样类型
    //	g_isBAT = 0;	//跳缝标记清除
    g_temp_clr_flag = 1; //默认清除
    g_GreatPatType = PAT_MIT;
    // if (g_temp_clr_flag == 0)
    // {
    //     pfbaseflag = 0;
    //     lfbaseflag = 0;
    // }
    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                 SheetPage, rect[0].index[0], rect[0].colorT[0]); //花样设计

    //画出方框显示
    for (i = 1; i < RECT_INPUT_MAX; i++)
    {

        if (i == RECT_INPUT_PFBASE ||
            i == RECT_INPUT_LFBASE ||
            i == RECT_INPUT_SPEED)
        {
            DrawRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);

            Draw24x24Str(rect[i].xpis + SAFE_DIST4, rect[i].ypis + SAFE_DIST3,
                         MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
                         SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
        }
        else if (i == RECT_INPUT_PIN_TIT)
        {
            DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
            Draw24x24Str(rect[i].xpis + (rect[i].xsize - 24 * 2) / 2, rect[i].ypis + (rect[i].ysize - 24) / 2,
                         MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
                         SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
        }
        else
        {
            DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
            DrawDottedRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorT[0]);
        }
    }
    //画出按键显示
    for (i = 2; i < KEY_INPUT_MAX; i++)
    {
        //无效按键
        //绘制颜色文字按键
        DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
    }
    DrawF16Str(rect[RECT_INPUT_PIN_STR].xpis,
               rect[RECT_INPUT_PIN_STR].ypis + rect[RECT_INPUT_PIN_STR].ysize + SAFE_DIST4,
               "(0.1-12.7)mm", rect[RECT_INPUT_PIN_STR].colorT[0]);
    Draw24x24Str(keyd[KEY_INPUT_CLR].xpis + (keyd[KEY_INPUT_CLR].xsize - 24 * 2) / 2,
                 keyd[KEY_INPUT_CLR].ypis + keyd[KEY_INPUT_CLR].ysize + SAFE_DIST3,
                 MEM_TITLE_ADD + keybmpind[KEY_INPUT_CLR].nameStr[0] * TitleLengthMax,
                 SheetPage, keybmpind[KEY_INPUT_CLR].nameStr[0], keybmpind[KEY_INPUT_CLR].textColor[0]); //画出方框的文字
    Draw24x24Str(keyd[KEY_INPUT_CLRX].xpis + (keyd[KEY_INPUT_CLRX].xsize - 24 * 2) / 2,
                 keyd[KEY_INPUT_CLRX].ypis + keyd[KEY_INPUT_CLRX].ysize + SAFE_DIST3,
                 MEM_TITLE_ADD + keybmpind[KEY_INPUT_CLRX].nameStr[0] * TitleLengthMax,
                 SheetPage, keybmpind[KEY_INPUT_CLRX].nameStr[0], keybmpind[KEY_INPUT_CLRX].textColor[0]); //画出方框的文字
    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************
    ViewPage(usepageno); //设置显示缓存
    g_cttohome = 0;
    g_ct_insert_flag = 0;
    g_blkInset = 0;
    g_zhouDown = 1;
    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    Timer_ms = 30720; //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        keydata = get_keydata((KEYPAD *)keyd, keynum, 0); //获取键值

        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理
        //无效按键

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            if ((keyon == KEY_INPUT_UP) || (keyon == KEY_INPUT_DOWN))
            {
            }
            else if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {
            //特定情况下不生效按键
            if (((keydata == KEY_INPUT_CLRX) && (g_init_flag == 0)))
            {
                keydata = 0;
            }
            else
            {
                if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时
                {
                    keyon = keydata;
                    if (keyon == KEY_INPUT_SCRNSVR) //无按键特效
                    {
                    }
                    //非常规按键-//绘制颜色文字按键
                    else
                    {
                        DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);
                    }
                    Times = 0;
                    delay = KEYDT; //按键防抖次数
                }
                else if (keyon != keydata) //已有按键按下，不处理新按键信息
                {
                    keydata = 0;
                }

                if (Times > delay) //按键防抖
                {
                    if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                    {
                        beeponf = 1;

                        if (g_keyBellT) //按键时蜂鸣器发声时间
                            Beep_On(g_keyBellT);

                        switch (keyon) //按键按下标题提示语显示
                        {
                        case KEY_INPUT_PFBASE:
                            DrawFMenuStr((pfbaseflag) ? keybmpind[keyon].titleStr[1] : keybmpind[keyon].titleStr[0]);
                            break;
                        case KEY_INPUT_LFBASE:
                            DrawFMenuStr((lfbaseflag) ? keybmpind[keyon].titleStr[1] : keybmpind[keyon].titleStr[0]);
                            break;
                        case KEY_INPUT_PFOOT:
                            DrawFMenuStr((pfootf != 0x10) ? keybmpind[keyon].titleStr[1] : keybmpind[keyon].titleStr[0]);
                            break;
                        case KEY_INPUT_PINUP:
                            DrawFMenuStr((needlef == 0x20) ? keybmpind[keyon].titleStr[1] : keybmpind[keyon].titleStr[0]);
                            break;

                        case KEY_INPUT_0:
                        case KEY_INPUT_1:
                        case KEY_INPUT_2:
                        case KEY_INPUT_3:
                        case KEY_INPUT_4:
                        case KEY_INPUT_5:
                        case KEY_INPUT_6:
                        case KEY_INPUT_7:
                        case KEY_INPUT_8:
                        case KEY_INPUT_9:
                            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
                            DrawMFU32(TITLE_XPOS_C2, SAFE_DIST4, keyon - KEY_INPUT_0, 1, rect[0].colorT[0]);
                            break;
                        default:
                            DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                            break;
                        }
                        delay = KEYFT;
                    }
                    else if (beeponf == 1) //第二次进入
                    {
                        beeponf = 2;
                        delay = KEYNT;
                    }
                    else if (beeponf < 20)
                    {
                        beeponf++;
                    }

                    if ((keyon == KEY_INPUT_UP) || (keyon == KEY_INPUT_DOWN)) //带有长按连续功能按键的功能
                    {
                        keyoff = keyon;
                        key_on_flag1 = 1;
                    }
                    Times = 0; //当前
                }
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            if ((keyoff >= KEY_INPUT_0) && (keyoff <= KEY_INPUT_9))
            {
                temp_pitch = (temp_pitch % 100) * 10 + keyoff - KEY_INPUT_0;
                if (temp_pitch > LOOSEN_MAX)
                    temp_pitch = temp_pitch % 100;
                if (temp_pitch > LOOSEN_MAX)
                    temp_pitch = LOOSEN_MAX;
                dis_updata5 = 1;
            }
            else
            {
                switch (keyoff)
                {
                case KEY_INPUT_SCRNSVR:
                    pno = MENU_SCRNSVR;
                    plastno = MENU_INPUT;
                    break;
                case KEY_INPUT_BACK:
                    if ((plastno == MENU_CURSOR) || ((plastno == MENU_SCRNSVR) && (poldno[2] == MENU_CURSOR)))
                    {
                        if (F_FILETYPE == PAT_MIT)
                        { //三菱款
                            if ((SREG[g_draw_p - 4] != 0x1f01) && (SREG[g_pat_p - 2] != 0x1f) && (SREG[g_draw_p - 4] != 0x1e01) && (SREG[g_pat_p - 2] != 0x1e))
                            {
                                SREG[g_draw_p++] = 0x1e01;
                                SREG[g_draw_p++] = 0;
                                SREG[g_draw_p++] = 0;
                                SREG[g_draw_p++] = 0;
                                SREG[g_line_p++] = g_line_sum++;
                                SREG[g_pat_p++] = 0x1e;
                                SREG[g_pat_p++] = 0;
                                pno = MENU_INHELP;
                                hleppara = 0;
                                plastno = MENU_CURSOR;
                                break;
                            }
                        }
                        else if (F_FILETYPE == PAT_SEW)
                        { //兄弟款
                            pno = MENU_INHELP;
                            hleppara = 0;
                            plastno = MENU_CURSOR;
                            break;
                        }
                    }
                    pno = poldno[0];
                    pnoindex = 0;
                    plastno = MENU_INPUT;
                    break;
                case KEY_INPUT_ENTER:
                    Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                    if (!(S_CLAMP))
                    { //压板抬起状态
                        pno = MENU_RWHELP;
                        hleppara = 13;
                        poldno[pnoindex++] = MENU_INPUT;
                        break;
                    }
                    poldno[1] = MENU_INPUT;
                    pnoindex = 2;
                    plastno = MENU_INPUT;
                    g_Ptya = P_TYA;
                    if (temp_pitch < 1)
                        temp_pitch = 1;
                    g_pitch = temp_pitch;
                    g_speed = temp_speed;
                    g_modifyflag = 0;
                    g_array4[0][0] = 0;
                    g_home_2flag = 0;
                    g_feed_sew = 0;

                    f = Read_D(D_SYS + SYS_MAX_XL, 4, (U16 *)(&YREG[SYS_MAX_XL]));
                    if (f)
                    {
                        g_Mac.max_xl = (S16)(YREG[SYS_MAX_XL]);
                        g_Mac.max_xr = (S16)(YREG[SYS_MAX_XR]);
                        g_Mac.max_yu = (S16)(YREG[SYS_MAX_YU]);
                        g_Mac.max_yd = (S16)(YREG[SYS_MAX_YD]);
                        if ((g_Mac.max_xl < (-20000)) || (g_Mac.max_xl > 0))
                            g_Mac.max_xl = -20000;
                        if ((g_Mac.max_xr > 20000) || (g_Mac.max_xr < 0))
                            g_Mac.max_xr = 20000;
                        if ((g_Mac.max_yu > 10000) || (g_Mac.max_yu < 0))
                            g_Mac.max_yu = 10000;
                        if ((g_Mac.max_yd < (-10000)) || (g_Mac.max_yd > 0))
                            g_Mac.max_yd = -10000;
                    }
                    else
                    {
                        g_Mac.max_xl = -1000;
                        g_Mac.max_xr = 1000;
                        g_Mac.max_yu = 500;
                        g_Mac.max_yd = -500;
                    }

                    if (tmpsetPf != g_pfootd.base)
                    { //中压脚基准值不基于原来的基准值
                        g_pfootd.base = tmpsetPf;
                        //设置中压脚基准值
                        f = Write_Cmd(C_PFOOTACTION, g_pfootd.base, 0);
                        Read_Status();
                        Write_Cmd2(C_PFEST, 1, 2, 0x5a);
                        Read_Status();
                    }

                    if (tmpsetLf != g_tdtensiond.base)
                    { //张力线基准值不基于原来的基准值
                        g_tdtensiond.base = tmpsetLf;

                        //设置张力线基准值
                        f = Write_Cmd2(C_SETLFORCE, g_tdtensiond.base, 0, 0x5a); //向主板发送保存面线张力基准值命令
                        Read_Status();
                    }

                    g_ExCode = 0;
                    g_curExCode = 0;
                    g_curPinAng = 0;
                    g_curSetPara1 = 0;
                    g_curSetPara2 = 0;
                    g_pointPinAng = 0;
                    g_pointSetPara1 = 0;
                    g_pointSetPara2 = 0;
                    g_jogfunction = 0; //打板默认不输出附加功能
                    g_curPTtype = g_GreatPatType;
                    if ((!g_init_flag) || (g_temp_clr_flag))
                    {

                        g_modifyflag = 1;

                        g_num_mov_key = 0;
                        g_oxpos = 0;
                        g_oypos = 0;
                        g_dxpos = 0;
                        g_dypos = 0;
                        g_disxpos = 0;
                        g_disypos = 0;
                        g_point_num = 1; //圆,折线,曲线等已输入的点数
                        g_feed_flag = 0;
                        g_ct_status_flag = 0;
                        g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
                        g_array4[0][0] = 0;
                        g_input_method = 2; //输入模式
                        g_para_offset = 0;  //多重缝 不使用
                        g_zig_zag = 0;      //Z字缝
                        g_bt_mode = 0;      //倒缝
                        g_patd.PFmax = PF_ABS_MIN;
                        g_patd.PFmin = PF_ABS_MIN;
                        g_pf_absval = 0;
                        if (g_GreatPatType == 1)
                        { //三菱
                            for (ii = 8; ii < MAXSREG; ii++)
                                SREG[ii] = 0; //
                            g_init_flag = 2;
                            g_feed_flag = 0;
                            SREG[0] = 600; //文件号
                            SREG[1] = 0;
                            SREG[2] = 64000 - 0x40; //线条数据启始位置在SREG[32000]位置
                            SREG[4] = 0x3880;       //每组数据的针数据长最大为20000
                            SREG[5] = 1;            //2013.3.27
                            SREG[12] = 0x3e8;       //花样最小长度100mm
                            SREG[14] = 0x3e8;       //花样最小宽度100mm
                            SREG[16] = 0x454e;      //文件名
                            SREG[17] = 0x2057;
                            SREG[18] = 0x2020;
                            SREG[19] = 0x2020;
                            SREG[30] = 0x3045; //版本
                            SREG[31] = 0x3536;

                            SREG[10] = g_tdtensiond.base; //张力基准值
                            SREG[25] = g_pfootd.base;     //中压脚基准值

                            g_feedc = 0;      //目前针位置的步数
                            g_feedsum = 0;    //总步数
                            g_feedpat = 0;    //总针数
                            g_draw_p = 0x24;  //绘图数据当前位置指针
                            g_line_p = 32000; //线条数据当前位置指针
                            g_pat_p = 52000;  //针数据当前位置指针
                            g_line_sum = 0;   //线条总数

                            g_patd.draw_add = 0x24;
                            g_patd.line_add = (SREG[2] + 0x40) / 2;
                            g_patd.pat_add = (SREG[2] + 0x40 + ((((U32)(SREG[5]) << 16) + SREG[4]) / 2)) / 2;

                            g_lineforceValSetNow = g_tdtensiond.base;

                            AnaPattern(0, PAT_MIT, 0);
                        }
                        else if (g_GreatPatType == 2)
                        { //兄弟
                            Bor_CtBefDatAny((U32 *)&g_Ctstaddr, (U32 *)&g_CtPatLen, (U8 *)&g_oldspeed, 2);

                            g_Ctendaddr = g_Ctstaddr;
                            g_feedsum = g_patd.feed_sum;
                            g_feedc = g_patd.feed_sum;
                            g_pf_mode = 0;
                            g_Ctsavetimes = 0;
                            for (i = 0; i < MAXBLKBUF; i++)
                            {
                                BLKBUF[i] = 0;
                            }
                            g_pf_dis = 0;
                            g_lineforceValSetNow = 100; //计算夹线器张力值100%
                            g_home_2flag = 0;
                            g_patd.orgX = 0;
                            g_patd.orgY = 0;
                            g_updata_pf_valflg = 1;

                            Bor_CreatBack((U16 *)&g_Ctsavetimes, g_Ctstaddr, g_Ctendaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);

                            Bor_BaseAddr((U16 *)SREG, g_CtPatLen, &BorPFaddr, &BorLFaddr);

                            SREG[BorLFaddr] = g_tdtensiond.base; //张力基准值
                            SREG[BorPFaddr] = g_pfootd.base;     //中压脚基准值

                            AnaPattern(0, PAT_SEW, g_CtPatLen);
                        }
                        F_FILETYPE = g_GreatPatType;
                        if (g_ntohome != 1)
                        {
                            pno = MENU_RWHELP;
                            hleppara = 159;
                            poldno[pnoindex++] = MENU_INPUT;
                            //pno = MENU_INHELP; hleppara = 0;	// 正常使用这一行，先回原点再入打版
                        }
                        else
                        {
                            pno = MENU_CURSOR;
                        }
                        g_ntohome = 0;
                    }
                    else
                    { //保留原来花样
                        if (CheckDrawData(MENU_INPUT, 1) == 0)
                        { //超范围
                            break;
                        }

                        pno = MENU_CURSOR;
                        g_ntohome = 0;
                        g_modifyflag = 0;
                        if (S_PFOOT)
                        { //中压脚要先抬起
                            DREG[D_COMMAND] = C_PFOOTUP;
                            DREG[D_CMDSTATUS] = 0;
                            DREG[D_CMDPARA1] = 0;
                            f = Write_D(D_Address[DISP] + D_COMMAND, 3, (U16 *)(&DREG[D_COMMAND]));

                            for (i = 0; i < RDTIMES; i++)
                            {
                                Read_D(D_Address[DISP] + D_CMDSTATUS, 1, (U16 *)(&DREG[D_CMDSTATUS])); // 读状态
                                if ((DREG[D_CMDSTATUS]) == 100)
                                    break;
                                DelayMs(WAITTIME);
                            }
                        }
                        f = Read_D(D_Address[SYS] + SYS_PFOOTSET, 1, (U16 *)(&YREG[SYS_PFOOTSET]));
                        if (f == 0)
                        {
                            pno = MENU_RWHELP;
                            hleppara = 15;
                            return;
                        }

                        if ((g_pfootd.base > (PF_ABS_MAX - g_patd.PFmax)) || (g_pfootd.base < PF_ABS_MIN - g_patd.PFmin))
                        {
                            g_pfootd.base = PF_ABS_MIN - g_patd.PFmin;
                            //重新设置中压脚基准值
                            f = Write_Cmd(C_PFOOTACTION, g_pfootd.base, 0);
                            Read_Status();
                            Write_Cmd2(C_PFEST, 1, 2, 0x5a);
                            Read_Status();
                        }

                        g_point_num = 1;
                        g_feed_flag = 0;
                        g_ct_status_flag = 0;
                        g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);

                        g_array4[0][0] = 0;
                        g_input_method = 2; //输入模式
                        g_para_offset = 0;  //多重缝 不使用
                        g_zig_zag = 0;      //Z字缝
                        g_bt_mode = 0;      //倒缝

                        if (g_GreatPatType == 1)
                        { //输出花样为三菱
                            if (F_FILETYPE == PAT_SEW)
                            { //原兄弟花样,转为三菱类型
                                f = Bor_To_Mit(F_FILELEN);
                                if (f == 0)
                                { //部件数超过8000
                                    pno = MENU_RWHELP;
                                    hleppara = 98;
                                    break;
                                }
                                AnaPattern(0, PAT_MIT, 0);
                                g_modifyflag = 1;
                            }
                            ii = ((((U32)(SREG[5]) << 16) + SREG[4]) / 4);
                            g_temp_line_p = (SREG[2] + 0x40) / 2;
                            g_temp_pat_p = g_temp_line_p + ii;
                            if ((g_temp_line_p <= 32000) && (g_temp_pat_p <= 52000) && (ii < 20000))
                            {
                                if ((S_CLAMP) || (P_OST == 1))
                                {
                                    g_init_flag = 3;
                                    g_draw_p = g_temp_line_p;
                                    g_line_p = 32000 + ii;
                                    g_pat_p = 52000 + ii * 2;

                                    n = g_temp_pat_p + ii * 2;
                                    g_dxpos = 0;
                                    g_dypos = 0;

                                    g_oxpos = 0;
                                    g_oypos = 0;
#if PATRULES_ORG_OFFSET
                                    if (SREG[3] == 7) //新增-修改原点位置
                                    {
                                        g_oxpos = (S16)(SREG[6]);
                                        g_oypos = (S16)(SREG[7]);
                                    }
#endif
                                    g_feed_sew = 0xff;
                                    for (; ii > 0; ii--)
                                    {
                                        SREG[--g_pat_p] = SREG[--n];
                                        dat = SREG[n];
                                        SREG[--g_pat_p] = SREG[--n];
                                        if (((SREG[n] & 0x00ff) == 0x61) || ((SREG[n] & 0x00ff) == 0x41) || ((SREG[n] & 0x00ff) == 0x21) || ((SREG[n] & 0x00ff) == 0x1) || ((SREG[n] & 0x00ff) == 0x1b) || ((SREG[n] & 0x00ff) == 0x3))
                                        {
                                            if (g_feed_sew == 0xff)
                                            {
                                                if ((SREG[n] == 0x3) || (SREG[n] == 0x1b))
                                                    g_feed_sew = 0;
                                                else
                                                    g_feed_sew = 1;
                                            }
                                            ch = (U8)(dat);
                                            if (ch >= 0x80)
                                            {
                                                ch = ch - 0x80;
                                                g_oxpos = g_oxpos - (S16)(ch);
                                            }
                                            else
                                            {
                                                g_oxpos = g_oxpos + (S16)(ch);
                                            }
                                            ch = (U8)((U16)(dat) >> 8);
                                            if (ch >= 0x80)
                                            {
                                                ch = ch - 0x80;
                                                g_oypos = g_oypos - (S16)(ch);
                                            }
                                            else
                                            {
                                                g_oypos = g_oypos + (S16)(ch);
                                            }
                                        }
                                        else if ((g_feed_sew == 0xff) && (SREG[n] == 0x2))
                                        {
                                            g_feed_sew = 0;
                                        }
                                        else if (SREG[n] == 0x05)
                                        { //功能1
                                            excode ^= 0x01;
                                        }
                                        else if (SREG[n] == 0x0b)
                                        { //功能2
                                            excode ^= 0x02;
                                        }
                                        else if (SREG[n] == 0x0c)
                                        { //功能3
                                            excode ^= 0x04;
                                        }
                                        else if (SREG[n] == 0x0d)
                                        { //功能4
                                            excode ^= 0x08;
                                        }
                                        else if (SREG[n] == 0x001d)
                                        { //功能5
                                            excode ^= 0x10;
                                        }
                                        else if (SREG[n] == 0x011d)
                                        { //功能6
                                            excode ^= 0x20;
                                        }
                                        else if (SREG[n] == 0x021d)
                                        { //功能7
                                            excode ^= 0x40;
                                        }
                                        else if (SREG[n] == 0x031d)
                                        { //功能8
                                            excode ^= 0x80;
                                        }
                                    }
                                    if (g_feed_sew == 0xff)
                                        g_feed_sew = 0;
                                    Comm_Move(g_oxpos, g_oypos, 120, MENU_INPUT, 0, 0);

                                    ii = ((((U32)(SREG[5]) << 16) + SREG[4]) / 4);
                                    for (; ii > 0; ii--)
                                    {
                                        SREG[--g_line_p] = SREG[--n];
                                    }
                                    for (ii = g_draw_p; ii < 32000; ii++)
                                    {
                                        SREG[ii] = 0;
                                    }

                                    g_line_p = 32000 + ((((U32)(SREG[5]) << 16) + SREG[4]) / 4);
                                    g_pat_p = 52000 + ((((U32)(SREG[5]) << 16) + SREG[4]) / 2);
                                    SREG[2] = 64000 - 0x40;
                                    SREG[4] = 0x3880;
                                    SREG[5] = 1;
                                    ///////////////////////////////
                                    g_temp_line_p = SREG[g_draw_p - 4];
                                    g_temp_pat_p = SREG[g_pat_p - 2];
                                    if (((g_temp_line_p == 0x1f01) && (g_temp_pat_p == 0x1f)) || ((g_temp_line_p == 0x1e01) && (g_temp_pat_p == 0x1e)))
                                    {
                                        g_draw_p -= 4;
                                        g_line_p -= 1;
                                        g_pat_p -= 2;
                                        SREG[g_draw_p] = 0;

                                        ///////////////////////////////////////////////ADD ON 1.16

                                        g_temp_line_p = SREG[g_draw_p - 4];
                                        g_temp_pat_p = SREG[g_pat_p - 2];
                                        if ((g_temp_line_p == 0x0201) && (g_temp_pat_p == 0x02))
                                        {
                                            g_draw_p -= 4;
                                            g_line_p -= 1;
                                            g_pat_p -= 2;
                                            SREG[g_draw_p] = 0;
                                            g_DoTrim = 1; //删除剪线标志
                                        }
                                    }
                                    g_line_sum = (U16)((SREG[g_line_p - 1]) & 0x3fff) + 1;
                                    g_feedc = g_line_p - (SREG[2] + 0x40) / 2;
                                    g_feedsum = g_feedc;

                                    g_pointPinAng = mit_getExCodeData(52000, 52000 + g_feedc * 2, 0);
                                    g_pointSetPara1 = mit_getExCodeData(52000, 52000 + g_feedc * 2, 1);
                                    g_pointSetPara2 = mit_getExCodeData(52000, 52000 + g_feedc * 2, 2);
                                    sendExCodeCmd();
                                    for (ii = 0x24; ii < g_draw_p; ii += 4)
                                    {
                                        if (SREG[ii] == 0x601)
                                        {
                                            g_home_2flag = 1;
                                            g_home_2xpos = 0;
                                            g_home_2ypos = 0;
                                            for (; ii > 0x24; ii -= 4)
                                            {
                                                g_home_2xpos += (S16)(SREG[ii - 2]);
                                                g_home_2ypos += (S16)(SREG[ii - 1]);
                                            }
                                            break;
                                        }
                                    }
                                }
                                else
                                {
                                    pno = MENU_RWHELP;
                                    hleppara = 13;
                                    break;
                                }
                            }
                            else
                            {
                            }

                            SREG[10] = g_tdtensiond.base; //张力基准值
                            SREG[25] = g_pfootd.base;     //中压脚基准值
                            g_patd.draw_add = 0x24;
                            g_patd.line_add = (SREG[2] + 0x40) / 2;
                            g_patd.pat_add = (SREG[2] + 0x40 + ((((U32)(SREG[5]) << 16) + SREG[4]) / 2)) / 2;

                            g_lineforceValSet = g_tdtensiond.base;
                            lforceval = Mit_CailPadOffestLF(g_feedsum, 0);
                            g_lineforceValSetNow = g_lineforceValSet + lforceval;
                            g_pf_absval = Mit_CailPadOffestPF(g_jog_enpoint, 1, 0);
                            g_disxpos = g_oxpos;
                            g_disypos = g_oypos;
                        }
                        else if (g_GreatPatType == 2)
                        { //输出花样为兄弟
                            g_CtPatLen = F_FILELEN;
                            if (F_FILETYPE == PAT_MIT)
                            { //原花样为三菱
                                Mit_To_Bor((U32 *)&g_CtPatLen);
                                g_modifyflag = 1;
                            }

                            AnaPattern(0, PAT_SEW, g_CtPatLen);

                            if ((g_patd.patmX > 2 * (g_Mac.max_xr + 1)) || (g_patd.patiX < 2 * (g_Mac.max_xl - 1)) || (g_patd.patmY > 2 * (g_Mac.max_yu + 1)) || (g_patd.patiY < 2 * (g_Mac.max_yd - 1)))
                            { //图形超范围
                                pno = MENU_RWHELP;
                                poldno[pnoindex] = MENU_INPUT;
                                pnoindex++;
                                hleppara = 139;
                                break;
                            }
                            Bor_feedInfo(g_patd.feed_sum, g_CtPatLen, &tmpBorcmd, (S16 *)&g_oxpos, (S16 *)&g_oypos, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &tmpBorpooft, &Borpfdis); //查找当前原花样结束点坐标

                            Comm_Move(g_oxpos + g_dxpos, g_oypos + g_dypos, 120, MENU_INPUT, 1, 1); //移动到花样结束点坐标
                            g_oxpos = g_oxpos + g_dxpos;
                            g_oypos = g_oypos + g_dypos;
                            g_disxpos = g_oxpos;
                            g_disypos = g_oypos;
                            g_dxpos = 0;
                            g_dxpos = 0;

                            excode = g_tExCode;

                            Bor_CtBefDatAny((U32 *)&g_Ctstaddr, (U32 *)&g_CtPatLen, (U8 *)&g_oldspeed, 1);
                            g_feedsum = g_patd.feed_sum;
                            g_feedc = g_patd.feed_sum;
                            g_Ctendaddr = g_Ctstaddr;
                            g_pf_mode = 0;
                            g_Ctsavetimes = 0;
                            for (i = 0; i < MAXBLKBUF; i++)
                            {
                                BLKBUF[i] = 0;
                            }
                            g_pf_absval = tmpBorpooft;

                            g_lineforceValSetNow = Bor_CreatCalLF(g_Ctstaddr, g_CtPatLen); //计算夹线器张力值
                            if ((g_patd.orgX == 0) && (g_patd.orgY == 0))
                            {
                                g_home_2flag = 0;
                            }
                            else
                            {
                                g_home_2flag = 1;
                            }

                            g_updata_pf_valflg = 1;

                            Bor_CreatBack((U16 *)&g_Ctsavetimes, g_Ctstaddr, g_Ctendaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);

                            Bor_BaseAddr((U16 *)SREG, g_CtPatLen, &BorPFaddr, &BorLFaddr);

                            SREG[BorLFaddr] = g_tdtensiond.base; //张力基准值
                            SREG[BorPFaddr] = g_pfootd.base;     //中压脚基准值
                        }
                        F_FILETYPE = g_GreatPatType;

                        if (excode != 0)
                        {
                            OutputExcode(excode, MENU_INPUT);
                        }
                        sendExCodeCmd();
                    }

                    g_pf_dis = 0;

                    g_pf_absval += g_pfootd.base;
                    g_updata_pf_valflg = 1;

                    Write_Cmd(C_PFOOTACTION, g_pf_absval, 0); //记录打板开始时中压脚高度
                    Read_Status();
                    //						if(g_GreatPatType != gBatType){
                    //							gBatType = g_GreatPatType;
                    //							SaveBatType(gBatType);
                    //						}

                    g_maxX = g_patd.patmX;
                    g_minX = g_patd.patiX;
                    g_maxY = g_patd.patmY;
                    g_minY = g_patd.patiY;
                    if (g_maxX == 0 && g_minX == 0 && g_maxY == 0 && g_minY == 0)
                    {
                        g_maxX = 200;
                        g_minX = -200;
                        g_maxY = 200;
                        g_minY = -200;
                    }
                    //Write_Cmd(C_LDOWMPF, 0, 0);		//记录打板开始时中压脚高度
                    //Read_Status();
                    break;

                case KEY_INPUT_CLRX:
                    g_temp_clr_flag = 0;
                    pfbaseflag = 0;
                    lfbaseflag = 0;
                    dis_updata2 = 1;
                    dis_updata3 = 1;
                    dis_updata4 = 1;
                    break;

                case KEY_INPUT_CLR:
                    g_temp_clr_flag = 1;
                    pfbaseflag = 1;
                    lfbaseflag = 1;
                    dis_updata2 = 1;
                    dis_updata3 = 1;
                    dis_updata4 = 1;
                    break;

                case KEY_INPUT_PFBASE:
                    if (pfbaseflag)
                        pfbaseflag = 0;
                    else
                        pfbaseflag = 1;
                    dis_updata3 = 1;
                    break;

                case KEY_INPUT_LFBASE:
                    if (lfbaseflag)
                        lfbaseflag = 0;
                    else
                        lfbaseflag = 1;
                    dis_updata4 = 1;
                    break;

                case KEY_INPUT_PFOOT:
                    Send_Pfoot(0, MENU_INPUT, 0);
                    break;

                case KEY_INPUT_PINUP:
                    Write_Cmd1(C_NEEDLEUP, 0, 0);
                    break;

                case KEY_INPUT_H:
                    temp_speed = 0x60;
                    dis_updata1 = 1;
                    break;

                case KEY_INPUT_MD1:
                    temp_speed = 0x40;
                    dis_updata1 = 1;
                    break;
                case KEY_INPUT_MD2:
                    temp_speed = 0x20;
                    dis_updata1 = 1;
                    break;

                case KEY_INPUT_L:
                    temp_speed = 0x0;
                    dis_updata1 = 1;
                    break;

                case KEY_INPUT_CLEAN:
                    temp_pitch = 0;
                    dis_updata5 = 1;
                    break;

                case KEY_INPUT_UP:
                    if (temp_pitch < LOOSEN_MAX)
                        temp_pitch++;
                    dis_updata5 = 1;
                    break;

                case KEY_INPUT_DOWN:
                    if (temp_pitch > 1)
                        temp_pitch--;
                    dis_updata5 = 1;
                    break;
                }
            }
            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            if (keyon == KEY_INPUT_SCRNSVR) //不需要显示的按键
            {
            }

            //非常规按键-//绘制颜色文字按键
            else //常规按键
            {
                DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);
            }

            keyon = 0;
            beeponf = 0;
            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
            Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                         SheetPage, rect[0].index[0], rect[0].colorT[0]); //显示回花样设计
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if (Timerms > 1000)
        {
            Timerms = 0;
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1)
        {
            // ErrorMsg(MENU_LINEFORCE);
        }
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*begin]**********************************************************
        if (beeponf == 0)
        {
        }
        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*end]**********************************************************

        // /[速度按键刷新*begin]**********************************************************
        if (dis_updata1)
        { //速度选择
            dis_updata1 = 0;

            if (temp_speed == 0x60)
                f = KEY_INPUT_H;
            else if (temp_speed == 0x40)
                f = KEY_INPUT_MD1;
            else if (temp_speed == 0x20)
                f = KEY_INPUT_MD2;
            else
                f = KEY_INPUT_L;
            for (i = KEY_INPUT_H; i <= KEY_INPUT_L; i++)
            {
                DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                           (f == i) ? keybmpind[i].border[1] : keybmpind[i].border[0],
                           (f == i) ? keybmpind[i].icon[1] : keybmpind[i].icon[0]);
            }
        }
        // /[速度按键刷新*end]**********************************************************

        // /[保留新建按钮刷新*begin]**********************************************************
        if (dis_updata2)
        { //删除、不删
            dis_updata2 = 0;
            if (g_temp_clr_flag)
                f = KEY_INPUT_CLR;
            else
                f = KEY_INPUT_CLRX;
            for (i = KEY_INPUT_CLRX; i <= KEY_INPUT_CLR; i++)
            {
                if ((i == KEY_INPUT_CLRX) && (g_init_flag == 0))
                {
                    BmpFillRect(keyd[i].xpis, keyd[i].ypis,
                                keyd[i].xsize, keyd[i].ysize + SAFE_DIST10);
                }
                else
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               (f == i) ? keybmpind[i].border[1] : keybmpind[i].border[0],
                               (f == i) ? keybmpind[i].icon[1] : keybmpind[i].icon[0]);
                }
            }
        }
        // /[保留新建按钮刷新*end]**********************************************************

        // /[中压脚继承按键刷新*begin]**********************************************************
        if (dis_updata3)
        { //中压脚
            dis_updata3 = 0;
            tmpsetPf = (pfbaseflag > 0) ? (g_temp_clr_flag ? 0 : -g_patd.PFmin) : g_pfootd.base;

            DrawButton(keyd[KEY_INPUT_PFBASE], (U16 *)(ADD_ICONBMP),
                       (pfbaseflag) ? keybmpind[KEY_INPUT_PFBASE].border[1] : keybmpind[KEY_INPUT_PFBASE].border[0],
                       (pfbaseflag) ? keybmpind[KEY_INPUT_PFBASE].icon[1] : keybmpind[KEY_INPUT_PFBASE].icon[0]);
            DrawFS32P(keyd[KEY_INPUT_PFBASE].xpis + keyd[KEY_INPUT_PFBASE].xsize / 2,
                      keyd[KEY_INPUT_PFBASE].ypis + SAFE_DIST5,
                      tmpsetPf, 3, 1,
                      (pfbaseflag) ? keybmpind[KEY_INPUT_PFBASE].textColor[1] : keybmpind[KEY_INPUT_PFBASE].textColor[0]);
        }
        // /[中压脚继承按键刷新*end]**********************************************************

        // /[松线继承按键刷新*begin]**********************************************************
        if (dis_updata4)
        { //夹线器
            dis_updata4 = 0;
            tmpsetLf = (lfbaseflag > 0) ? 60 : g_tdtensiond.base;

            DrawButton(keyd[KEY_INPUT_LFBASE], (U16 *)(ADD_ICONBMP),
                       (lfbaseflag) ? keybmpind[KEY_INPUT_LFBASE].border[1] : keybmpind[KEY_INPUT_LFBASE].border[0],
                       (lfbaseflag) ? keybmpind[KEY_INPUT_LFBASE].icon[1] : keybmpind[KEY_INPUT_LFBASE].icon[0]);
            DrawFU32Z(keyd[KEY_INPUT_LFBASE].xpis + keyd[KEY_INPUT_LFBASE].xsize / 2 + SAFE_DIST1,
                      keyd[KEY_INPUT_LFBASE].ypis + keyd[KEY_INPUT_LFBASE].ysize - TYPE_SIZE26 - SAFE_DIST5,
                      tmpsetLf, 2,
                      (lfbaseflag) ? keybmpind[KEY_INPUT_LFBASE].textColor[1] : keybmpind[KEY_INPUT_LFBASE].textColor[0]);
        }
        // /[松线继承按键刷新*end]**********************************************************

        // /[针距数据刷新*begin]**********************************************************
        if (dis_updata5)
        {
            dis_updata5 = 0;
            DrawFillRect(rect[RECT_INPUT_PIN_STR].xpis + SAFE_DIST2, rect[RECT_INPUT_PIN_STR].ypis + SAFE_DIST2,
                         rect[RECT_INPUT_PIN_STR].xsize - 2 * SAFE_DIST2, rect[RECT_INPUT_PIN_STR].ysize - 2 * SAFE_DIST2,
                         rect[RECT_INPUT_PIN_STR].colorB[0]);
            DrawMFS32P(rect[RECT_INPUT_PIN_STR].xpis + (rect[RECT_INPUT_PIN_STR].xsize - 4 * 12) / 2,
                       rect[RECT_INPUT_PIN_STR].ypis + (rect[RECT_INPUT_PIN_STR].ysize - 24) / 2,
                       temp_pitch, 4, 1, rect[RECT_INPUT_PIN_STR].colorT[0]);
        }
        // /[针距数据刷新*end]**********************************************************

        // /[显示压脚上升下降*begin]**********************************************************
        if (pfootf != (U16)(S_PFOOT))
        {
            pfootf = (U16)(S_PFOOT);
            DrawButton(keyd[KEY_INPUT_PFOOT], (U16 *)(ADD_ICONBMP),
                       keybmpind[KEY_INPUT_PFOOT].border[0],
                       (pfootf == 0) ? keybmpind[KEY_INPUT_PFOOT].icon[1] : keybmpind[KEY_INPUT_PFOOT].icon[0]);
        }
        // /[显示压脚上升下降*end]**********************************************************

        // /[显示针上升下降*begin]**********************************************************
        if (needlef != (U8)(S_NEEDLE))
        {
            needlef = S_NEEDLE;
            DrawButton(keyd[KEY_INPUT_PINUP], (U16 *)(ADD_ICONBMP),
                       keybmpind[KEY_INPUT_PINUP].border[0],
                       (needlef == 0x20) ? keybmpind[KEY_INPUT_PINUP].icon[1] : keybmpind[KEY_INPUT_PINUP].icon[0]);
        }
        // /[显示针上升下降*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if (pno != MENU_INPUT)
        {
            plastno = MENU_INPUT;
            break;
        }
        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

/***************************************/
#define TLFNADD_CURSOR 0
#define TLFNLEN_CURSOR 70 //0
#define TLFNADD_CALLFILE (TLFNADD_CURSOR + TLFNLEN_CURSOR)
#define TLFNLEN_CALLFILE 30
#define TLFNADD_READCOV (TLFNADD_CALLFILE + TLFNLEN_CALLFILE)
#define TLFNLEN_READCOV 33
#define TLFNADD_CTTACK 0
#define TLFNLEN_CTTACK 32
#define TLFNADD_CTTACK1 TLFNLEN_CTTACK + 1
#define TLFNLEN_CTTACK1 4

#define KEY_CURSOR_SCRNSVR 1 //1 屏保
#define KEY_CURSOR_MENU 2    //2 菜单
#define KEY_CURSOR_ENTER 3   //3 确认

#define KEY_CURSOR_METHOD 4  //4 直线
#define KEY_CURSOR_OFFSET 5  //5 多重缝
#define KEY_CURSOR_ZIG 6     //6 Z字缝
#define KEY_CURSOR_TACKING 7 //7 前后倒缝
#define KEY_CURSOR_FEED 8    //8 空松
#define KEY_CURSOR_SPEED 9   //9 变更速度
#define KEY_CURSOR_CODE 10   //10 代码
#define KEY_CURSOR_RETURN 11 //11 取消一段
#define KEY_CURSOR_HOME 12   //12 回原点

#define KEY_CURSOR_PFOOT 13    //13 抬压脚上升下降
#define KEY_CURSOR_NEEDLE 14   //14 针上升下降
#define KEY_CURSOR_PFOOTSET 15 //15 压脚高度设置
#define KEY_CURSOR_CANCEL 16   //16 取消选中点
#define KEY_CURSOR_ZIN 17      //17 放大
#define KEY_CURSOR_ZOUT 18     //18 缩小
#define KEY_CURSOR_IMG 19      //19 拖动
#define KEY_CURSOR_MUP 20      //20 寸动加
#define KEY_CURSOR_MDOWN 21    //21 寸动减
#define KEY_CURSOR_NULL1 22    //22 预留1
#define KEY_CURSOR_NULL2 23    //23 预留2
#define KEY_CURSOR_NULL3 24    //24 预留3
#define KEY_CURSOR_MAX1 25

#define KEY_CURSOR_MUL 25  //25 左上
#define KEY_CURSOR_MUM 26  //26 上
#define KEY_CURSOR_MUR 27  //27 右上
#define KEY_CURSOR_MML 28  //28 左
#define KEY_CURSOR_MMSP 29 //29 压框速度
#define KEY_CURSOR_MMR 30  //30 右
#define KEY_CURSOR_MDL 31  //31 左下
#define KEY_CURSOR_MDM 32  //32 下
#define KEY_CURSOR_MDR 33  //33 右下
#define KEY_CURSOR_MAX2 9

#define KEY_CURSOR_DUP 34    //34 +1
#define KEY_CURSOR_DDOWN 35  //35 -1
#define KEY_CURSOR_NUMMSP 36 //36 压框速度
#define KEY_CURSOR_CLR 37    //37 清除1位
#define KEY_CURSOR_SIGN 38   //38 +/-
#define KEY_CURSOR_XY 39     //39 X/Y
#define KEY_CURSOR_0 40      //40 0
#define KEY_CURSOR_1 41      //41 1
#define KEY_CURSOR_2 42      //42 2
#define KEY_CURSOR_3 43      //43 3
#define KEY_CURSOR_4 44      //44 4
#define KEY_CURSOR_5 45      //45 5
#define KEY_CURSOR_6 46      //46 6
#define KEY_CURSOR_7 47      //47 7
#define KEY_CURSOR_8 48      //48 8
#define KEY_CURSOR_9 49      //49 9
#define KEY_CURSOR_DX 50     //50 选中X
#define KEY_CURSOR_DY 51     //51 选中Y
#define KEY_CURSOR_MAX3 18

#define KEY_CURSOR_TOP 52 //52 吸附
#define KEY_CURSOR_MAX4 1

#define KEY_CURSOR_INSERT 53 //53 段插入
#define KEY_CURSOR_MAX5 1

#define KEY_CURSOR_MAX 54

//内容详见 function.c中的void dis_data(U16 dat, U8 div)
#define RECT_CURSOR_X_TIT 1     //1 X坐标-标题
#define RECT_CURSOR_X_STR 2     //2 X坐标-内容
#define RECT_CURSOR_Y_TIT 3     //3 Y坐标-标题
#define RECT_CURSOR_Y_STR 4     //4 Y坐标-内容
#define RECT_CURSOR_XX_TIT 5    //5 X挪动值-标题
#define RECT_CURSOR_XX_STR 6    //6 X挪动值-内容
#define RECT_CURSOR_XY_TIT 7    //7 Y挪动值-标题
#define RECT_CURSOR_XY_STR 8    //8 Y挪动值-内容
#define RECT_CURSOR_PIN_TIT 9   //9 针距-标题
#define RECT_CURSOR_PIN_STR 10  //10 针距-内容
#define RECT_CURSOR_SP_TIT 11   //11 速度-标题
#define RECT_CURSOR_SP_STR 12   //12 速度-内容
#define RECT_CURSOR_CODE_TIT 13 //13 代码-标题
#define RECT_CURSOR_CODE_STR 14 //14 代码-内容
#define RECT_CURSOR_PINS_TIT 15 //15 针数-标题
#define RECT_CURSOR_PINS_STR 16 //16 针数-内容
#define RECT_CURSOR_P_TIT 17    //17 P-标题
#define RECT_CURSOR_P_STR 18    //18 P-内容
#define RECT_CURSOR_LF_TIT 19   //19 松线-标题
#define RECT_CURSOR_LF_STR 20   //20 松线-内容
#define RECT_CURSOR_PF_TIT 21   //21 压脚高度-标题
#define RECT_CURSOR_PF_STR 22   //22 压脚高度-内容
#define RECT_CURSOR_XPF_TIT 23  //23 压脚高度绝对值-标题
#define RECT_CURSOR_XPF_STR 24  //24 压脚高度绝对值-内容
#define RECT_CURSOR_LINEX 25    //25 窗口提示线X
#define RECT_CURSOR_LINEY 26    //26 窗口提示线Y
#define RECT_CURSOR_MAX 27

void Menu_CtCursor(void)
{

    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
                                            /****按键相关参数end****/

    /****标志位相关参数begin****/
    U8 g_ct_insert_flag_temp; //打板插入标志缓存

    U16 okeyxpct = 0, okeyypct = 0, stkeyxpct = 0, stkeyypct = 0;
    U32 i;
    U8 dis_updata = 1, dis_updata1 = 1, dis_updata2 = 0, dis_updata3 = 1, dis_updata4 = 1;
    U32 x, y, n, ii, dat = 0, dat1;
    U8 ll = 0;
    U8 f;
    U8 tmp_pfoot = 0xff, tmp_needle = 0xff;
    S16 tmpxpos, tmpypos;
    S16 xx, yy;
    //	U16 runf1=0,runf2=0;
    U16 dat4;
    U8 Up = 1;
    U8 Dn = 1;
    U8 uplock = 1;
    S8 pfootval = 0;
    S16 PfootOffVal, old_PfootOffVal;
    S16 temp_PfVal;
    S32 datxy = 0;
    U8 SpeedClass = 0;
    S8 lforceval = 0;
    U32 addr1 = 0;
    U8 exflag = 0;
    U8 dismove = 0;
    U8 stflag = 0;
    U16 Borcmd;
    S16 /*tmpxdat =0,tmpydat =0,*/ tmpxdat1 = 0, tmpydat1 = 0;
    S8 Borpooft = 0, Borpfdis;
    U32 tmpCreatstaddr = 0, tmpCreatstaddr1;
    U32 ctBackSaddr = 0, ctBackEaddr = 0;
    U8 excode = 0;
    U8 movfeed = 0;
    U8 vflag = 0;
    U8 isHome = 0;
    //	U8 dp =0;
    U8 dis_updataP = 1;                    //显示花样
    S32 scale = 0, scale1 = 0, vscale = 0; // scale:花样最佳倍率 scale1:当前缩放倍率 vscale:总倍率
    U8 bResetCaonvas = 0;
    S32 posx1, posy1; //光标的坐标-屏幕坐标系
    S8 mult1 = 1, mult2 = 1, tmuly = 1;
    S16 xorg = 0, yorg = 0;
    //S16 dxorg =0, dyorg =0;
    const U16 ORG_X = CONVAS_ORG_PX5, ORG_Y = CONVAS_ORG_PY5;
    //	U8 borBatPf = 0;
    //    U8 ch = 0;
    U16 tBorcmd;
    S16 ttemp_oxpos1, ttemp_oypos1, tdxpos, tdypos;
    U8 toldspeed;
    S8 tBorpooft, tBorpfdis;
    S16 fpx, fpy;
    S32 xo = 0, yo = 0;
    U16 cfeed = 0;
    S16 cpx = 0, cpy = 0, cpx0 = 0, cpy0 = 0;
    S16 vposx = 0, vposy = 0;
    U8 pressKey = 0;
    S16 nearpx, nearpy, onearpx = 0, onearpy = 0;
    U8 getNearflag = 0 /*,vnear =0*/;
    U8 tonear = 0, otonear = 0;
    // S32 nearposx = 0, nearposy = 0;
    U8 ct_insert_flag = g_ct_insert_flag, old_ct_insert_flag = 0xff; //ct_insert_flag 吸附功能
    PINMSG mitPinmsg = {0};
    U8 tfeed_flag = 0 /*, tpara_offset = 0*/;
    U16 tpoint_num = 0, tfeedsum = 0, tfeedc = 0, tfeed = 0;
    static U8 EnUPflag = 0;
    static U8 dis_pattern = 0;
    const U8 mult3 = 1;
    U8 chEditflagTemp = g_editflag, bEditFlashFlag = 0;
    U8 patRulesTmp = PATRULES_CREATE2;

    // #endif
    /****标志位相关参数end***/
    const U32 keylitd[] = {0x00000000, 0x00000000, 0x00004000, 0x00020000, 0x00000002,
                           0x00000010, 0x00000080, 0x00000400, 0x00000004, 0x00000200,
                           0x00000040, 0x00000100, 0x00000020, 0x00000001, 0x00000008,
                           0x00080000, 0x00000800};

    // const U8 keynum = {KEY_CURSOR_MAX};
    const KEYPAD patV = {CONVAS_PX5, CONVAS_PY5, CONVAS_X5, CONVAS_Y5};
    const KEYPAD keyd[] = {
        {0, 0, 0, 0},
        {0, 0, 128, 32},                     //1 屏保
        {TYPE_X1, TYPE_Y4, KEY_X1, KEY_Y1},  //2 菜单
        {TYPE_X11, TYPE_Y4, KEY_X1, KEY_Y1}, //3 确认

        {TYPE_X23, TYPE_Y27, KEY_X6, KEY_Y6},                       //4 直线
        {TYPE_X23 + KEY_X6, TYPE_Y27, KEY_X6, KEY_Y6},              //5 多重缝
        {TYPE_X23 + KEY_X6 * 2, TYPE_Y27, KEY_X6, KEY_Y6},          //6 Z字缝
        {TYPE_X23 + KEY_X6 * 3, TYPE_Y27, KEY_X6, KEY_Y6},          //7 前后倒缝
        {TYPE_X23, TYPE_Y27 + KEY_Y6, KEY_X6, KEY_Y6},              //8 空松
        {TYPE_X23 + KEY_X6, TYPE_Y27 + KEY_Y6, KEY_X6, KEY_Y6},     //9 变更速度
        {TYPE_X23 + KEY_X6 * 2, TYPE_Y27 + KEY_Y6, KEY_X6, KEY_Y6}, //10 代码
        {TYPE_X23 + KEY_X6 * 3, TYPE_Y27 + KEY_Y6, KEY_X6, KEY_Y6}, //11 取消一段

        {TYPE_X2, TYPE_Y4, KEY_X1, KEY_Y1},                        //12 回原点
        {TYPE_X3, TYPE_Y4, KEY_X1, KEY_Y1},                        //13 抬压脚上升下降
        {TYPE_X4, TYPE_Y4, KEY_X1, KEY_Y1},                        //14 针上升下降
        {TYPE_X5, TYPE_Y4, KEY_X1, KEY_Y1},                        //15 压脚高度设置
        {TYPE_X10, TYPE_Y4, KEY_X1, KEY_Y1},                       //16 取消选中点
        {TYPE_X7, TYPE_Y4, KEY_X1, KEY_Y1},                        //17 放大
        {TYPE_X6, TYPE_Y4, KEY_X1, KEY_Y1},                        //18 缩小
        {CONVAS_PX5, CONVAS_PY5, CONVAS_X5, CONVAS_Y5},            //19 拖动
        {TYPE_X1, TYPE_Y26, KEY_X1, KEY_Y1},                       //20 寸动加
        {TYPE_X1, TYPE_Y26 + KEY_Y1 + SAFE_DIST1, KEY_X1, KEY_Y1}, //21 寸动减
        {0, 0, 0, 0},                                              //22 预留1
        {0, 0, 0, 0},                                              //23 预留2
        {0, 0, 0, 0},                                              //24 预留3

        {TYPE_X9, TYPE_Y28, KEY_X1, KEY_Y1},                           //25 左上
        {TYPE_X9 + KEY_X1, TYPE_Y28, KEY_X1, KEY_Y1},                  //26 上
        {TYPE_X9 + KEY_X1 * 2, TYPE_Y28, KEY_X1, KEY_Y1},              //27 右上
        {TYPE_X9, TYPE_Y28 + KEY_Y1, KEY_X1, KEY_Y1},                  //28 左
        {TYPE_X9 + KEY_X1, TYPE_Y28 + KEY_Y1, KEY_X1, KEY_Y1},         //29 压框速度
        {TYPE_X9 + KEY_X1 * 2, TYPE_Y28 + KEY_Y1, KEY_X1, KEY_Y1},     //30 右
        {TYPE_X9, TYPE_Y28 + KEY_Y1 * 2, KEY_X1, KEY_Y1},              //31 左下
        {TYPE_X9 + KEY_X1, TYPE_Y28 + KEY_Y1 * 2, KEY_X1, KEY_Y1},     //32 下
        {TYPE_X9 + KEY_X1 * 2, TYPE_Y28 + KEY_Y1 * 2, KEY_X1, KEY_Y1}, //33 右下

        {TYPE_X9 + KEY_X2 * 2, TYPE_Y28 + KEY_Y2 * 3, KEY_X2, KEY_Y2}, //34 +1
        {TYPE_X9 + KEY_X2 * 3, TYPE_Y28 + KEY_Y2 * 3, KEY_X2, KEY_Y2}, //35 -1
        {TYPE_X9, TYPE_Y28, KEY_X2, KEY_Y2},                           //36 压框速度
        {TYPE_X9, TYPE_Y28 + KEY_Y2, KEY_X2, KEY_Y2},                  //37 清除1位
        {TYPE_X9, TYPE_Y28 + KEY_Y2 * 2, KEY_X2, KEY_Y2},              //38 +/-
        {TYPE_X9, TYPE_Y28 + KEY_Y2 * 3, KEY_X2, KEY_Y2},              //39 X/Y
        {TYPE_X9 + KEY_X2, TYPE_Y28 + KEY_Y2 * 3, KEY_X2, KEY_Y2},     //40 0

        {TYPE_X9 + KEY_X2, TYPE_Y28, KEY_X2, KEY_Y2},                                                    //41 1
        {TYPE_X9 + KEY_X2 * 2, TYPE_Y28, KEY_X2, KEY_Y2},                                                //42 2
        {TYPE_X9 + KEY_X2 * 3, TYPE_Y28, KEY_X2, KEY_Y2},                                                //43 3
        {TYPE_X9 + KEY_X2, TYPE_Y28 + KEY_Y2, KEY_X2, KEY_Y2},                                           //44 4
        {TYPE_X9 + KEY_X2 * 2, TYPE_Y28 + KEY_Y2, KEY_X2, KEY_Y2},                                       //45 5
        {TYPE_X9 + KEY_X2 * 3, TYPE_Y28 + KEY_Y2, KEY_X2, KEY_Y2},                                       //46 6
        {TYPE_X9 + KEY_X2, TYPE_Y28 + KEY_Y2 * 2, KEY_X2, KEY_Y2},                                       //47 7
        {TYPE_X9 + KEY_X2 * 2, TYPE_Y28 + KEY_Y2 * 2, KEY_X2, KEY_Y2},                                   //48 8
        {TYPE_X9 + KEY_X2 * 3, TYPE_Y28 + KEY_Y2 * 2, KEY_X2, KEY_Y2},                                   //49 9
        {TYPE_X1 + TYPE_SIZE4 + SAFE_DIST3, TYPE_Y1, TYPE_SIZE14, TYPE_SIZE4},                           //50 选中X
        {TYPE_X1 + TYPE_SIZE4 + SAFE_DIST3, TYPE_Y1 + SAFE_DIST3 + TYPE_SIZE4, TYPE_SIZE14, TYPE_SIZE4}, //51 选中Y

        {TYPE_X1, CONVAS_PY5, KEY_X1, KEY_Y1}, //52 吸附

        {TYPE_X1, TYPE_Y5, KEY_X1, KEY_Y1}, //53 段插入

    };
    const U16 keyBmpList[4][18] = {
        {388, 389, 390,
         391, 392, 393,
         394, 395, 396,
         403, 404, 405,
         400, 401, 402,
         397, 398, 399},
        {419, 420, 421,
         422, 423, 424,
         425, 426, 427,
         428, 429, 430,
         431, 432, 433,
         434, 435, 436},
        {442, 443, 444,
         445, 446, 447},
        {457, 458, 459,
         460, 461, 462,
         463, 464, 465},
    };
    const tydDisSrcIndex keybmpind[] = {
        //title_counter
        {{KEY_Silver}, {0}, {0}, {0, 44, 0, 0}, {0}},

        {{KEY_Silver}, {0}, {0}, {1, 0, 0, 0}, {0}},                //1 屏保
        {{KEY_Silver, KEY_Gray}, {0}, {1, 2}, {2, 0, 0, 0}, {0}},   //2 菜单
        {{KEY_Silver, KEY_Gray}, {0}, {71, 87}, {6, 0, 0, 0}, {0}}, //3 确认

        {{KEY_Silver, KEY_Blue, KEY_Gray}, {0}, {0}, {8, 0, 0, 0}, {0}},                   //4 直线-指向InputBmpList
        {{KEY_Silver, KEY_Blue, KEY_Gray}, {0}, {1}, {11, 0, 0, 0}, {0}},                  //5 多重缝-指向InputBmpList
        {{KEY_Silver, KEY_Blue, KEY_Gray}, {0}, {2}, {14, 0, 0, 0}, {0}},                  //6 Z字缝-指向InputBmpList
        {{KEY_Silver, KEY_Blue, KEY_Gray}, {0}, {3}, {17, 0, 0, 0}, {0}},                  //7 前后倒缝-指向InputBmpList上
        {{KEY_Blue, KEY_Gray, KEY_Silver}, {0}, {379, 380, 381, 383}, {7, 40, 0, 0}, {0}}, //8 空松
        {{KEY_Silver, KEY_Blue, KEY_Gray}, {0}, {369, 370, 371}, {18, 0, 0, 0}, {0}},      //9 变更速度
        {{KEY_Silver, KEY_Blue, KEY_Gray}, {0}, {372, 373, 374}, {15, 0, 0, 0}, {0}},      //10 代码
        {{KEY_Silver, KEY_Blue, KEY_Gray}, {0}, {366, 367, 368}, {13, 0, 0, 0}, {0}},      //11 取消一段

        {{KEY_Silver, KEY_Gray}, {0}, {3, 4}, {10, 0, 0, 0}, {0}},                   //12 回原点
        {{KEY_Silver, KEY_Gray}, {0}, {17, 18, 19, 20}, {41, 9, 0, 0}, {0}},         //13 抬压脚上升下降
        {{KEY_Silver, KEY_Gray}, {0}, {21, 22, 23, 24}, {42, 12, 0, 0}, {0}},        //14 针上升下降
        {{KEY_Silver, KEY_Blue, KEY_Gray}, {0}, {351, 352, 353}, {5, 0, 0, 0}, {0}}, //15 压脚高度设置
        {{KEY_Silver, KEY_Gray}, {0}, {361, 362}, {13, 0, 0, 0}, {0}},               //16 取消选中点
        {{KEY_Silver}, {0}, {75}, {60, 0, 0, 0}, {0}},                               //17 放大
        {{KEY_Silver}, {0}, {74}, {61, 0, 0, 0}, {0}},                               //18 缩小
        {{KEY_Silver}, {0}, {Color_Black}, {4, 0, 0, 0}, {0}},                       //19 拖动
        {{KEY_Silver, KEY_Gray}, {0}, {191, 192}, {19, 0, 0, 0}, {0}},               //20 寸动加
        {{KEY_Silver, KEY_Gray}, {0}, {193, 194}, {20, 0, 0, 0}, {0}},               //21 寸动减
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},                                 //22 预留1
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},                                 //23 预留2
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},                                 //24 预留3

        {{KEY_Silver, KEY_Gray}, {0}, {55}, {25, 0, 0, 0}, {0}},                             //25 左上
        {{KEY_Silver, KEY_Gray}, {0}, {56}, {26, 0, 0, 0}, {0}},                             //26 上
        {{KEY_Silver, KEY_Gray}, {0}, {57}, {27, 0, 0, 0}, {0}},                             //27 右上
        {{KEY_Silver, KEY_Gray}, {0}, {58}, {28, 0, 0, 0}, {0}},                             //28 左
        {{KEY_Silver, KEY_Gray}, {Color_Black, Color_Silver}, {51, 52}, {29, 0, 0, 0}, {0}}, //29 压框速度
        {{KEY_Silver, KEY_Gray}, {0}, {59}, {30, 0, 0, 0}, {0}},                             //30 右
        {{KEY_Silver, KEY_Gray}, {0}, {60}, {31, 0, 0, 0}, {0}},                             //31 左下
        {{KEY_Silver, KEY_Gray}, {0}, {61}, {32, 0, 0, 0}, {0}},                             //32 下
        {{KEY_Silver, KEY_Gray}, {0}, {62}, {33, 0, 0, 0}, {0}},                             //33 右下

        {{KEY_Silver, KEY_Gray}, {0}, {199, 200}, {34, 0, 0, 0}, {0}},                       //34 +1
        {{KEY_Silver, KEY_Gray}, {0}, {201, 202}, {35, 0, 0, 0}, {0}},                       //35 -1
        {{KEY_Silver, KEY_Gray}, {Color_Black, Color_Silver}, {53, 54}, {36, 0, 0, 0}, {0}}, //36 压框速度
        {{KEY_Silver, KEY_Gray}, {0}, {113, 114}, {37, 0, 0, 0}, {0}},                       //37 清除1位
        {{KEY_Silver, KEY_Gray}, {0}, {115, 116}, {38, 0, 0, 0}, {0}},                       //38 +/-
        {{KEY_Silver, KEY_Gray}, {0}, {117, 118}, {43, 39, 0, 0}, {0}},                      //39 X/Y
        {{KEY_Silver, KEY_Gray}, {0}, {91, 101}, {0, 0, 0, 0}, {0}},                         //40 0

        {{KEY_Silver, KEY_Gray}, {0}, {92, 102}, {0, 0, 0, 0}, {0}},                                         //41 1
        {{KEY_Silver, KEY_Gray}, {0}, {93, 103}, {0, 0, 0, 0}, {0}},                                         //42 2
        {{KEY_Silver, KEY_Gray}, {0}, {94, 104}, {0, 0, 0, 0}, {0}},                                         //43 3
        {{KEY_Silver, KEY_Gray}, {0}, {95, 105}, {0, 0, 0, 0}, {0}},                                         //44 4
        {{KEY_Silver, KEY_Gray}, {0}, {96, 106}, {0, 0, 0, 0}, {0}},                                         //45 5
        {{KEY_Silver, KEY_Gray}, {0}, {97, 107}, {0, 0, 0, 0}, {0}},                                         //46 6
        {{KEY_Silver, KEY_Gray}, {0}, {98, 108}, {0, 0, 0, 0}, {0}},                                         //47 7
        {{KEY_Silver, KEY_Gray}, {0}, {99, 109}, {0, 0, 0, 0}, {0}},                                         //48 8
        {{KEY_Silver, KEY_Gray}, {0}, {100, 110}, {0, 0, 0, 0}, {0}},                                        //49 9
        {{KEY_Silver}, {Color_Black}, {Color_White, Color_DeepSkyBlue, Color_Black, 0}, {43, 0, 0, 0}, {0}}, //50 选中X
        {{KEY_Silver}, {Color_Black}, {Color_White, Color_DeepSkyBlue, Color_Black, 0}, {39, 0, 0, 0}, {0}}, //51 选中Y

        {{KEY_Silver}, {Color_Black, Color_Silver}, {364}, {62, 0, 0, 0}, {0}}, //52 吸附

        {{KEY_Silver, KEY_Blue}, {0}, {545, 546}, {59, 0, 0, 0}, {0}}, //53 段插入

    };

    const RECTPAD rect[] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {0, 44}},

        {TYPE_X1, TYPE_Y1, TYPE_SIZE4, TYPE_SIZE4, {Color_KeyBlue}, {Color_White}, {63}},                                                          //1 X坐标-标题
        {TYPE_X1 + TYPE_SIZE4 + SAFE_DIST3, TYPE_Y1, TYPE_SIZE14, TYPE_SIZE4, {Color_White, Color_DeepSkyBlue}, {Color_Black, Color_Black}, {0}},  //2 X坐标-内容
        {TYPE_X1, TYPE_Y29, TYPE_SIZE4, TYPE_SIZE4, {Color_KeyBlue}, {Color_White}, {64}},                                                         //3 Y坐标-标题
        {TYPE_X1 + TYPE_SIZE4 + SAFE_DIST3, TYPE_Y29, TYPE_SIZE14, TYPE_SIZE4, {Color_White, Color_DeepSkyBlue}, {Color_Black, Color_Black}, {0}}, //4 Y坐标-内容

        {TYPE_X28, TYPE_Y1, TYPE_SIZE9, TYPE_SIZE4, {Color_KeyBlue}, {Color_White}, {65}},                         //5 X_ABS-X挪动值-标题
        {TYPE_X28 + TYPE_SIZE9 + SAFE_DIST3, TYPE_Y1, TYPE_SIZE9, TYPE_SIZE4, {Color_White}, {Color_Black}, {0}},  //6 X挪动值-内容
        {TYPE_X28, TYPE_Y29, TYPE_SIZE9, TYPE_SIZE4, {Color_KeyBlue}, {Color_White}, {66}},                        //7 Y_ABS-Y挪动值-标题
        {TYPE_X28 + TYPE_SIZE9 + SAFE_DIST3, TYPE_Y29, TYPE_SIZE9, TYPE_SIZE4, {Color_White}, {Color_Black}, {0}}, //8 Y挪动值-内容

        {TYPE_X29, TYPE_Y1, TYPE_SIZE21, TYPE_SIZE4, {Color_KeyBlue}, {Color_White}, {51}},                         //9 针距-标题
        {TYPE_X29 + TYPE_SIZE21 + SAFE_DIST3, TYPE_Y1, TYPE_SIZE9, TYPE_SIZE4, {Color_White}, {Color_Black}, {0}},  //10 针距-内容
        {TYPE_X29, TYPE_Y29, TYPE_SIZE21, TYPE_SIZE4, {Color_KeyBlue}, {Color_White}, {52}},                        //11 速度-标题
        {TYPE_X29 + TYPE_SIZE21 + SAFE_DIST3, TYPE_Y29, TYPE_SIZE9, TYPE_SIZE4, {Color_White}, {Color_Black}, {0}}, //12 速度-内容

        {TYPE_X30, TYPE_Y1, TYPE_SIZE21, TYPE_SIZE4, {Color_KeyBlue}, {Color_White}, {53}},                          //13 代码-标题
        {TYPE_X30 + TYPE_SIZE21 + SAFE_DIST3, TYPE_Y1, TYPE_SIZE14, TYPE_SIZE4, {Color_White}, {Color_Black}, {0}},  //14 代码-内容
        {TYPE_X30, TYPE_Y29, TYPE_SIZE21, TYPE_SIZE4, {Color_KeyBlue}, {Color_White}, {54}},                         //15 针数-标题
        {TYPE_X30 + TYPE_SIZE21 + SAFE_DIST3, TYPE_Y29, TYPE_SIZE14, TYPE_SIZE4, {Color_White}, {Color_Black}, {0}}, //16 针数-内容

        {TYPE_X31, TYPE_Y1, TYPE_SIZE9, TYPE_SIZE4, {Color_KeyBlue}, {Color_White}, {67}},                         //17 P-标题
        {TYPE_X31 + TYPE_SIZE9 + SAFE_DIST3, TYPE_Y1, TYPE_SIZE6, TYPE_SIZE4, {Color_White}, {Color_Black}, {0}},  //18 P-内容
        {TYPE_X31, TYPE_Y29, TYPE_SIZE9, TYPE_SIZE4, {Color_KeyBlue}, {Color_White}, {55}},                        //19 松线-标题
        {TYPE_X31 + TYPE_SIZE9 + SAFE_DIST3, TYPE_Y29, TYPE_SIZE6, TYPE_SIZE4, {Color_White}, {Color_Black}, {0}}, //20 松线-内容

        {TYPE_X32, TYPE_Y1, TYPE_SIZE9, TYPE_SIZE4, {Color_KeyBlue}, {Color_White}, {68}},                         //21 压脚高度-标题
        {TYPE_X32 + TYPE_SIZE9 + SAFE_DIST3, TYPE_Y1, TYPE_SIZE9, TYPE_SIZE4, {Color_White}, {Color_Black}, {0}},  //22 压脚高度-内容
        {TYPE_X32, TYPE_Y29, TYPE_SIZE9, TYPE_SIZE4, {Color_KeyBlue}, {Color_White}, {69}},                        //23 压脚高度绝对值-标题
        {TYPE_X32 + TYPE_SIZE9 + SAFE_DIST3, TYPE_Y29, TYPE_SIZE9, TYPE_SIZE4, {Color_White}, {Color_Black}, {0}}, //24 压脚高度绝对值-内容

        {CONVAS_PX5, CONVAS_ORG_PY5, CONVAS_X5, 1, {Color_White}, {Color_White}, {0}}, //25 窗口提示线X
        {CONVAS_ORG_PX5, CONVAS_PY5, 1, CONVAS_Y5, {Color_White}, {Color_White}, {0}}, //26 窗口提示线Y

    };

    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_CURSOR); //设置当前文字显示雷人在P1页面，对应41.bin
    InitScreen();
    initViewStatus();
    updateViewStatus();
    pat_resetPatRule();
    pat_setPatRule(patRulesTmp);

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    g_readcovnflag = 0;
    g_readcovnflag1 = 1;
    g_nolimt = 0;

    if (g_ct_insert_flag)
    {
        stflag = 2;
    }
    if (g_ct_insert_flag == 3)
    {
        g_ct_insert_flag = 2;
        dis_updataP = 2;
        dis_updata2 = 1;
        g_dxpos = 0;
        g_dypos = 0;
        dismove = 1;
    }

    if (g_ct_insert_flag == 2 && (g_dxpos != 0 || g_dypos != 0))
    {
        ct_insert_flag = 0;
        dis_updata4 = 0;
    }

    if (g_ModToCt && plastno == MENU_MODIFYADD)
    {
        g_ct_insert_flag = 2;
        ct_insert_flag = g_ct_insert_flag;
        stflag = 2;
        dis_updata4 = 1;
        dis_updata2 = 0;
        g_ct_insert_flag = 2;
        g_ct_status_flag = 0;
        dismove = 0;
        if (!g_feed_flag)
        {
            g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
        }
        g_ct_status_flag |= (bit5 | bit12 | bit13 | bit8);
        g_dxpos = 0;
        g_dypos = 0;
        g_temp_pno = 0xffffffff;
        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
        dis_updata = 1;
        dis_updata1 = 1;
        dis_pattern = 0;

        if (g_GreatPatType == 1)
        {
            mitPinmsg = mit_getPinsMsg((U16 *)SREG, 52000, g_feedc);
#if PATRULES_ORG_OFFSET
// if (SREG[3] == 7) //新增-修改原点位置
// {
//     mitPinmsg.posx += (S16)(SREG[6]);
//     mitPinmsg.posy += (S16)(SREG[7]);
// }
#endif
            g_oxpos = mitPinmsg.posx;
            g_oypos = mitPinmsg.posy;
            g_inoxpos = g_oxpos;
            g_inoypos = g_oypos;
            g_dxpos = 0;
            g_dypos = 0;
        }
        else if (g_GreatPatType == 2)
        {
            if (g_feedc < g_feedsum)
            {
                Bor_feedInfo(g_feedc + 1, g_CtPatLen, &Borcmd, (S16 *)&g_oxpos, (S16 *)&g_oypos, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &Borpooft, &Borpfdis);
                if (g_oldspeed == 0)
                    g_oldspeed = 0x60;
                else if (g_oldspeed == 1)
                    g_oldspeed = 0x40;
                else if (g_oldspeed == 2)
                    g_oldspeed = 0x20;
                else
                    g_oldspeed = 0x0;

                g_inoxpos = g_oxpos;
                g_inoypos = g_oypos;
                g_dxpos = 0;
                g_dypos = 0;
            }
        }
    }

    if (g_Ptya == 1)
    { // 初始化速度级数
        SpeedClass = 1;
    }
    else if ((g_Ptya > 1) && (g_Ptya < 5))
    {
        SpeedClass = 2;
    }
    else if ((g_Ptya > 4) && (g_Ptya < 9))
    {
        SpeedClass = 3;
    }
    else if ((g_Ptya > 8) && (g_Ptya < 16))
    {
        SpeedClass = 4;
    }
    //g_endtype = 0;
    if (g_DrawOcclude == 2)
    { //输入不是封闭图形,取消前一步操作
        g_DrawOcclude = 0;
        keyoff = KEY_CURSOR_CANCEL;
    }
    //读设定中压脚修正量
    f = Read_D(D_Address[SYS] + SYS_PFOOTSET, 1, (U16 *)(&YREG[SYS_PFOOTSET]));
    if (f == 0)
    {
        pno = MENU_RWHELP;
        hleppara = 15;
        pnoindex = 3;
        poldno[2] = MENU_CURSOR;
        return;
    }
    PfootOffVal = YREG[SYS_PFOOTSET];
    //读设定中压脚修正量
    f = Read_D(D_Address[SYS] + SYS_PFOOTNOW, 1, (U16 *)(&YREG[SYS_PFOOTNOW]));
    if (f == 0)
    {
        pno = MENU_RWHELP;
        hleppara = 15;
        pnoindex = 3;
        poldno[2] = MENU_CURSOR;
        return;
    }
    temp_PfVal = YREG[SYS_PFOOTNOW];
    old_PfootOffVal = temp_PfVal;
    //读面线张力基准值
    f = Read_D(D_Address[SYS] + SYS_LFORCESET, 1, (U16 *)(&YREG[SYS_LFORCESET]));
    if (f == 0)
    {
        pno = MENU_RWHELP;
        hleppara = 15;
        pnoindex = 3;
        poldno[2] = MENU_CURSOR;
        return;
    }
    g_lineforceValSet = YREG[SYS_LFORCESET];

    if ((g_speed != 0x20) && (g_speed != 0x40) && (g_speed != 0x60))
        g_speed = 0x00;
    if (g_pitch > 127 || g_pitch == 0)
        g_pitch = 30;
    if ((g_input_method == 0) || (g_input_method > 6))
        g_input_method = 2; //输入模式
    if (g_para_offset > 5)
        g_para_offset = 0; //多重缝
    if (g_direction > 1)
        g_direction = 0;
    if (g_distance > 250)
        g_distance = 0;
    if ((g_times < 2) || (g_times > 9))
        g_times = 2;
    if (g_zig_zag > 1)
        g_zig_zag = 0; //Z字缝
    if ((g_zig_width == 0) || (g_zig_width > 100))
        g_zig_width = 10;
    if ((g_zig_pitch < 5) || (g_zig_pitch > 100))
        g_zig_pitch = 30;
    if (g_zig_direction > 2)
        g_zig_direction = 1;
    if (g_bt_mode > 2)
        g_bt_mode = 0; //倒缝
    if (g_repeat > 3)
        g_repeat = 0;
    if (g_r_stitch > 9)
        g_r_stitch = 0;
    if (g_srt_bt > 3)
        g_srt_bt = 0;
    if (g_s_stitch > 9)
        g_s_stitch = 0;
    if (g_ent_bt > 3)
        g_ent_bt = 0;
    if (g_e_stitch > 9)
        g_e_stitch = 0;

    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4,
                 MEM_TITLE_ADD + (U32)((g_num_mov_key) ? rect[0].index[1] : rect[0].index[0]) * TitleLengthMax,
                 SheetPage, (g_num_mov_key) ? rect[0].index[1] : rect[0].index[0], rect[0].colorT[0]); //打板界面

    //画出方框显示
    for (i = 1; i <= RECT_CURSOR_XPF_TIT; i++)
    {

        DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
        if (i % 2 > 0)
        {
            Draw16x16Str(rect[i].xpis + SAFE_DIST4, rect[i].ypis + (rect[i].ysize - 16) / 2,
                         (MEM_TITLE_ADD + (U32)(rect[i].index[0] * TitleLengthMax)),
                         SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
        }
    }
    DrawFS32P(rect[RECT_CURSOR_P_STR].xpis + SAFE_DIST3, rect[RECT_CURSOR_P_STR].ypis + SAFE_DIST4,
              g_point_num, 3, 0, rect[RECT_CURSOR_P_STR].colorT[0]);
    //画出按键显示
    for (i = 2; i < KEY_CURSOR_NULL1; i++)
    {
        //无效按键
        //绘制颜色文字按键
        //绘制常规按键
        if (i >= KEY_CURSOR_METHOD && i <= KEY_CURSOR_TACKING)
        {
            // DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keyBmpList[keybmpind[i].icon[0]][0]);
        }
        else if (i == KEY_CURSOR_IMG)
        {
            DrawFillRect(keyd[i].xpis, keyd[i].ypis, keyd[i].xsize, keyd[i].ysize, keybmpind[i].icon[0]);
            DrawHLine(CONVAS_PX5, CONVAS_ORG_PY5, CONVAS_X5, CONVAS_COLOR_T);
            DrawVLine(CONVAS_ORG_PX5, CONVAS_PY5, CONVAS_Y5, CONVAS_COLOR_T);
        }
        else
        {
            DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
        }
    }

    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************
    AnaPattern(0, g_GreatPatType, g_CtPatLen);
    dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
    if (g_signflag > 1)
        g_signflag = 0;
    if ((g_Ptya == 0) || (g_Ptya > 15))
        g_Ptya = 1;

    if (g_cttohome)
    {
        if (0 != g_feedsum)
        {
            g_feedc = g_jog_point;

            g_ct_status_flag = 0x7cfdf;
            g_ct_status_flag |= bit19;
            dismove = 1;
            dis_updata = 1;
            dis_updata1 = 1;
            dis_updata2 = 1;
            dis_updata3 = 0;
            if (g_needtohome == 0)
            {
                g_feedc = 0;
                if (g_GreatPatType == 1)
                { //三菱
                    dat1 = g_pat_p - g_feedsum - g_feedsum;
                    dat = SREG[dat1] & 0x00ff;
#if PATRULES_ORG_OFFSET
                    if (SREG[3] == 7) //新增-修改原点位置
                    {
                        g_temp_oxpos = (S16)(SREG[6]);
                        g_temp_oxpos = (S16)(SREG[7]);
                    }
#endif
                    if ((dat == 0x61) || (dat == 0x41) || (dat == 0x21) || (dat == 0x1) || (dat == 0x1b) || (dat == 0x3))
                    {
                        dat = SREG[dat1 + 1];
                        x = dat & 0x000000ff;
                        y = ((U32)(dat >> 8)) & 0x000000ff;
                        if (x >= 0x80)
                        {
                            x -= 0x80;
                            g_dxpos = -x;
                            g_temp_oxpos += 0;
                        }
                        else
                        {
                            g_dxpos = x;
                            g_temp_oxpos += 0;
                        }
                        if (y >= 0x80)
                        {
                            y -= 0x80;
                            g_dypos = -y;
                            g_temp_oypos += 0;
                        }
                        else
                        {
                            g_dypos = y;
                            g_temp_oypos += 0;
                        }
                        dat = SREG[dat1];
                    }
                    else
                    {
                        g_dxpos = 0;
                        g_dypos = 0;
                        dat = SREG[dat1];
                    }
                    dis_data(dat, 0);
                }
                else if (g_GreatPatType == 2)
                {               //兄弟
                    stflag = 0; //在机械原点
                    g_ct_status_flag = 0x7cfdf;
                    g_ct_status_flag |= bit19;

                    g_dxpos = g_patd.orgX;
                    g_dypos = g_patd.orgY;
                    g_pf_absdis = 0;
                    g_speed = 0x60;
                    dis_data(0, 1);
                    dismove = 1;

                    dis_updata = 1;
                }
                g_ExCode = 0;
                g_curExCode = 0;
            }
        }
        else
        {
            g_cttohome = 0;
        }
    }

    if (g_GreatPatType == 1)
    { //三菱
        mult1 = 1;
        mult2 = -1;
        tmuly = 1;
    }
    else if (g_GreatPatType == 2)
    { //兄弟
        mult1 = 2;
#if MOVEUNIT == 1
        mult1 = 1;
#endif
        //mult1 = 1;
        mult2 = 1;
        tmuly = -1;
    }

    scale = pat_getScale(patRule.h_patConvasIndex, patRulesTmp);
    vscale = pat_getFinalScale(scale, scale1);
    xo = ORG_X;
    yo = ORG_Y;

    vposx = g_oxpos;
    vposy = g_oypos;
#if PATRULES_ORG_OFFSET
    if (SREG[3] == 7) //新增-修改原点位置
    {
        vposy += (S16)(SREG[6]);
        vposy += (S16)(SREG[7]);
    }
#endif
    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    ViewPage(usepageno); //设置显示缓存
    Timer_ms = 30720;    //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        keydata = get_keydata((KEYPAD *)keyd, KEY_CURSOR_MAX1, 0); //获取键值
        if (((keydata == KEY_CURSOR_MUP) && (g_ct_status_flag & bit12)) ||
            ((keydata == KEY_CURSOR_MDOWN) && (g_ct_status_flag & bit13)))
        {
            keydata = 0;
        }
        if (keydata == 0 && tonear)
        {
            keydata = get_keydata((KEYPAD *)keyd, KEY_CURSOR_MAX4 + KEY_CURSOR_MAX3 + KEY_CURSOR_MAX2 + KEY_CURSOR_MAX1, KEY_CURSOR_MAX3 + KEY_CURSOR_MAX2 + KEY_CURSOR_MAX1);
        }
        if (keydata == 0 && ct_insert_flag)
        {
            keydata = get_keydata((KEYPAD *)keyd, KEY_CURSOR_MAX5 + KEY_CURSOR_MAX4 + KEY_CURSOR_MAX3 + KEY_CURSOR_MAX2 + KEY_CURSOR_MAX1, KEY_CURSOR_MAX4 + KEY_CURSOR_MAX3 + KEY_CURSOR_MAX2 + KEY_CURSOR_MAX1);
        }
        if ((keydata == 0) && (dismove == 0))
        {
            if (g_num_mov_key == 0)
            {                                                                                              //方向键
                keydata = get_keydata((KEYPAD *)keyd, KEY_CURSOR_MAX2 + KEY_CURSOR_MAX1, KEY_CURSOR_MAX1); //25
                if ((g_feedc < g_feedsum) || (g_ct_status_flag & bit18))
                {
                    keydata = 0;
                    resetKeyData();
                }
            }
            else
            {                                                                                                                                  //数字键
                keydata = get_keydata((KEYPAD *)keyd, KEY_CURSOR_MAX3 + KEY_CURSOR_MAX2 + KEY_CURSOR_MAX1, KEY_CURSOR_MAX2 + KEY_CURSOR_MAX1); //34
                if (keydata)
                    DelayMs(1);
                if ((g_feedc < g_feedsum) ||
                    ((g_ct_status_flag & bit18) && ((keydata == KEY_CURSOR_DUP) || (keydata == KEY_CURSOR_DDOWN))))
                {
                    keydata = 0;
                    resetKeyData();
                }
            }
        }

        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理
        //无效按键

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            if (((keyon >= KEY_CURSOR_MUL && keyon <= KEY_CURSOR_MDR) && keyon != KEY_CURSOR_MMSP) ||
                (keyon >= KEY_CURSOR_ZOUT && keyon <= KEY_CURSOR_IMG) ||
                (keyon >= KEY_CURSOR_MUP && keyon <= KEY_CURSOR_MDOWN) ||
                (keyon >= KEY_CURSOR_DUP && keyon <= KEY_CURSOR_DDOWN))
            {
            }
            else if ((keyon) && (beeponf))
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {
            //特定情况下不生效按键
            if ((keydata <= KEY_CURSOR_CANCEL) && (g_ct_status_flag & keylitd[keydata]))
            {
                keydata = 0;
            }
            else if (((keydata == KEY_CURSOR_MUP) && (g_ct_status_flag & bit12)) ||
                     ((keydata == KEY_CURSOR_MDOWN) && (g_ct_status_flag & bit13)))
            {
                keydata = 0;
            }
            else if ((keydata == KEY_CURSOR_PFOOTSET) && (g_feed_flag == 0))
            {
                keydata = 0;
            }
            else if ((keydata >= KEY_CURSOR_MUL && keydata <= KEY_CURSOR_DY) && (dis_pattern == 1))
            {
                keydata = 0;
            }
            else
            {
                if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时
                {
                    keyon = keydata;
                    pressKey = 1;

                    if (keyon == KEY_CURSOR_SCRNSVR || keyon == KEY_CURSOR_IMG) //无按键特效
                    {
                    }
                    else if (keyon == KEY_CURSOR_DX || keyon == KEY_CURSOR_DY)
                    {
                        DrawButtonOnZoomIn(keyd[keyon], 2);
                    }
                    //非常规按键-//绘制颜色文字按键
                    else
                    {
                        DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);
                    }
                    Times = 0;
                    ll = 1;
                    //按键防抖次数
                    if ((keyon == KEY_CURSOR_MMSP) || (keyon == KEY_CURSOR_NUMMSP))
                        delay = KEYLT;
                    else
                        delay = KEYDT;
                }
                else if (keyon != keydata) //已有按键按下，不处理新按键信息
                {
                    keydata = 0;
                }

                if (Times > delay) //按键防抖
                {
                    if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                    {
                        beeponf = 1;

                        if (g_keyBellT) //按键时蜂鸣器发声时间
                            Beep_On(g_keyBellT);

                        switch (keyon) //按键按下标题提示语显示
                        {
                        case KEY_CURSOR_FEED:
                            DrawFMenuStr((g_feed_flag) ? keybmpind[keyon].titleStr[1] : keybmpind[keyon].titleStr[0]);
                            break;
                        case KEY_CURSOR_PFOOT:
                            DrawFMenuStr((tmp_pfoot != 0x10) ? keybmpind[keyon].titleStr[1] : keybmpind[keyon].titleStr[0]);
                            break;
                        case KEY_CURSOR_NEEDLE:
                            DrawFMenuStr((tmp_needle == 0x20) ? keybmpind[keyon].titleStr[1] : keybmpind[keyon].titleStr[0]);
                            break;
                        case KEY_CURSOR_XY:
                            DrawFMenuStr((g_editflag) ? keybmpind[keyon].titleStr[1] : keybmpind[keyon].titleStr[0]);
                            break;

                        case KEY_CURSOR_0:
                        case KEY_CURSOR_1:
                        case KEY_CURSOR_2:
                        case KEY_CURSOR_3:
                        case KEY_CURSOR_4:
                        case KEY_CURSOR_5:
                        case KEY_CURSOR_6:
                        case KEY_CURSOR_7:
                        case KEY_CURSOR_8:
                        case KEY_CURSOR_9:
                            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
                            DrawMFU32(TITLE_XPOS_C2, SAFE_DIST4, keyon - KEY_CURSOR_0, 1, rect[0].colorT[0]);
                            break;
                        default:
                            DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                            break;
                        }
                        delay = KEYFT;
                    }
                    else if (beeponf == 1) //第二次进入
                    {
                        beeponf = 2;
                        //带有长按连续功能按键的功能

                        delay = KEYNT;
                    }
                    else if (beeponf < 20)
                    {
                        beeponf++;
                    }

                    if (((keyon >= KEY_CURSOR_MUL && keyon <= KEY_CURSOR_MDR) && keyon != KEY_CURSOR_MMSP) ||
                        (keyon >= KEY_CURSOR_ZOUT && keyon <= KEY_CURSOR_IMG) ||
                        (keyon >= KEY_CURSOR_MUP && keyon <= KEY_CURSOR_MDOWN) ||
                        (keyon >= KEY_CURSOR_DUP && keyon <= KEY_CURSOR_DDOWN)) //带有长按连续功能按键的功能
                    {
                        keyoff = keyon;
                        key_on_flag1 = 1;
                    }
                    Times = 0; //当前
                }
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            pressKey = 1;
            if (g_needtohome && (keyoff != KEY_CURSOR_HOME))
            {
                g_feedc = g_jog_point;
                pno = MENU_RWHELP;
                hleppara = 158;
                poldno[pnoindex] = MENU_CURSOR;
                pnoindex++;
                g_jog_point = g_feedc;
                g_BorSTflag = stflag;
            }
            else
            {
                if (((keyoff >= KEY_CURSOR_0) && (keyoff <= KEY_CURSOR_9)) || (keyoff == KEY_CURSOR_DUP) || (keyoff == KEY_CURSOR_DDOWN))
                { // 数字键
                    if ((!(S_CLAMP)) && (P_OST == 0))
                    {
                        pno = MENU_RWHELP;
                        hleppara = 13;
                        pnoindex = 3;
                        poldno[2] = MENU_CURSOR;
                    }
                    else
                    {
                        if ((g_dxpos == 0) && (g_dypos == 0) && (g_point_num == 1))
                        {
                            g_tmpoxpos = g_oxpos;
                            g_tmpoypos = g_oypos;
                        }
#if MOVEUNIT == 1
                        if (g_curPTtype == 2)
                        {
                            if (g_editflag)
                            {
                                if (g_dypos)
                                    datxy = g_dypos * 5;
                                ll = 56;
                            }
                            else
                            {
                                if (g_dxpos)
                                    datxy = g_dxpos * 5;
                                ll = 36;
                            }
                        }
                        else
                        {
                            if (g_editflag)
                            {
                                datxy = g_dypos;
                                ll = 56;
                            }
                            else
                            {
                                datxy = g_dxpos;
                                ll = 36;
                            }
                        }
#else
                        if (g_editflag)
                        {
                            datxy = g_dypos;
                            ll = rect[RECT_CURSOR_Y_STR].ypis;
                        }
                        else
                        {
                            datxy = g_dxpos;
                            ll = rect[RECT_CURSOR_X_STR].ypis;
                        }
#endif

                        if (keyoff > KEY_CURSOR_DDOWN)
                        {
                            datxy = (datxy % 1000) * 10;
                            if (datxy < 0)
                                datxy = datxy - (keyoff - KEY_CURSOR_0);
                            else
                                datxy = datxy + (keyoff - KEY_CURSOR_0);
                            if (g_signflag)
                                datxy = -datxy;
                            if (abs(datxy) > 9999)
                                datxy = datxy % 10000;
                        }
                        else
                        {
#if MOVEUNIT == 1
                            if (g_curPTtype == 2)
                            {
                                if (keyoff == KEY_CURSOR_DDOWN)
                                    datxy -= 5;
                                else
                                    datxy += 5;
                            }
                            else
                            {
                                if (keyoff == KEY_CURSOR_DDOWN)
                                    datxy--;
                                else
                                    datxy++;
                            }
#else
                            if (keyoff == KEY_CURSOR_DDOWN)
                                datxy--;
                            else
                                datxy++;
#endif

                            if (datxy > 9999)
                                datxy = 9999;
                            if (datxy < -9999)
                                datxy = -9999;
                        }
#if MOVEUNIT == 1
                        if (g_curPTtype == 2)
                        {
                            if (g_editflag)
                            {
                                g_dypos = datxy / 5;
                            }
                            else
                            {
                                g_dxpos = datxy / 5;
                            }
                            DrawFillRect(26, ll, 56, 16, Color_Black);
                            DrawFS32P(26, ll, datxy, 7, 2, Color_White);
                        }
                        else
                        {
                            if (g_editflag)
                            {
                                g_dypos = datxy;
                            }
                            else
                            {
                                g_dxpos = datxy;
                            }
                            DrawFillRect(26, ll, 48, 16, Color_Black);
                            DrawFS32P(26, ll, datxy, 6, 1, Color_White);
                        }
#else
                        if (g_editflag)
                        {
                            g_dypos = datxy;
                        }
                        else
                        {
                            g_dxpos = datxy;
                        }
                        xx = g_tmpoxpos + mult1 * g_dxpos;
                        yy = g_tmpoypos + mult1 * g_dypos;
                        if (xx < mult1 * mult3 * g_Mac.max_xl)
                            g_dxpos = (mult1 * mult3 * g_Mac.max_xl - g_tmpoxpos) / mult1;
                        if (xx > mult1 * mult3 * g_Mac.max_xr)
                            g_dxpos = (mult1 * mult3 * g_Mac.max_xr - g_tmpoxpos) / mult1;
                        if (yy > mult1 * mult3 * g_Mac.max_yu)
                            g_dypos = (mult1 * mult3 * g_Mac.max_yu - g_tmpoypos) / mult1;
                        if (yy < mult1 * mult3 * g_Mac.max_yd)
                            g_dypos = (mult1 * mult3 * g_Mac.max_yd - g_tmpoypos) / mult1;
                        if (g_editflag)
                        {
                            datxy = g_dypos;
                        }
                        else
                        {
                            datxy = g_dxpos;
                        }
                        // DrawFillRect(26,ll,48,16,Color_Black);
                        // DrawFS32P(26,ll, datxy,6,1,Color_White);
                        DrawFillRect(rect[RECT_CURSOR_Y_STR].xpis + 1, ll + 1,
                                     rect[RECT_CURSOR_Y_STR].xsize - 2, rect[RECT_CURSOR_Y_STR].ysize - 2,
                                     ReadPixel(rect[RECT_CURSOR_Y_STR].xpis + 1, ll + 1));
                        DrawFS32P(rect[RECT_CURSOR_Y_STR].xpis + SAFE_DIST3, ll + SAFE_DIST4,
                                  datxy, 6, 1, rect[RECT_CURSOR_Y_STR].colorT[0]);
#endif
                        if (keyoff == KEY_CURSOR_0)
                        {
                            if (g_signflag)
                            {
                                // // Draw24X24FStr(26, ll, "-", Color_White);
                                // Draw24X24FStr(rect[RECT_CURSOR_Y_TIT].xpis + SAFE_DIST3 + TYPE_SIZE4 + SAFE_DIST3, ll + SAFE_DIST4,
                                //         "-", Color_Black);
                            }
                        }
                        else
                            g_signflag = 0;

                        if ((g_dxpos != 0) || (g_dypos != 0))
                        {
                            if ((g_ct_status_flag != 0x8f5f6) && (g_ct_status_flag != 0x8f7f6))
                            {
                                g_ct_status_flag = 0xf5f6;
                                if (!g_feed_flag)
                                    g_ct_status_flag |= bit9;
                                //status_flag |= bit19;
                                dis_updata = 1;
                            }
                        }
                        else if (g_ct_status_flag && g_point_num < 2)
                        {
                            g_ct_status_flag = 0;
                            if (!g_feed_flag)
                            {
                                g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
                            }
                            dis_updata = 1;
                        }
                        if ((g_num_mov_key) && ((g_dxpos != 0) || (g_dypos != 0))) //修改-新增
                        {
                            xx = g_tmpoxpos + mult1 * g_dxpos;
                            yy = g_tmpoypos + mult1 * g_dypos;
                            if ((xx < mult1 * g_Mac.max_xl) || (xx > mult1 * g_Mac.max_xr) || (yy > mult1 * g_Mac.max_yu) || (yy < mult1 * g_Mac.max_yd))
                            {
                                pno = MENU_RWHELP;
                                hleppara = 23;
                                poldno[2] = MENU_CURSOR;
                                pnoindex = 3;
                                break;
                            }
                            f = Comm_Move(g_tmpoxpos + mult1 * g_dxpos, g_tmpoypos + mult1 * g_dypos, 80, MENU_CURSOR, 0, 0);
                            if (f == 0)
                            {
                                break;
                            }
                            vflag = 0;
                            vposx = g_tmpoxpos + mult1 * g_dxpos;
                            vposy = g_tmpoypos + mult1 * g_dypos;
                            if (g_tmpoxpos + mult1 * g_dxpos > g_maxX || g_tmpoxpos + mult1 * g_dxpos < g_minX || mult2 * (g_tmpoypos + mult1 * g_dypos) > g_maxY || mult2 * (g_tmpoypos + mult1 * g_dypos) < g_minY)
                            {
                                if (g_tmpoxpos + mult1 * g_dxpos > g_maxX)
                                {
                                    g_maxX = g_tmpoxpos + mult1 * g_dxpos;
                                }
                                if (g_tmpoxpos + mult1 * g_dxpos < g_minX)
                                {
                                    g_minX = g_tmpoxpos + mult1 * g_dxpos;
                                }
                                if (mult2 * (g_tmpoypos + mult1 * g_dypos) > g_maxY)
                                {
                                    g_maxY = mult2 * (g_tmpoypos + mult1 * g_dypos);
                                }
                                if (mult2 * (g_tmpoypos + mult1 * g_dypos) < g_minY)
                                {
                                    g_minY = mult2 * (g_tmpoypos + mult1 * g_dypos);
                                }
                                dis_updataP = 1;
                                scale = pat_getScale(patRule.h_patConvasIndex, patRulesTmp);
                                vscale = pat_getFinalScale(scale, scale1);
                            }
                            else
                            {
                                posx1 = (S32)((g_tmpoxpos + mult1 * g_dxpos) * (vscale) / 1000 + xorg);
                                posy1 = (S32)(mult2 * tmuly * (g_tmpoypos + mult1 * g_dypos) * (vscale) / 1000 + yorg);
                                if (((posx1 < patV.xpis) || (posx1 > patV.xpis + patV.xsize) || (posy1 < patV.ypis) || (posy1 > patV.ypis + patV.ysize)))
                                {
                                    dis_updataP = 1;
                                }
                                else
                                {
                                    RecoveData2();
                                    ReadPointData2(posx1 - 4, posy1 - 4);
                                    Draw_SmallCrossLimit(posx1, posy1, COLOR_CROSS, patRule.h_patConvasIndex);
                                }
                            }
                        }
                        if (g_GreatPatType == 2)
                        {
                            g_disxpos = g_tmpoxpos + mult1 * g_dxpos;
                            g_disypos = g_tmpoypos + mult1 * g_dypos;
                        }
                    }
                }
                else if ((keyoff >= KEY_CURSOR_MUL) && (keyoff <= KEY_CURSOR_MDR) && (keyoff != KEY_CURSOR_MMSP))
                { // 方向键
                    if ((!(S_CLAMP)) && (P_OST == 0))
                    {
                        pno = MENU_RWHELP;
                        hleppara = 13;
                        pnoindex = 3;
                        poldno[2] = MENU_CURSOR;
                    }
                    else
                    {
                        if ((g_dxpos == 0) && (g_dypos == 0))
                        {
                            g_ct_status_flag = 0xf5f6;
                            if (!g_feed_flag)
                                g_ct_status_flag |= bit9;
                            dis_updata = 1;
                            if (g_point_num == 1)
                            {
                                g_tmpoxpos = g_oxpos;
                                g_tmpoypos = g_oypos;
                            }
                            if ((g_Ptya == 0) || (g_Ptya > 15))
                                g_Ptya = 1;
                        }
                        getNearflag = 1;
                        dis_updata4 = 0;
                        tmpxpos = g_dxpos;
                        tmpypos = g_dypos;
                        if ((keyoff == KEY_CURSOR_MUR) || (keyoff == KEY_CURSOR_MMR) || (keyoff == KEY_CURSOR_MDR))
                        {
                            g_dxpos += ll;
                        }
                        else if ((keyoff == KEY_CURSOR_MUL) || (keyoff == KEY_CURSOR_MML) || (keyoff == KEY_CURSOR_MDL))
                        {
                            g_dxpos -= ll;
                        }
                        if ((keyoff == KEY_CURSOR_MUL) || (keyoff == KEY_CURSOR_MUM) || (keyoff == KEY_CURSOR_MUR))
                        {
                            g_dypos += ll;
                        }
                        else if ((keyoff == KEY_CURSOR_MDL) || (keyoff == KEY_CURSOR_MDM) || (keyoff == KEY_CURSOR_MDR))
                        {
                            g_dypos -= ll;
                        }

                        if (ct_insert_flag)
                        {
                            BmpFillRect(keyd[KEY_CURSOR_TOP].xpis, keyd[KEY_CURSOR_TOP].ypis,
                                        keyd[KEY_CURSOR_TOP].xsize, keyd[KEY_CURSOR_TOP].ysize);
                            ct_insert_flag = 0;
                        }

                        if ((g_dxpos == 0) && (g_dypos == 0) && (g_point_num == 1))
                        {
                            g_ct_status_flag = 0;
                            if (!g_feed_flag)
                            {
                                g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
                            }
                            dis_updata = 1;

                            if (g_ct_insert_flag)
                            {
                                dis_updata4 = 1;
                                getNearflag = 2;
                                tonear = 0;
                                //ct_insert_flag =1;
                                g_ct_status_flag |= (bit8);
                                //DrawButton(keyd6[0],(U16 *)(STARTWLBMPADD),KEY_Silver,keybmpind6[0]);
                            }
                        }
                        xx = g_tmpoxpos + mult1 * g_dxpos;
                        yy = g_tmpoypos + mult1 * g_dypos;
                        //printf("xx = %d yy = %d  \r\n",xx,yy);
                        if (xx < mult1 * mult3 * g_Mac.max_xl)
                            g_dxpos = (mult1 * mult3 * g_Mac.max_xl - g_tmpoxpos) / mult1;
                        if (xx > mult1 * mult3 * g_Mac.max_xr)
                            g_dxpos = (mult1 * mult3 * g_Mac.max_xr - g_tmpoxpos) / mult1;
                        if (yy > mult1 * mult3 * g_Mac.max_yu)
                            g_dypos = (mult1 * mult3 * g_Mac.max_yu - g_tmpoypos) / mult1;
                        if (yy < mult1 * mult3 * g_Mac.max_yd)
                            g_dypos = (mult1 * mult3 * g_Mac.max_yd - g_tmpoypos) / mult1;

#if MOVEUNIT == 1
                        if (g_curPTtype == 2)
                        {
                            f = Comm_Move(g_tmpoxpos + mult1 * g_dxpos, g_tmpoypos + mult1 * g_dypos, ll / 2, MENU_CURSOR, (g_GreatPatType == 1) ? 0 : 1, 0);
                        }
                        else
                        {
                            f = Comm_Move(g_tmpoxpos + mult1 * g_dxpos, g_tmpoypos + mult1 * g_dypos, ll, MENU_CURSOR, (g_GreatPatType == 1) ? 0 : 1, 0);
                        }
#else
                        f = Comm_Move(g_tmpoxpos + mult1 * g_dxpos, g_tmpoypos + mult1 * g_dypos, ll, MENU_CURSOR, (g_GreatPatType == 1) ? 0 : 1, 0);
#endif

                        g_disxpos = g_tmpoxpos + mult1 * g_dxpos;
                        g_disypos = g_tmpoypos + mult1 * g_dypos;

                        if (f == 0)
                        {
                            g_dxpos = tmpxpos;
                            g_dypos = tmpypos;
                        }

                        if (ll < g_Ptya * 8)
                            ll += g_Ptya;
                        else
                            ll += g_Ptya * 2;
                        dat = 20 + g_Ptya * 5;
                        if (ll > dat)
                            ll = dat;

                        for (i = 0; i < RDTIMES; i++)
                        {
                            Read_D(D_Address[DISP] + D_CMDSTATUS, 1, (U16 *)(&DREG[D_CMDSTATUS])); // 读状态
                            if ((DREG[D_CMDSTATUS]) == 100)
                                break;
                            DelayMs(6);
                        }
                        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                        vflag = 0;
                        vposx = g_tmpoxpos + mult1 * g_dxpos;
                        vposy = g_tmpoypos + mult1 * g_dypos;
                        if (g_tmpoxpos + mult1 * g_dxpos > g_maxX || g_tmpoxpos + mult1 * g_dxpos < g_minX || mult2 * (g_tmpoypos + mult1 * g_dypos) > g_maxY || mult2 * (g_tmpoypos + mult1 * g_dypos) < g_minY)
                        {
                            if (g_tmpoxpos + mult1 * g_dxpos > g_maxX)
                            {
                                g_maxX = g_tmpoxpos + mult1 * g_dxpos;
                            }
                            if (g_tmpoxpos + mult1 * g_dxpos < g_minX)
                            {
                                g_minX = g_tmpoxpos + mult1 * g_dxpos;
                            }
                            if (mult2 * (g_tmpoypos + mult1 * g_dypos) > g_maxY)
                            {
                                g_maxY = mult2 * (g_tmpoypos + mult1 * g_dypos);
                            }
                            if (mult2 * (g_tmpoypos + mult1 * g_dypos) < g_minY)
                            {
                                g_minY = mult2 * (g_tmpoypos + mult1 * g_dypos);
                            }
                            dis_updataP = 1;
                            scale = pat_getScale(patRule.h_patConvasIndex, patRulesTmp);
                            vscale = pat_getFinalScale(scale, scale1);
                            onearpx = 0;
                            onearpy = 0;
                        }
                        else
                        {
                            posx1 = (S32)((g_tmpoxpos + mult1 * g_dxpos) * (vscale) / 1000 + xorg);
                            posy1 = (S32)(mult2 * tmuly * (g_tmpoypos + mult1 * g_dypos) * (vscale) / 1000 + yorg);
                            if (((posx1 < patV.xpis) || (posx1 > patV.xpis + patV.xsize) || (posy1 < patV.ypis) || (posy1 > patV.ypis + patV.ysize)))
                            {
                                dis_updataP = 1;
                            }
                            else
                            {
                                RecoveData2();
                                ReadPointData2(posx1 - 4, posy1 - 4);
                                Draw_SmallCrossLimit(posx1, posy1, COLOR_CROSS, patRule.h_patConvasIndex);
                            }
                        }
                    }
                }
                else
                {
                    switch (keyoff)
                    {
                    case KEY_CURSOR_SCRNSVR:
                        pno = MENU_SCRNSVR;
                        break;
                    case KEY_CURSOR_MENU:
                        pno = MENU_INMENU;
                        poldno[2] = MENU_CURSOR;
                        pnoindex = 3;
                        break;
                        // case KEY_CURSOR_BACK:
                        //     if ((g_temp_clr_flag == 1) && (g_feedc == 0) && (g_feedsum == 0))
                        //     { //无任何操作,重新从主板读回数据
                        //         g_temp_clr_flag = 0;
                        //         g_ImageDis = 1;
                        //         g_modifyflag = 0;
                        //     }
                        //     if (g_modifyflag)
                        //     {
                        //         if (F_FILETYPE == PAT_MIT)
                        //         {
                        //             SREG[g_draw_p++] = 0x1e01;
                        //             SREG[g_draw_p++] = 0;
                        //             SREG[g_draw_p++] = 0;
                        //             SREG[g_draw_p++] = 0;
                        //             SREG[g_line_p++] = g_line_sum++;
                        //             SREG[g_pat_p++] = 0x1e;
                        //             SREG[g_pat_p++] = 0;
                        //             g_NoEndCode = 1;
                        //         }
                        //         else
                        //         {
                        //             g_Ctstaddr = g_Ctendaddr;
                        //             Bor_doEndcmd((U16 *)SREG, (U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, &g_patd.feed_sum);
                        //             HREG[5] = (g_CtPatLen >> 16) & 0xffff;
                        //             HREG[4] = g_CtPatLen & 0xffff;
                        //             g_jog_point = g_patd.feed_sum;
                        //             HREG[5] = (g_CtPatLen >> 16) & 0xffff;
                        //             HREG[4] = g_CtPatLen & 0xffff;
                        //         }
                        //         hleppara = 0;
                        //         pno = MENU_INHELP;
                        //         poldno[pnoindex] = MENU_CURSOR;
                        //         pnoindex++;
                        //     }
                        //     else
                        //     {
                        //         if (g_pfootd.oldbase != g_pfootd.base)
                        //         { //还原原来基准值
                        //             g_pfootd.base = g_pfootd.oldbase;
                        //             //设置中压脚基准值
                        //             f = Write_Cmd(C_PFOOTACTION, g_pfootd.base, 0);
                        //             Read_Status();
                        //             Write_Cmd2(C_PFEST, 1, 2, 0);
                        //             Read_Status();
                        //         }
                        //         if (g_tdtensiond.base != g_tdtensiond.oldbase)
                        //         { //还原原来基准值
                        //             g_tdtensiond.base = g_tdtensiond.oldbase;
                        //             f = Write_Cmd2(C_SETLFORCE, g_tdtensiond.base, 0, 0); //向主板发送保存面线张力基准值命令
                        //             Read_Status();
                        //         }
                        //         pno = MENU_INPUT;
                        //         pnoindex = 2;
                        //     }
                        //     g_endtype = 1;
                        //     break;

                        //case KEY_CURSOR_PAT:
                        //	AnaPattern(0,g_GreatPatType,g_CtPatLen);
                        //	pno = MENU_MOIMAGE;poldno[2] = MENU_CURSOR;pnoindex = 3;
                        //	break;

                        // case KEY_CURSOR_EXPF: //内压板伸缩
                        //     if (Write_Cmd(C_ECLAMP, 0, 0) == 0)
                        //     { //伸缩板
                        //         pno = MENU_RWHELP;
                        //         hleppara = 16;
                        //         poldno[pnoindex++] = MENU_CURSOR;
                        //         break;
                        //     }
                        //     if (Read1_Status(10) == 0)
                        //     {
                        //         pno = MENU_RWHELP;
                        //         hleppara = 15;
                        //         poldno[pnoindex++] = MENU_CURSOR;
                        //         break;
                        //     }
                        //     else if (DREG[D_CMDSTATUS] != 100)
                        //     {
                        //         pno = MENU_RWHELP;
                        //         hleppara = 16;
                        //         poldno[pnoindex++] = MENU_CURSOR;
                        //         break;
                        //     }
                        //     break;

                    case KEY_CURSOR_PFOOTSET:
                        if (g_GreatPatType == 2)
                        { //兄弟
                            if (g_pf_mode == 0)
                            {
                                Bor_CalPFval((U16 *)SREG, g_CtPatLen, g_Ctendaddr, (S16 *)&g_pf_absval);
                                g_pf_absval += g_pfootd.base;
                                Bor_CalPFlimt((U16 *)SREG, g_CtPatLen, &g_patd.PFmax, &g_patd.PFmin);
                                g_updata_pf_valflg = 1;
                                g_pf_dis = 0;
                            }
                        }

                        pno = MENU_PFOOT;
                        g_para0 = 2;
                        poldno[2] = MENU_CURSOR;
                        pnoindex = 3;
                        break;

                    case KEY_CURSOR_ENTER:
                        if (g_GreatPatType == 1) //三菱
                        {
#if 0
                            if ((g_num_mov_key) && ((g_dxpos != 0) || (g_dypos != 0)))
                            {
                                xx = g_tmpoxpos + mult1 * g_dxpos;
                                yy = g_tmpoypos + mult1 * g_dypos;
                                if ((xx < mult1 * g_Mac.max_xl) || (xx > mult1 * g_Mac.max_xr) || (yy > mult1 * g_Mac.max_yu) || (yy < mult1 * g_Mac.max_yd))
                                {
                                    pno = MENU_RWHELP;
                                    hleppara = 23;
                                    poldno[2] = MENU_CURSOR;
                                    pnoindex = 3;
                                    break;
                                }
                                f = Comm_Move(g_tmpoxpos + mult1 * g_dxpos, g_tmpoypos + mult1 * g_dypos, 80, MENU_CURSOR, 0, 0);
                                if (f == 0)
                                {
                                    break;
                                }
                                vflag = 0;
                                vposx = g_tmpoxpos + mult1 * g_dxpos;
                                vposy = g_tmpoypos + mult1 * g_dypos;
                                if (g_tmpoxpos + mult1 * g_dxpos > g_maxX || g_tmpoxpos + mult1 * g_dxpos < g_minX || mult2 * (g_tmpoypos + mult1 * g_dypos) > g_maxY || mult2 * (g_tmpoypos + mult1 * g_dypos) < g_minY)
                                {
                                    if (g_tmpoxpos + mult1 * g_dxpos > g_maxX)
                                    {
                                        g_maxX = g_tmpoxpos + mult1 * g_dxpos;
                                    }
                                    if (g_tmpoxpos + mult1 * g_dxpos < g_minX)
                                    {
                                        g_minX = g_tmpoxpos + mult1 * g_dxpos;
                                    }
                                    if (mult2 * (g_tmpoypos + mult1 * g_dypos) > g_maxY)
                                    {
                                        g_maxY = mult2 * (g_tmpoypos + mult1 * g_dypos);
                                    }
                                    if (mult2 * (g_tmpoypos + mult1 * g_dypos) < g_minY)
                                    {
                                        g_minY = mult2 * (g_tmpoypos + mult1 * g_dypos);
                                    }
                                    dis_updataP = 1;
                                    scale = pat_getScale(patRule.h_patConvasIndex, patRulesTmp);
                                    vscale = pat_getFinalScale(scale, scale1);
                                }
                                else
                                {
                                    posx1 = (S32)((g_tmpoxpos + mult1 * g_dxpos) * (vscale) / 1000 + xorg);
                                    posy1 = (S32)(mult2 * tmuly * (g_tmpoypos + mult1 * g_dypos) * (vscale) / 1000 + yorg);
                                    if (((posx1 < patV.xpis) || (posx1 > patV.xpis + patV.xsize) || (posy1 < patV.ypis) || (posy1 > patV.ypis + patV.ysize)))
                                    {
                                        dis_updataP = 1;
                                    }
                                    else
                                    {
                                        RecoveData2();
                                        ReadPointData2(posx1 - 4, posy1 - 4);
                                        Draw_SmallCrossLimit(posx1, posy1, COLOR_CROSS, patRule.h_patConvasIndex);
                                    }
                                }
                            }
#endif

                            if (g_ct_insert_flag == 2)
                            { //段插入
                                if ((g_dxpos != 0) || (g_dypos != 0))
                                {
                                    if (((!g_feed_flag) || (g_input_method == 1) || (g_input_method == 2)))
                                    { //空送/点/直线
                                        tfeed_flag = g_feed_flag;
                                        tpoint_num = g_point_num;
                                        // tpara_offset = g_para_offset;
                                        tfeedsum = g_patd.feed_sum;
                                        //if((!g_feed_flag)&&SREG[52000+g_feedc*2]==0x02){	//剪线
                                        //	g_feedc++;
                                        //}
                                        tfeedc = g_feedc;
                                        g_jog_stpoint = g_feedc;
                                        g_jog_enpoint = g_feedc;

                                        g_array4[g_point_num][0] = g_dxpos; //记录控制点的绝对坐标
                                        g_array4[g_point_num][1] = g_dypos;
                                        g_array5[g_point_num][0] = g_dxpos; //记录控制点相对坐标
                                        g_array5[g_point_num][1] = g_dypos;

                                        g_nolimt = 1;
                                        mit_CtToMod();
                                        AnaPattern(0, g_GreatPatType, 0);
                                        g_feed_flag = tfeed_flag;
                                        g_point_num = tpoint_num;
                                        //g_para_offset = tpara_offset;
                                        if (!g_feed_flag)
                                        { //空送
                                            g_selectmode = 5;
                                        }
                                        else if (g_input_method == 1)
                                        { //点
                                            g_selectmode = 6;
                                        }
                                        else if (g_input_method == 2)
                                        { //直线
                                            g_selectmode = 0;
                                        }
                                        g_point_num++;
                                        g_temp_point_num = g_point_num;
                                        //printf("-0- g_patd.feed_sum = %d  tfeedsum = %d  g_ctAddpins = %d  g_feedc = %d tfeedc =%d\r\n",g_patd.feed_sum,tfeedsum,g_ctAddpins,g_feedc,tfeedc);
                                        tfeedsum = g_patd.feed_sum;
                                        f = Mit_Modify_Data(20);
                                        //AnaPattern(0,0,0);
                                        //g_ctAddpins = g_patd.feed_sum-tfeedsum;
                                        //printf("f = %d g_ct_insert_flag = %d  g_ctAddpins = %d \r\n",f,g_ct_insert_flag,g_ctAddpins);
                                        g_nolimt = 0;

                                        mit_ModToCt();
                                        AnaPattern(0, g_GreatPatType, 0);

                                        g_feed_flag = 1;

                                        //printf("-- g_patd.feed_sum = %d  tfeedsum = %d  g_ctAddpins = %d  g_feedc = %d tfeedc =%d\r\n",g_patd.feed_sum,tfeedsum,g_ctAddpins,g_feedc,tfeedc);
                                        g_feedsum = g_patd.feed_sum;
                                        g_feedc = tfeedc + g_ctAddpins;
                                        tfeedc = g_feedc;
                                        mitPinmsg = mit_getPinsMsg((U16 *)SREG, 52000, g_feedc);
                                        //printf("g_patd.pat_add =%d  px = %d py =%d  dx = %d  dy = %d speed = %02x g_oxpos = %d  g_oypos = %d g_feedc = %d g_inoxpos = %d g_inoypos = %d\r\n",g_patd.pat_add,mitPinmsg.posx,mitPinmsg.posy,mitPinmsg.dx,mitPinmsg.dy,mitPinmsg.speed,g_oxpos,g_oypos,g_feedc,g_inoxpos,g_inoypos);

                                        //--绘制空送回到原来位置
                                        g_dxpos = g_inoxpos - mitPinmsg.posx;
                                        g_dypos = g_inoypos - mitPinmsg.posy;
                                        if (g_dxpos != 0 || g_dypos != 0)
                                        {
                                            g_nolimt = 1;
                                            g_point_num = 1;
                                            g_jog_stpoint = g_feedc;
                                            g_jog_enpoint = g_feedc;
                                            g_array4[g_point_num][0] = g_dxpos; //记录控制点的绝对坐标
                                            g_array4[g_point_num][1] = g_dypos;
                                            g_array5[g_point_num][0] = g_dxpos; //记录控制点相对坐标
                                            g_array5[g_point_num][1] = g_dypos;
                                            g_point_num++;
                                            g_temp_point_num = g_point_num;
                                            //printf("0 g_patd.feed_sum = %d \r\n",g_patd.feed_sum);
                                            mit_CtToMod();
                                            //printf("1 g_patd.feed_sum = %d \r\n",g_patd.feed_sum);
                                            AnaPattern(0, g_GreatPatType, 0);
                                            g_nolimt = 0;
                                            //printf("2 g_patd.feed_sum = %d \r\n",g_patd.feed_sum);
                                            f = Mit_Modify_Data(21);
                                            mit_ModToCt();
                                            //printf("0 patmX = %d  patiX = %d  patmY = %d patiY =%d\r\n",g_patd.patmX,g_patd.patiX,g_patd.patmY,g_patd.patiY);
                                            //g_patd.patmX =0;g_patd.patiX =0;g_patd.patmY =0;g_patd.patiY =0;
                                            AnaPattern(0, g_GreatPatType, 0);
                                            //printf("1 patmX = %d  patiX = %d  patmY = %d patiY =%d\r\n",g_patd.patmX,g_patd.patiX,g_patd.patmY,g_patd.patiY);
                                            g_feedc = tfeedc;
                                            g_feedsum = g_patd.feed_sum;
                                        }
                                        g_maxX = g_patd.patmX;
                                        g_minX = g_patd.patiX;
                                        g_maxY = g_patd.patmY;
                                        g_minY = g_patd.patiY;

                                        g_dxpos = 0;
                                        g_dypos = 0;

                                        g_point_num = 1;
                                        g_ct_insert_flag = 1;
                                        dismove = 1;
                                        g_ct_status_flag = 0x7cfdf;
                                        g_ct_status_flag |= bit19;

                                        if (Up)
                                        { //压脚在下面，先抬起压脚
                                            Up = 0;
                                            Dn = 1;
                                            Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                        }
                                        g_oxpos = mitPinmsg.posx;
                                        g_oypos = mitPinmsg.posy;
                                        Comm_Move(g_oxpos, g_oypos, 120, MENU_CURSOR, 0, 0);

                                        if (f == 0)
                                        {
                                            g_ct_insert_flag = 3;
                                            pno = MENU_INHELP;
                                            hleppara = 8;
                                            poldno[2] = MENU_CURSOR;
                                            pnoindex = 3;
                                            break;
                                        }
                                        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);

                                        dis_updata = 1;
                                        dis_updata2 = 1;
                                        dis_updataP = 2;
                                        scale = pat_getScale(patRule.h_patConvasIndex, patRulesTmp);
                                        vscale = pat_getFinalScale(scale, scale1);

                                        tonear = 0;
                                        getNearflag = 2;

                                        break;
                                    }
                                    else if ((g_input_method == 4 || g_input_method == 5) && g_point_num > 1)
                                    { //圆、圆弧

                                        pno = MENU_INHELP;
                                        hleppara = 1;
                                        poldno[2] = MENU_CURSOR;
                                        pnoindex = 3;
                                        break;
                                    }
                                    else
                                    {
                                        g_array4[g_point_num][0] = g_dxpos; //记录控制点的绝对坐标
                                        g_array4[g_point_num][1] = g_dypos;
                                        g_array5[g_point_num][0] = g_dxpos; //记录控制点相对坐标
                                        g_array5[g_point_num][1] = g_dypos;
                                        g_oxpos = g_tmpoxpos + g_dxpos;
                                        g_oypos = g_tmpoypos + g_dypos;
                                        g_tmpoxpos = g_oxpos;
                                        g_tmpoypos = g_oypos;

                                        g_dxpos = 0;
                                        g_dypos = 0;
                                        g_point_num++;
                                        // DrawFillRect(416, 36, 24, 16, mCOLOR ? Color_Silver : Color_White);
                                        // DrawFS32P(416, 36, g_point_num, 3, 0, Color_Black);
                                        // DrawFillRect(rect[RECT_CURSOR_P_STR].xpis, rect[RECT_CURSOR_P_STR].ypis,
                                        //              rect[RECT_CURSOR_P_STR].xsize, rect[RECT_CURSOR_P_STR].ysize, rect[RECT_CURSOR_P_STR].colorB[0]);
                                        // DrawFS32P(rect[RECT_CURSOR_P_STR].xpis + SAFE_DIST4, rect[RECT_CURSOR_P_STR].ypis + SAFE_DIST4,
                                        //           g_point_num, 3, 0, rect[RECT_CURSOR_P_STR].colorT[0]);
                                        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                                    }
                                }
                                else if ((g_input_method == 3 || g_input_method == 6) && g_point_num > 1)
                                { //折线 曲线
                                    pno = MENU_INHELP;
                                    hleppara = 1;
                                    poldno[2] = MENU_CURSOR;
                                    pnoindex = 3;
                                    break;
                                }
                                else
                                {
                                    break;
                                }

                                dis_updata = 1;
                                dis_updataP = 1;
                                scale = pat_getScale(patRule.h_patConvasIndex, patRulesTmp);
                                vscale = pat_getFinalScale(scale, scale1);

                                tonear = 0;
                                getNearflag = 2;
                                break;
                            }

                            if ((!g_feed_flag) || (g_input_method == 1) || (g_input_method == 2))
                            { //空送/点/直线
                                if ((g_dxpos != 0) || (g_dypos != 0))
                                {
                                    if (g_jogmethod)
                                    { //花样轨迹移动
                                        cpx0 = g_tmpoxpos + mult1 * g_dxpos;
                                        cpy0 = g_tmpoypos + mult1 * g_dypos;
                                        cpx = cpx0;
                                        cpy = cpy0;
                                    }
                                    f = Mit_Create_Data(1);
                                    if (f == 1)
                                    { //生成花样数据成功
                                        if (Up)
                                        { //压脚在下面，先抬起压脚
                                            Up = 0;
                                            Dn = 1;
                                            Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                        }
                                        if (g_jogmethod)
                                        { //花样轨迹移动
                                            cfeed = mitFindPinAndPos(g_patd.feed_sum, g_feedsum, &cpx, &cpy);
                                            if ((cpx != cpx0) || (cpy != cpy0))
                                            {
                                                Comm_Move(cpx, cpy, 120, MENU_CURSOR, 0, 0);
                                            }
                                            mitP2Pmove(cfeed, g_feedsum, MENU_CURSOR);
                                        }
                                        else
                                        {
                                            Comm_Move(g_oxpos, g_oypos, 120, MENU_CURSOR, 0, 0);
                                        }
                                    }
                                    g_disxpos = g_oxpos;
                                    g_disypos = g_oypos;
                                    AnaPattern(0, g_GreatPatType, g_CtPatLen);
                                    g_maxX = g_patd.patmX;
                                    g_minX = g_patd.patiX;
                                    g_maxY = g_patd.patmY;
                                    g_minY = g_patd.patiY;
                                }
                            }
                            else if ((g_input_method == 4) || (g_input_method == 5))
                            { //圆/圆弧
                                if ((g_point_num == 1) && ((g_dxpos != 0) || (g_dypos != 0)))
                                {
                                    g_tmpoxpos += g_dxpos;
                                    g_tmpoypos += g_dypos;
                                    Mit_Create_Data(1);
                                    AnaPattern(0, g_GreatPatType, g_CtPatLen);
                                    //										g_maxX = g_patd.patmX;
                                    //										g_minX = g_patd.patiX;
                                    //										g_maxY = g_patd.patmY;
                                    //										g_minY = g_patd.patiY;
                                }
                                else
                                {
                                    pno = MENU_INHELP;
                                    hleppara = 1;
                                    poldno[2] = MENU_CURSOR;
                                    pnoindex = 3;
                                }
                            }
                            else
                            {
                                if (((g_dxpos == 0) && (g_dypos == 0)) || (g_point_num > SPLINESUM_MAX))
                                {
                                    pno = MENU_INHELP;
                                    hleppara = 1;
                                    poldno[2] = MENU_CURSOR;
                                    pnoindex = 3;
                                }
                                else
                                {
                                    g_tmpoxpos += g_dxpos;
                                    g_tmpoypos += g_dypos;
                                    Mit_Create_Data(1);
                                }
                            }
                            g_updata_pf_valflg = 1;
                            g_pfootsetOffest = g_pf_absval - g_pfootd.base;
                            g_dxpos = 0; //修改-新增
                            g_dypos = 0;
                            bEditFlashFlag = 1;
                        }
                        else if (g_GreatPatType == 2)
                        { //兄弟
                            if ((g_num_mov_key) && ((g_dxpos != 0) || (g_dypos != 0)))
                            {
                                xx = g_tmpoxpos + mult1 * g_dxpos;
                                yy = g_tmpoypos + mult1 * g_dypos;
                                if ((xx < mult1 * mult3 * g_Mac.max_xl) || (xx > mult1 * mult3 * g_Mac.max_xr) || (yy > mult1 * mult3 * g_Mac.max_yu) || (yy < mult1 * mult3 * g_Mac.max_yd))
                                {
                                    pno = MENU_RWHELP;
                                    hleppara = 23;
                                    poldno[2] = MENU_CURSOR;
                                    pnoindex = 3;
                                    break;
                                }
                                f = Comm_Move(g_tmpoxpos + mult1 * g_dxpos, g_tmpoypos + mult1 * g_dypos, 80, MENU_CURSOR, 1, 0);
                                if (f == 0)
                                {
                                    break;
                                }
                                vflag = 0;
                                vposx = g_tmpoxpos + mult1 * g_dxpos;
                                vposy = g_tmpoypos + mult1 * g_dypos;
                                if (g_tmpoxpos + mult1 * g_dxpos > g_maxX || g_tmpoxpos + mult1 * g_dxpos < g_minX || mult2 * (g_tmpoypos + mult1 * g_dypos) > g_maxY || mult2 * (g_tmpoypos + mult1 * g_dypos) < g_minY)
                                {
                                    if (g_tmpoxpos + mult1 * g_dxpos > g_maxX)
                                    {
                                        g_maxX = g_tmpoxpos + mult1 * g_dxpos;
                                    }
                                    if (g_tmpoxpos + mult1 * g_dxpos < g_minX)
                                    {
                                        g_minX = g_tmpoxpos + mult1 * g_dxpos;
                                    }
                                    if (mult2 * (g_tmpoypos + mult1 * g_dypos) > g_maxY)
                                    {
                                        g_maxY = mult2 * (g_tmpoypos + mult1 * g_dypos);
                                    }
                                    if (mult2 * (g_tmpoypos + mult1 * g_dypos) < g_minY)
                                    {
                                        g_minY = mult2 * (g_tmpoypos + mult1 * g_dypos);
                                    }
                                    dis_updataP = 1;
                                    scale = pat_getScale(patRule.h_patConvasIndex, patRulesTmp);
                                    vscale = pat_getFinalScale(scale, scale1);
                                }
                                else
                                {
                                    posx1 = (S32)((g_tmpoxpos + mult1 * g_dxpos) * (vscale) / 1000 + xorg);
                                    posy1 = (S32)(mult2 * tmuly * (g_tmpoypos + mult1 * g_dypos) * (vscale) / 1000 + yorg);
                                    if (((posx1 < patV.xpis) || (posx1 > patV.xpis + patV.xsize) || (posy1 < patV.ypis) || (posy1 > patV.ypis + patV.ysize)))
                                    {
                                        dis_updataP = 1;
                                    }
                                    else
                                    {
                                        RecoveData2();
                                        ReadPointData2(posx1 - 4, posy1 - 4);
                                        Draw_SmallCrossLimit(posx1, posy1, COLOR_CROSS, patRule.h_patConvasIndex);
                                    }
                                }
                                g_disxpos = g_tmpoxpos + mult1 * g_dxpos;
                                g_disypos = g_tmpoypos + mult1 * g_dypos;
                            }

                            if (g_ct_insert_flag == 2)
                            { //段插入
                                if ((g_dxpos != 0) || (g_dypos != 0))
                                {

                                    if (g_feed_flag == 0)
                                    { //空送
                                        for (i = 0; i < MAXBLKSREG; i++)
                                        {
                                            BLKSREG[i] = SREG[i];
                                        }
                                        g_blkInsetlen = g_CtPatLen;

                                        tmpCreatstaddr = g_Ctendaddr;
                                        tmpCreatstaddr1 = g_Ctendaddr;
                                        g_ctAddpins = 0;

                                        f = Bor_CreatData((U32 *)&tmpCreatstaddr1, (U32 *)&g_Ctendaddr, 0, 0, mult1 * g_dxpos, mult1 * g_dypos, 0, (U32 *)&g_CtPatLen, 1, 0);
                                        g_ctAddpins += (g_Ctendaddr - tmpCreatstaddr1) / 4 + ((g_Ctendaddr - tmpCreatstaddr1) % 4 ? 1 : 0);

                                        sew_UpFeed((U16 *)&SREG, -mult1 * g_dxpos, -mult1 * g_dypos, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen);

                                        g_array4[0][0] = 0;
                                        g_point_num = 1;

                                        //g_Ctstaddr = g_Ctendaddr;

                                        g_Ctstaddr = sew_getPinAddr((U16 *)SREG, g_CtPatLen, g_feedc, 1);
                                        g_Ctsavetimes = 0;
                                        g_blkInset = 1;
                                        Bor_CreatBack((U16 *)&g_Ctsavetimes, g_Ctstaddr, g_Ctstaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);
                                        //printf("g_Ctendaddr = %d tmpCreatstaddr = %d  \r\n",g_Ctendaddr,tmpCreatstaddr);
                                        g_ct_status_flag = 0;
                                        g_feed_flag = 1;
                                        g_feedsum = g_patd.feed_sum;
                                        g_feedc += g_ctAddpins;

                                        //stflag =2;
                                        g_dxpos = 0;
                                        g_dypos = 0;
                                        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);

                                        g_ct_insert_flag = 1;
                                        dismove = 1;
                                        g_ct_status_flag = 0x7cfdf;
                                        g_ct_status_flag |= bit19;
                                        dis_updata = 1;
                                        dis_updata2 = 1;
                                        dis_updataP = 2;
                                        scale = pat_getScale(patRule.h_patConvasIndex, patRulesTmp);
                                        vscale = pat_getFinalScale(scale, scale1);

                                        tonear = 0;
                                        getNearflag = 2;
                                        break;
                                    }
                                    else if ((g_input_method == 1 || g_input_method == 2))
                                    { //点、直线
                                        for (i = 0; i < MAXBLKSREG; i++)
                                        {
                                            BLKSREG[i] = SREG[i];
                                        }
                                        g_blkInsetlen = g_CtPatLen;
                                        g_nolimt = 1;
                                        tmpCreatstaddr = g_Ctendaddr;
                                        tmpCreatstaddr1 = g_Ctendaddr;
                                        ctBackSaddr = g_Ctstaddr;
                                        ctBackEaddr = g_Ctendaddr;
                                        g_ctAddpins = 0;
                                        tfeed = g_feedc;
                                        tfeedsum = g_patd.feed_sum;
                                        exflag = 0; //清除附加功能标志，记录有无速度、中压脚功能
                                        ////空送到起始点
                                        //f = Bor_CreatData((U32*)&tmpCreatstaddr1,(U32*)&g_Ctendaddr,0,0,2*g_dxpos,2*g_dypos,0,(U32*)&g_CtPatLen,1,0);
                                        //g_ctAddpins += (g_Ctendaddr-tmpCreatstaddr1)/4 + ((g_Ctendaddr-tmpCreatstaddr1)%4?1:0);
                                        //printf("g_oldspeed = %d g_speed = %d  g_Ctendaddr = %d  \r\n",g_oldspeed,g_speed,g_Ctendaddr);
                                        if (g_oldspeed != g_speed)
                                        { //修改速度
                                            tmpCreatstaddr1 = g_Ctendaddr;
                                            Bor_doSpeed((U16 *)SREG, (U32 *)&tmpCreatstaddr1, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, g_speed, &g_patd.feed_sum);
                                            g_oldspeed = g_speed;
                                            exflag |= 0x01; //标记速度修改
                                        }

                                        if ((g_pf_dis != 0) && g_pf_mode)
                                        { //	中压脚
                                            tmpCreatstaddr1 = g_Ctendaddr;
                                            Bor_doPF((U16 *)SREG, (U32 *)&tmpCreatstaddr1, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, g_pf_absval - g_pfootd.base, &g_patd.feed_sum);
                                            g_updata_pf_valflg = 1;
                                            exflag |= 0x02; //标记中压脚修改
                                            g_pf_mode = 0;
                                        }

                                        exflag = 0; //清除附加功能标志，记录有离边，重缝，Z缝、倒缝功能
                                        if (g_para_offset == 3)
                                        { //离边
                                            exflag |= 0x01;
                                        }
                                        else if ((g_para_offset == 1) || (g_para_offset == 2) || (g_para_offset == 4) || (g_para_offset == 5))
                                        { //多重缝
                                            exflag |= 0x02;
                                        }

                                        if (g_zig_zag)
                                        { //Z缝
                                            exflag |= 0x04;
                                        }

                                        if (g_bt_mode)
                                        { //倒缝
                                            exflag |= 0x08;
                                        }

                                        //g_oxpos = g_tmpoxpos + 2*g_dxpos;
                                        //g_oypos = g_tmpoypos + 2*g_dypos;
                                        //printf("-- g_ctAddpins = %d g_oxpos = %d g_oypos =%d g_tmpoxpos = %d g_tmpoypos =%d g_dxpos =%d g_dypos =%d\r\n",g_ctAddpins,g_oxpos,g_oypos,g_tmpoxpos,g_tmpoypos,g_dxpos,g_dypos);
                                        tmpCreatstaddr1 = g_Ctendaddr;
                                        //printf("--0 g_ctAddpins = %d \r\n",g_ctAddpins);
                                        f = Bor_CreatData((U32 *)&tmpCreatstaddr1, (U32 *)&g_Ctendaddr, 0, 0, mult1 * g_dxpos, mult1 * g_dypos, g_pitch, (U32 *)&g_CtPatLen, g_input_method + 1, exflag);
                                        g_ctAddpins = g_patd.feed_sum - tfeedsum;
                                        //printf("tfeedsum = %d  g_patd.feed_sum = %d \r\n",tfeedsum,g_patd.feed_sum);
                                        //printf("--1 g_ctAddpins = %d g_oxpos = %d g_oypos =%d g_tmpoxpos = %d g_tmpoypos =%d g_dxpos =%d g_dypos =%d\r\n",g_ctAddpins,g_oxpos,g_oypos,g_tmpoxpos,g_tmpoypos,g_dxpos,g_dypos);

                                        g_nolimt = 0;
                                        if (f)
                                        {
                                            g_feedc += g_ctAddpins;
                                            Bor_feedInfo(g_feedc, g_CtPatLen, &Borcmd, (S16 *)&g_oxpos, (S16 *)&g_oypos, (S16 *)&tmpxdat1, (S16 *)&tmpydat1, (U8 *)&g_oldspeed, &Borpooft, &Borpfdis);
                                            g_oxpos += tmpxdat1;
                                            g_oypos += tmpydat1;
                                            if (g_oldspeed == 0)
                                                g_oldspeed = 0x60;
                                            else if (g_oldspeed == 1)
                                                g_oldspeed = 0x40;
                                            else if (g_oldspeed == 2)
                                                g_oldspeed = 0x20;
                                            else
                                                g_oldspeed = 0x0;

                                            f = sew_UpFeed((U16 *)&SREG, g_inoxpos - g_oxpos, g_inoypos - g_oypos, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen);
                                        }
                                        g_nolimt = 0;
                                        if ((f == 1) || (f == 2))
                                        {
                                            g_para_offset = 0;
                                            g_zig_zag = 0;
                                            g_bt_mode = 0;
                                            g_array4[0][0] = 0;
                                            g_point_num = 1;

                                            if (Up)
                                            { //压脚在下面，先抬起压脚
                                                Up = 0;
                                                Dn = 1;
                                                Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                            }
                                            Comm_Move(g_oxpos, g_oypos, 80, MENU_CURSOR, 1, 1);
                                            //printf("g_oxpos = %d  g_oypos = %d g_inoxpos = %d g_inoypos = %d g_ctAddpins = %d \r\n",g_oxpos,g_oypos,g_inoxpos,g_inoypos,g_ctAddpins);
                                            //空送回来
                                            tmpCreatstaddr1 = g_Ctendaddr;

                                            //f = Bor_CreatData((U32*)&tmpCreatstaddr1,(U32*)&g_Ctendaddr,g_oxpos,g_oypos,g_inoxpos,g_inoypos,0,(U32*)&g_CtPatLen,1,0);

                                            g_blkInset = 1;
                                            g_Ctsavetimes = 0;
                                            g_Ctstaddr = sew_getPinAddr((U16 *)SREG, g_CtPatLen, g_feedc, 1);
                                            Bor_CreatBack((U16 *)&g_Ctsavetimes, g_Ctstaddr, g_Ctstaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);

                                            g_ct_status_flag = 0;
                                            g_feed_flag = 1;
                                            g_feedsum = g_patd.feed_sum;

                                            g_dxpos = 0;
                                            g_dypos = 0;
                                            dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);

                                            g_ct_insert_flag = 1;
                                            dismove = 1;
                                            g_ct_status_flag = 0x7cfdf;
                                            g_ct_status_flag |= bit19;
                                            dis_updata = 1;
                                            dis_updata2 = 1;
                                            dis_updataP = 2;
                                            scale = pat_getScale(CONVAS5, PATRULES_CREATE1);

                                            tonear = 0;
                                            getNearflag = 2;

                                            break;
                                        }
                                        else
                                        {
                                            if (f == 3)
                                            {
                                                g_feedc = tfeed;
                                                Bor_CreatUnDO(tmpCreatstaddr, g_Ctendaddr, (U32 *)&g_CtPatLen);
                                                g_Ctstaddr = ctBackSaddr;
                                                g_Ctendaddr = ctBackEaddr;
                                                g_oxpos = g_tmpoxpos + mult1 * g_dxpos;
                                                g_oypos = g_tmpoypos + mult1 * g_dypos;
                                            }
                                            pno = MENU_INHELP;
                                            hleppara = 2;
                                            poldno[2] = MENU_CURSOR;
                                            pnoindex = 3;
                                        }
                                        g_disxpos = g_oxpos;
                                        g_disypos = g_oypos;
                                        g_pf_dis = 0;
                                        //stflag =2;
                                    }
                                    else if ((g_input_method == 4 || g_input_method == 5) && g_point_num > 1)
                                    { //圆、圆弧

                                        g_array4[0][0]++;
                                        g_oxpos = g_tmpoxpos + mult1 * g_dxpos;
                                        g_oypos = g_tmpoypos + mult1 * g_dypos;
                                        g_array4[g_point_num][0] = g_oxpos;
                                        g_array4[g_point_num][1] = g_oypos;
                                        g_array5[g_point_num][0] = g_dxpos;
                                        g_array5[g_point_num][1] = g_dypos;
                                        pno = MENU_INHELP;
                                        hleppara = 1;
                                        poldno[2] = MENU_CURSOR;
                                        pnoindex = 3;
                                    }
                                    else
                                    {
                                        g_array4[0][0]++;
                                        g_array4[g_point_num][0] = g_tmpoxpos + mult1 * g_dxpos; //记录控制点的绝对坐标
                                        g_array4[g_point_num][1] = g_tmpoypos + mult1 * g_dypos;
                                        g_array5[g_point_num][0] = g_dxpos; //记录控制点相对坐标
                                        g_array5[g_point_num][1] = g_dypos;
                                        g_oxpos = g_tmpoxpos + mult1 * g_dxpos;
                                        g_oypos = g_tmpoypos + mult1 * g_dypos;
                                        g_tmpoxpos = g_oxpos;
                                        g_tmpoypos = g_oypos;

                                        g_dxpos = 0;
                                        g_dypos = 0;
                                        g_point_num++;
                                        // DrawFillRect(416, 36, 24, 16, mCOLOR ? Color_Silver : Color_White);
                                        // DrawFS32P(416, 36, g_point_num, 3, 0, Color_Black);
                                        DrawFillRect(rect[RECT_CURSOR_P_STR].xpis, rect[RECT_CURSOR_P_STR].ypis,
                                                     rect[RECT_CURSOR_P_STR].xsize, rect[RECT_CURSOR_P_STR].ysize, rect[RECT_CURSOR_P_STR].colorB[0]);
                                        DrawFS32P(rect[RECT_CURSOR_P_STR].xpis + SAFE_DIST4, rect[RECT_CURSOR_P_STR].ypis + SAFE_DIST4,
                                                  g_point_num, 3, 0, rect[RECT_CURSOR_P_STR].colorT[0]);
                                        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                                    }
                                }
                                else if (g_input_method == 3)
                                { //折线
                                    if (g_point_num > 1)
                                    {
                                        pno = MENU_INHELP;
                                        hleppara = 1;
                                        poldno[2] = MENU_CURSOR;
                                        pnoindex = 3;
                                        break;
                                    }
                                }
                                else if (g_input_method == 6)
                                { //曲线
                                    if (g_point_num > 1)
                                    {
                                        pno = MENU_INHELP;
                                        hleppara = 1;
                                        poldno[2] = MENU_CURSOR;
                                        pnoindex = 3;
                                        break;
                                    }
                                }

                                dis_updata = 1;
                                dis_updataP = 1;
                                scale = pat_getScale(patRule.h_patConvasIndex, patRulesTmp);
                                vscale = pat_getFinalScale(scale, scale1);

                                tonear = 0;
                                getNearflag = 2;
                                break;
                            }
                            if (g_feed_flag == 0)
                            { //空送
                                if ((g_dxpos != 0) || (g_dypos != 0))
                                {
                                    //										borBatPf = 0;
                                    //										if((g_pf_dis !=0)&&g_pf_mode&&(g_isBAT==1)){	//跳缝前插入中压脚指令
                                    //											g_Ctstaddr = g_Ctendaddr-1;
                                    //											addr1 = g_Ctstaddr;
                                    //											Bor_doPF((U16*)SREG,(U32*)&g_Ctstaddr,(U32*)&addr1,(U32*)&g_CtPatLen,g_pf_absval-g_pfootd.base,&g_patd.feed_sum);
                                    //											g_updata_pf_valflg =1;
                                    //											g_Ctendaddr = addr1+1;
                                    //											g_pf_mode = 0;
                                    //											borBatPf = 1;
                                    //										}
                                    //
                                    //										g_Ctstaddr = g_Ctendaddr;
                                    //										if(exflag==0){	addr1 = g_Ctstaddr;}
                                    g_blkInset = 0;
                                    tmpCreatstaddr = g_Ctendaddr;
                                    f = Bor_CreatData((U32 *)&tmpCreatstaddr, (U32 *)&g_Ctendaddr, 0, 0, mult1 * g_dxpos, mult1 * g_dypos, 0, (U32 *)&g_CtPatLen, 1, 0);
                                    //										g_isBAT = 0;	//清除跳缝标志
                                    g_oxpos = g_tmpoxpos + mult1 * g_dxpos;
                                    g_oypos = g_tmpoypos + mult1 * g_dypos;
                                    g_disxpos = g_oxpos;
                                    g_disypos = g_oypos;
                                    g_array4[0][0] = 0;
                                    g_point_num = 1;
                                    if (f == 1)
                                    { //成功  则备份本次花样数据
                                        g_Ctstaddr = tmpCreatstaddr;
                                        Bor_CreatBack((U16 *)&g_Ctsavetimes, g_Ctstaddr, g_Ctendaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);
                                    }
                                    g_dxpos = 0;
                                    g_dypos = 0;
                                    g_ct_status_flag = 0;
                                    g_feed_flag = 1;
                                    g_feedsum = g_patd.feed_sum;
                                    g_feedc = g_patd.feed_sum;
                                    dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);

                                    g_maxX = g_patd.patmX;
                                    g_minX = g_patd.patiX;
                                    g_maxY = g_patd.patmY;
                                    g_minY = g_patd.patiY;
                                }
                            }
                            else
                            {
                                if (((g_input_method == 1) || ((g_input_method == 2))) && ((g_dxpos != 0) || (g_dypos != 0)))
                                { //点、直线
                                    ctBackSaddr = g_Ctstaddr;
                                    ctBackEaddr = g_Ctendaddr;
                                    //										g_isBAT = 0;	//清除跳缝标志
                                    exflag = 0; //清除附加功能标志，记录有无速度、中压脚功能
                                                //									#if Debug
                                                //										printf("---    ---  g_oldspeed = %d g_speed = %d \r\n",g_oldspeed,g_speed);
                                                //									#endif
                                    g_blkInset = 0;
                                    if (g_oldspeed != g_speed)
                                    { //修改速度
                                        g_Ctstaddr = g_Ctendaddr;
                                        addr1 = g_Ctstaddr;
                                        Bor_doSpeed((U16 *)SREG, (U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, g_speed, &g_patd.feed_sum);
                                        g_oldspeed = g_speed;
                                        exflag |= 0x01; //标记速度修改
                                    }

                                    if ((g_pf_dis != 0) && g_pf_mode)
                                    { //	中压脚
                                        g_Ctstaddr = g_Ctendaddr;
                                        if (exflag == 0)
                                        {
                                            addr1 = g_Ctstaddr;
                                        }

                                        Bor_doPF((U16 *)SREG, (U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, g_pf_absval - g_pfootd.base, &g_patd.feed_sum);
                                        g_updata_pf_valflg = 1;
                                        exflag |= 0x02; //标记中压脚修改
                                        g_pf_mode = 0;
                                    }

                                    g_Ctstaddr = g_Ctendaddr;
                                    if (exflag == 0)
                                    {
                                        addr1 = g_Ctstaddr;
                                    }

                                    exflag = 0; //清除附加功能标志，记录有离边，重缝，Z缝、倒缝功能
                                    if (g_para_offset == 3)
                                    { //离边
                                        exflag |= 0x01;
                                    }
                                    else if ((g_para_offset == 1) || (g_para_offset == 2) || (g_para_offset == 4) || (g_para_offset == 5))
                                    { //多重缝
                                        exflag |= 0x02;
                                    }

                                    if (g_zig_zag)
                                    { //Z缝
                                        exflag |= 0x04;
                                    }

                                    if (g_bt_mode)
                                    { //倒缝
                                        exflag |= 0x08;
                                    }

                                    g_oxpos = g_tmpoxpos + mult1 * g_dxpos;
                                    g_oypos = g_tmpoypos + mult1 * g_dypos;

                                    f = Bor_CreatData((U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, g_tmpoxpos, g_tmpoypos, g_tmpoxpos + mult1 * g_dxpos, g_tmpoypos + mult1 * g_dypos, g_pitch, (U32 *)&g_CtPatLen, g_input_method + 1, exflag);
                                    if ((f == 1) || (f == 2))
                                    {
                                        g_para_offset = 0;
                                        g_zig_zag = 0;
                                        g_bt_mode = 0;
                                        g_array4[0][0] = 0;
                                        g_point_num = 1;

                                        if ((g_oxpos != (g_tmpoxpos + mult1 * g_dxpos)) || (g_oypos != (g_tmpoypos + mult1 * g_dypos)))
                                        { //生成花样后，花样结束点坐标和平台移动最后坐标不同
                                            if (Up)
                                            { //压脚在下面，先抬起压脚
                                                Up = 0;
                                                Dn = 1;
                                                Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                            }
                                            if (g_jogmethod)
                                            { //花样轨迹移动
                                                cpx = g_tmpoxpos + mult1 * g_dxpos;
                                                cpy = g_tmpoypos + mult1 * g_dypos;
                                                cfeed = sewFindPinAndPos(g_CtPatLen, g_feedsum, g_patd.feed_sum, &cpx, &cpy);
                                                if ((cpx != (g_tmpoxpos + mult1 * g_dxpos)) || (cpy != (g_tmpoypos + mult1 * g_dypos)))
                                                {
                                                    Comm_Move(cpx, cpy, 80, MENU_CURSOR, 1, 1);
                                                }
                                                sewP2Pmove(g_CtPatLen, cfeed, g_patd.feed_sum, MENU_CURSOR);
                                                //#if Debug
                                                //	printf("cfeed = %d cpx0=%d cpy0 = %d cpx = %d cpy =%d g_oxpos =%d g_oypos = %d\r\n",cfeed,g_tmpoxpos + mult1*g_dxpos,g_tmpoypos + mult1*g_dypos,cpx,cpy,g_oxpos,g_oypos);
                                                //#endif
                                            }
                                            else
                                            {
                                                Comm_Move(g_oxpos, g_oypos, 80, MENU_CURSOR, 1, 1);
                                            }
                                        }

                                        if (f == 1)
                                        { //成功
                                            Bor_CreatBack((U16 *)&g_Ctsavetimes, addr1, g_Ctendaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);
                                            g_maxX = g_patd.patmX;
                                            g_minX = g_patd.patiX;
                                            g_maxY = g_patd.patmY;
                                            g_minY = g_patd.patiY;
                                        }
                                        g_dxpos = 0;
                                        g_dypos = 0;
                                        g_ct_status_flag = 0;
                                        g_feedsum = g_patd.feed_sum;
                                        g_feedc = g_patd.feed_sum;
                                        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                                    }
                                    else
                                    {
                                        if (f == 3)
                                        {
                                            Bor_CreatUnDO(addr1, g_Ctendaddr, (U32 *)&g_CtPatLen);
                                            g_Ctstaddr = ctBackSaddr;
                                            g_Ctendaddr = ctBackEaddr;
                                            g_oxpos = g_tmpoxpos + mult1 * g_dxpos;
                                            g_oypos = g_tmpoypos + mult1 * g_dypos;
                                        }
                                        pno = MENU_INHELP;
                                        hleppara = 2;
                                        poldno[2] = MENU_CURSOR;
                                        pnoindex = 3;
                                    }
                                    g_disxpos = g_oxpos;
                                    g_disypos = g_oypos;
                                    g_pf_dis = 0;
                                }
                                else if (g_input_method == 3)
                                { //折线
                                    //										g_isBAT = 0;	//清除跳缝标志
                                    if ((g_dxpos != 0) || (g_dypos != 0))
                                    {
                                        g_array4[0][0]++;
                                        g_array4[g_point_num][0] = g_tmpoxpos + mult1 * g_dxpos; //记录控制点的绝对坐标
                                        g_array4[g_point_num][1] = g_tmpoypos + mult1 * g_dypos;
                                        g_array5[g_point_num][0] = g_dxpos; //记录控制点相对坐标
                                        g_array5[g_point_num][1] = g_dypos;
                                        g_oxpos = g_tmpoxpos + mult1 * g_dxpos;
                                        g_oypos = g_tmpoypos + mult1 * g_dypos;
                                        g_tmpoxpos = g_oxpos;
                                        g_tmpoypos = g_oypos;

                                        g_dxpos = 0;
                                        g_dypos = 0;
                                        g_point_num++;
                                        // DrawFillRect(416, 36, 24, 16, mCOLOR ? Color_Silver : Color_White);
                                        // DrawFS32P(416, 36, g_point_num, 3, 0, Color_Black);
                                        DrawFillRect(rect[RECT_CURSOR_P_STR].xpis, rect[RECT_CURSOR_P_STR].ypis,
                                                     rect[RECT_CURSOR_P_STR].xsize, rect[RECT_CURSOR_P_STR].ysize, rect[RECT_CURSOR_P_STR].colorB[0]);
                                        DrawFS32P(rect[RECT_CURSOR_P_STR].xpis + SAFE_DIST4, rect[RECT_CURSOR_P_STR].ypis + SAFE_DIST4,
                                                  g_point_num, 3, 0, rect[RECT_CURSOR_P_STR].colorT[0]);
                                        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                                    }
                                    else
                                    {
                                        pno = MENU_INHELP;
                                        hleppara = 1;
                                        poldno[2] = MENU_CURSOR;
                                        pnoindex = 3;
                                    }
                                }
                                else if ((g_input_method == 4) || (g_input_method == 5))
                                { //圆、圆弧
                                    //										g_isBAT = 0;	//清除跳缝标志
                                    if ((g_point_num == 1) && ((g_dxpos != 0) || (g_dypos != 0)))
                                    {
                                        g_array4[0][0]++;
                                        g_array4[g_point_num][0] = g_tmpoxpos + mult1 * g_dxpos;
                                        g_array4[g_point_num][1] = g_tmpoypos + mult1 * g_dypos;
                                        g_array5[g_point_num][0] = g_dxpos;
                                        g_array5[g_point_num][1] = g_dypos;
                                        g_oxpos = g_tmpoxpos + mult1 * g_dxpos;
                                        g_oypos = g_tmpoypos + mult1 * g_dypos;
                                        g_tmpoxpos = g_oxpos;
                                        g_tmpoypos = g_oypos;
                                        g_dxpos = 0;
                                        g_dypos = 0;
                                        g_point_num++;
                                        // DrawFillRect(416, 36, 24, 16, mCOLOR ? Color_Silver : Color_White);
                                        // DrawFS32P(416, 36, g_point_num, 3, 0, Color_Black);
                                        DrawFillRect(rect[RECT_CURSOR_P_STR].xpis, rect[RECT_CURSOR_P_STR].ypis,
                                                     rect[RECT_CURSOR_P_STR].xsize, rect[RECT_CURSOR_P_STR].ysize, rect[RECT_CURSOR_P_STR].colorB[0]);
                                        DrawFS32P(rect[RECT_CURSOR_P_STR].xpis + SAFE_DIST4, rect[RECT_CURSOR_P_STR].ypis + SAFE_DIST4,
                                                  g_point_num, 3, 0, rect[RECT_CURSOR_P_STR].colorT[0]);
                                        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                                    }
                                    else
                                    {
                                        g_array4[0][0]++;
                                        g_oxpos = g_tmpoxpos + mult1 * g_dxpos;
                                        g_oypos = g_tmpoypos + mult1 * g_dypos;
                                        g_array4[g_point_num][0] = g_oxpos;
                                        g_array4[g_point_num][1] = g_oypos;
                                        g_array5[g_point_num][0] = g_dxpos;
                                        g_array5[g_point_num][1] = g_dypos;
                                        pno = MENU_INHELP;
                                        hleppara = 1;
                                        poldno[2] = MENU_CURSOR;
                                        pnoindex = 3;
                                    }
                                }
                                else if (g_input_method == 6)
                                { //曲线
                                    //										g_isBAT = 0;	//清除跳缝标志
                                    if (((g_dxpos == 0) && (g_dypos == 0)) || (g_point_num > SPLINESUM_MAX))
                                    {
                                        pno = MENU_INHELP;
                                        hleppara = 1;
                                        poldno[2] = MENU_CURSOR;
                                        pnoindex = 3;
                                    }
                                    else
                                    {
                                        g_array4[0][0]++;
                                        g_oxpos = g_tmpoxpos + mult1 * g_dxpos;
                                        g_oypos = g_tmpoypos + mult1 * g_dypos;
                                        g_array4[g_point_num][0] = g_oxpos;
                                        g_array4[g_point_num][1] = g_oypos;
                                        g_array5[g_point_num][0] = g_dxpos;
                                        g_array5[g_point_num][1] = g_dypos;
                                        g_tmpoxpos = g_oxpos;
                                        g_tmpoypos = g_oypos;
                                        g_dxpos = 0;
                                        g_dypos = 0;
                                        g_point_num++;
                                        // DrawFillRect(416, 36, 24, 16, mCOLOR ? Color_Silver : Color_White);
                                        // DrawFS32P(416, 36, g_point_num, 3, 0, Color_Black);
                                        DrawFillRect(rect[RECT_CURSOR_P_STR].xpis, rect[RECT_CURSOR_P_STR].ypis,
                                                     rect[RECT_CURSOR_P_STR].xsize, rect[RECT_CURSOR_P_STR].ysize, rect[RECT_CURSOR_P_STR].colorB[0]);
                                        DrawFS32P(rect[RECT_CURSOR_P_STR].xpis + SAFE_DIST4, rect[RECT_CURSOR_P_STR].ypis + SAFE_DIST4,
                                                  g_point_num, 3, 0, rect[RECT_CURSOR_P_STR].colorT[0]);
                                        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                                    }
                                }
                            }
                        }

                        dis_updata = 1;
                        dis_updataP = 1;
                        scale = pat_getScale(patRule.h_patConvasIndex, patRulesTmp);
                        vscale = pat_getFinalScale(scale, scale1);
                        //xo = ORG_X;
                        //yo = ORG_Y;
                        //scale1 = 0;
                        vflag = 0;
                        tonear = 0;
                        otonear = tonear;
                        BmpFillRect(keyd[KEY_CURSOR_TOP].xpis, keyd[KEY_CURSOR_TOP].ypis,
                                    keyd[KEY_CURSOR_TOP].xsize, keyd[KEY_CURSOR_TOP].ysize);
                        BmpFillRect(keyd[KEY_CURSOR_INSERT].xpis, keyd[KEY_CURSOR_INSERT].ypis,
                                    keyd[KEY_CURSOR_INSERT].xsize, keyd[KEY_CURSOR_INSERT].ysize);
                        break;
                    case KEY_CURSOR_FEED:
                        g_ct_status_flag = 0;
                        if (g_feed_flag)
                        { // 空送
                            g_feed_flag = 0;
                            g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
                        }
                        else
                        { // 缝纫
                            g_feed_flag = 1;
                        }

                        if (g_ct_insert_flag)
                        {
                            g_ct_status_flag |= (bit6 | bit8);
                        }
                        if (g_ct_insert_flag == 2)
                        {
                            g_ct_status_flag |= (bit12 | bit13);
                        }
                        dis_updata = 1;
                        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                        break;

                    case KEY_CURSOR_METHOD:
                        pno = MENU_METHOD;
                        poldno[2] = MENU_CURSOR;
                        pnoindex = 3;
                        break;
                    case KEY_CURSOR_PFOOT:
                        Send_Pfoot(0, MENU_CURSOR, 0);
                        break;
                    case KEY_CURSOR_HOME:

                        Write_Cmd(C_PFOOTACTION, g_pfootd.base, 0); //将中压脚高度设置为基准值
                        f = Read_Status();
                        old_PfootOffVal = g_pfootd.base;
                        temp_PfVal = g_pfootd.base;
                        g_jog_point = g_feedc;
                        g_BorSTflag = stflag;
                        g_ExCode = 0;
                        g_curExCode = 0;
                        g_pointPinAng = 0;
                        g_pointSetPara1 = 0;
                        g_pointSetPara2 = 0;
                        g_cttohome = 1;
                        f = Go_Home(MENU_CURSOR, 1); //0
                        if (f == 0)
                        {
                            g_needtohome = 1;
                            g_feedc = g_jog_point;
                            break;
                        }

                        isHome = (U8)(S_HOME) | (U8)(S_NEWHOME);
                        if ((isHome & 0x02) || (isHome & 0x04))
                        {
                            //	Beep_On(2000);
                        }
                        else
                        {                     //没有回到机械原点位置
                            g_needtohome = 1; //寸动前需要回一次原点
                            break;
                        }
                        g_needtohome = 0;
                        g_cttohome = 0;
                        Up = 0;
                        Dn = 0;
                        EnUPflag = 1;

                        if (g_feedc)
                        {
                            g_feedc = 0;
                            dis_updata2 = 1;
                        }

                        if (g_GreatPatType == 1)
                        { //三菱
                            if (g_feedc < g_feedsum)
                            {
                                g_ct_status_flag = 0x7cfdf;
                                g_ct_status_flag |= bit19;
                                dis_updata = 1;

                                dat1 = g_pat_p - g_feedsum - g_feedsum;
                                dat = SREG[dat1] & 0x00ff;
                                if ((dat == 0x61) || (dat == 0x41) || (dat == 0x21) || (dat == 0x1) || (dat == 0x1b) || (dat == 0x3))
                                {
                                    dat = SREG[dat1 + 1];
                                    x = dat & 0x000000ff;
                                    y = ((U32)(dat >> 8)) & 0x000000ff;
                                    if (x >= 0x80)
                                    {
                                        x -= 0x80;
                                        g_dxpos = -x;
                                        g_temp_oxpos = 0;
                                    }
                                    else
                                    {
                                        g_dxpos = x;
                                        g_temp_oxpos = 0;
                                    }
                                    if (y >= 0x80)
                                    {
                                        y -= 0x80;
                                        g_dypos = -y;
                                        g_temp_oypos = 0;
                                    }
                                    else
                                    {
                                        g_dypos = y;
                                        g_temp_oypos = 0;
                                    }
                                    dat = SREG[dat1];
                                }
                                else
                                {
                                    g_dxpos = 0;
                                    g_dypos = 0;
                                    dat = SREG[dat1];
                                }
                                dis_data(dat, 0);
                                dismove = 1;
                            }
                        }
                        else if (g_GreatPatType == 2)
                        { //兄弟
                            if ((g_feedc < g_feedsum) || (g_patd.orgX != 0) || (g_patd.orgY != 0))
                            {
                                if ((stflag) || (g_patd.orgX != 0) || (g_patd.orgY != 0))
                                { //不在机械原点位置
                                    dis_updata2 = 1;
                                }
                                //#if Debug
                                //printf("g_feedsum = %d \r\n",g_feedsum);
                                //#endif
                                stflag = 0; //在机械原点
                                g_BorSTflag = stflag;
                                g_ct_status_flag = 0x7cfdf;
                                g_ct_status_flag |= bit19;

                                g_dxpos = g_patd.orgX;
                                g_dypos = g_patd.orgY;
                                //								g_pf_absval = g_pfootd.base;
                                g_pf_absdis = 0;
                                g_speed = 0x60;
                                dis_data(0, 1);
                                dismove = 1;

                                dis_updata = 1;
                            }
                        }
                        vposx = 0;
                        vposy = 0;
                        tonear = 0;
                        otonear = tonear;
                        getNearflag = 2;
                        // BmpFillRect(234, 449, 80, 64);
                        BmpFillRect(keyd[KEY_CURSOR_TOP].xpis, keyd[KEY_CURSOR_TOP].ypis,
                                    keyd[KEY_CURSOR_TOP].xsize, keyd[KEY_CURSOR_TOP].ysize);
                        // BmpFillRect(keyd[KEY_CURSOR_INSERT].xpis, keyd[KEY_CURSOR_INSERT].ypis,
                        //             keyd[KEY_CURSOR_INSERT].xsize, keyd[KEY_CURSOR_INSERT].ysize);
                        //dxorg =0;
                        //dyorg =0;
                        //scale1 = 0;

                        break;

                    case KEY_CURSOR_OFFSET:
                        pno = MENU_MULTI;
                        poldno[2] = MENU_CURSOR;
                        pnoindex = 3;
                        break;
                    case KEY_CURSOR_NEEDLE:
                        Write_Cmd1(C_NEEDLEUP, 0, 0);
                        break;
                    case KEY_CURSOR_RETURN: //取消上一个输入点
                        if (g_GreatPatType == 1)
                        {
                            if (g_line_sum)
                            {
                                dat = Mit_Analyse_Data(1, &n); // 返回要删除的那一段绘图数据的起始地址
                                if (dat)
                                {
                                    for (ii = 0; ii < n; ii++)
                                    {
                                        dat4 = SREG[g_pat_p - 2 * (n - ii)] & 0x00ff;
                                        if ((dat4 == 0x61) || (dat4 == 0x41) || (dat4 == 0x21) || (dat4 == 0x01))
                                        {
                                            if ((SREG[g_pat_p - 2 * (n - ii)] & 0xff00) != 0)
                                            {
                                                g_pf_dis = (S8)(SREG[g_pat_p - 2 * (n - ii)] >> 8);
                                                break;
                                            }
                                        }
                                    }
                                    if (g_pf_dis != 0)
                                    {
                                        if (S_PFOOT)
                                        {
                                            if (g_pf_dis < 0)
                                            {
                                                f = Write_Cmd(C_PFEMOV, 1, (-g_pf_dis));
                                            }
                                            else
                                            {
                                                f = Write_Cmd(C_PFEMOV, 2, g_pf_dis);
                                            }
                                            for (i = 0; i < RDTIMES; i++)
                                            {
                                                Read_D(D_Address[DISP] + D_CMDSTATUS, 1, (U16 *)(&DREG[D_CMDSTATUS])); // 读状态
                                                if ((DREG[D_CMDSTATUS]) == 100)
                                                    break;
                                                DelayMs(WAITTIME);
                                            }
                                        }
                                        else
                                        {
                                            f = Read_D(D_Address[SYS] + SYS_PFOOTNOW, 1, (U16 *)(&YREG[SYS_PFOOTNOW]));
                                            //读当前中压脚修正量
                                            if (f == 0)
                                            {
                                                pno = MENU_RWHELP;
                                                hleppara = 15;
                                                poldno[2] = MENU_CURSOR;
                                                pnoindex = 3;
                                                return;
                                            }
                                            f = Write_Cmd(C_PFOOTACTION, YREG[SYS_PFOOTNOW] - g_pf_dis, 0);
                                            for (i = 0; i < RDTIMES; i++)
                                            {
                                                Read_D(D_Address[DISP] + D_CMDSTATUS, 1, (U16 *)(&DREG[D_CMDSTATUS])); // 读状态
                                                if ((DREG[D_CMDSTATUS]) == 100)
                                                    break;
                                                DelayMs(WAITTIME);
                                            }
                                        }
                                        g_pf_dis = 0;
                                    }
                                    if (SREG[dat] == 0x601)
                                        g_home_2flag = 0;
                                    if (SREG[dat] == 0x3a01)
                                    {
                                        g_lineforceValSetNow = g_lineforceValSetNow - (S8)(SREG[dat + 1]);
                                    }
                                    for (ii = dat; ii < MAXSREG; ii++)
                                        SREG[ii] = 0;
                                    g_reorigin = 0;
                                    AnaPattern(0, PAT_MIT, 0);
                                    Mit_CreateAllData();
                                    g_feedc = g_line_p - (SREG[2] + 0x40) / 2;
                                    g_feedsum = g_feedc;
                                    dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                                    g_feed_sew = 0; // 空送标志

                                    g_ct_status_flag = 0;
                                    if (g_feed_flag == 0)
                                    { // 空送
                                        g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
                                    }
                                    else
                                    { // 缝纫
                                    }
                                    dis_updata = 1;

                                    if (g_feedc)
                                    {
                                        for (ii = 1; ii <= g_feedc; ii++)
                                        {
                                            dat1 = SREG[g_pat_p - ii * 2] & 0x00ff;
                                            if ((dat1 == 0x1) || (dat1 == 0x21) || (dat1 == 0x41) || (dat1 == 0x61))
                                            {
                                                g_feed_sew = 1; // 缝纫标志
                                                break;
                                            }
                                            else if ((dat1 == 0x3) || (dat1 == 0x1b))
                                            {
                                                break;
                                            }
                                        }
                                    }
                                    g_tExCode = 0;
                                    if (g_feedc)
                                    {
                                        for (ii = 1; ii <= g_feedc; ii++)
                                        {
                                            if (SREG[g_pat_p - ii * 2] == 0x05)
                                            { //功能1
                                                g_tExCode ^= 0x01;
                                            }
                                            else if (SREG[g_pat_p - ii * 2] == 0x0b)
                                            { //功能2
                                                g_tExCode ^= 0x02;
                                            }
                                            else if (SREG[g_pat_p - ii * 2] == 0x0c)
                                            { //功能3
                                                g_tExCode ^= 0x04;
                                            }
                                            else if (SREG[g_pat_p - ii * 2] == 0x0d)
                                            { //功能4
                                                g_tExCode ^= 0x08;
                                            }
                                            else if (SREG[g_pat_p - ii * 2] == 0x001d)
                                            { //功能5
                                                g_tExCode ^= 0x10;
                                            }
                                            else if (SREG[g_pat_p - ii * 2] == 0x011d)
                                            { //功能6
                                                g_tExCode ^= 0x20;
                                            }
                                            else if (SREG[g_pat_p - ii * 2] == 0x021d)
                                            { //功能7
                                                g_tExCode ^= 0x40;
                                            }
                                            else if (SREG[g_pat_p - ii * 2] == 0x031d)
                                            { //功能8
                                                g_tExCode ^= 0x80;
                                            }
                                        }
                                    }
                                    excode = g_ExCode ^ g_tExCode;
                                    if (excode != 0)
                                    {
                                        OutputExcode(excode, MENU_CURSOR);
                                    }
                                    g_pointPinAng = mit_getExCodeData(52000, 52000 + g_feedc * 2, 0);
                                    g_pointSetPara1 = mit_getExCodeData(52000, 52000 + g_feedc * 2, 1);
                                    g_pointSetPara2 = mit_getExCodeData(52000, 52000 + g_feedc * 2, 2);

                                    sendExCodeCmd();
                                    if (1)
                                    {
                                        Send_Pfoot(1, MENU_CURSOR, 1); //PfootUp(MENU_CURSOR);
                                        f = Comm_Move(g_oxpos, g_oypos, 120, MENU_CURSOR, 0, 0);
                                        if (f == 0)
                                        {
                                            break;
                                        }
                                    }
                                }
                                g_disxpos = g_oxpos;
                                g_disypos = g_oypos;
                                g_pf_absval = Mit_CailPadOffestPF(g_jog_enpoint, 1, 1);
                                g_pf_absval += g_pfootd.base;
                                g_updata_pf_valflg = 1;
                                dis_updataP = 1;
                                //dxorg =0;
                                //dyorg =0;
                                //scale1 = 0;
                            }
                            else
                            {
                                pno = MENU_INHELP;
                                hleppara = 3;
                                poldno[2] = MENU_CURSOR;
                                pnoindex = 3;
                            }
                        }
                        else if (g_GreatPatType == 2)
                        {
                            if ((g_feedsum > 0) || (g_Ctsavetimes > 1))
                            {
                                //									g_isBAT = 0;	//清除跳缝标志
                                Bor_CreatDelData((U16 *)&g_Ctsavetimes, (U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, (S16 *)&g_oxpos, (S16 *)&g_oypos, (U8 *)&g_speed, (S16 *)&g_pf_absval, (S8 *)&g_pf_dis, (U8 *)&g_lineforceValSetNow, (S16 *)&g_patd.orgX, (S16 *)&g_patd.orgY, (U32 *)&g_CtPatLen);
                                g_pf_absval += g_pfootd.base;

                                Write_Cmd(C_PFOOTACTION, g_pf_absval, 0); //将中压脚高度设置为追后一针的高度
                                Read_Status();

                                g_pf_dis = 0;
                                Send_Pfoot(1, MENU_CURSOR, 1); //PfootUp(MENU_CURSOR);
                                f = Comm_Move(g_oxpos, g_oypos, 80, MENU_CURSOR, 1, 1);
                                //printf("g_oxpos = %d , g_oypos = %d \r\n",g_oxpos,g_oypos);
                                g_disxpos = g_oxpos;
                                g_disypos = g_oypos;
                                g_dxpos = 0;
                                g_dypos = 0;

                                g_feedsum = g_patd.feed_sum;
                                g_feedc = g_patd.feed_sum;

                                g_feed_flag = 1;
                                g_ct_status_flag = 0;
                                if (g_feed_flag == 0)
                                { // 空送
                                    g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
                                }
                                else
                                { // 缝纫
                                }
                                dis_updata = 1;
                                dis_updataP = 1;
                                //dxorg =0;
                                //dyorg =0;
                                //scale1 = 0;
                                dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);

                                Bor_feedInfo(g_feedsum, g_CtPatLen, &Borcmd, &tmpxdat1, &tmpydat1, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &Borpooft, &Borpfdis);
                                if (g_oldspeed == 0)
                                    g_oldspeed = 0x60;
                                else if (g_oldspeed == 1)
                                    g_oldspeed = 0x40;
                                else if (g_oldspeed == 2)
                                    g_oldspeed = 0x20;
                                else
                                    g_oldspeed = 0x0;

                                g_dxpos = 0;
                                g_dypos = 0;
                                excode = g_ExCode ^ g_tExCode;

                                if (excode != 0)
                                {
                                    OutputExcode(excode, MENU_CURSOR);
                                }
                                sendExCodeCmd();
                            }
                            else
                            {
                                pno = MENU_INHELP;
                                hleppara = 3;
                                poldno[2] = MENU_CURSOR;
                                pnoindex = 3;
                            }
                        }
                        //xo = ORG_X;
                        //yo = ORG_Y;
                        //scale1 = 0;
                        vflag = 0;
                        tonear = 0;
                        otonear = tonear;
                        // BmpFillRect(234, 449, 80, 64);
                        BmpFillRect(keyd[KEY_CURSOR_TOP].xpis, keyd[KEY_CURSOR_TOP].ypis,
                                    keyd[KEY_CURSOR_TOP].xsize, keyd[KEY_CURSOR_TOP].ysize);
                        BmpFillRect(keyd[KEY_CURSOR_INSERT].xpis, keyd[KEY_CURSOR_INSERT].ypis,
                                    keyd[KEY_CURSOR_INSERT].xsize, keyd[KEY_CURSOR_INSERT].ysize);
                        Wait_Move_End(); //等待平台移动结束
                        //printf("-88- pno = %d \r\n",pno);
                        break;

                    case KEY_CURSOR_ZIG:
                        pno = MENU_ZIGZAG;
                        poldno[2] = MENU_CURSOR;
                        pnoindex = 3;
                        break;
                    case KEY_CURSOR_CODE:
                        g_dxpos1 = 0;
                        g_dypos1 = 0;
                        if (g_GreatPatType == 1)
                        { //三菱
                            if (g_feedsum > 0)
                            {
                                dat1 = 52000 + (g_feedsum - 1) * 2;
                                dat = SREG[dat1] & 0x00ff;
                                if ((dat == 0x61) || (dat == 0x41) || (dat == 0x21) || (dat == 0x1) || (dat == 0x1b) || (dat == 0x3))
                                {
                                    dat = SREG[dat1 + 1];
                                    x = (U8)(dat);
                                    y = (U8)((U16)(dat >> 8));
                                    if (x >= 0x80)
                                    {
                                        x -= 0x80;
                                        g_dxpos1 = -x;
                                    }
                                    else
                                    {
                                        g_dxpos1 = x;
                                    }
                                    if (y >= 0x80)
                                    {
                                        y -= 0x80;
                                        g_dypos1 = -y;
                                    }
                                    else
                                    {
                                        g_dypos1 = y;
                                    }
                                }
                            }
                        }
                        else if (g_GreatPatType == 2)
                        { //兄弟
                            Bor_feedInfo(g_feedsum, g_CtPatLen, &Borcmd, &tmpxdat1, &tmpydat1, (S16 *)&g_dxpos1, (S16 *)&g_dypos1, (U8 *)&g_oldspeed, &Borpooft, &Borpfdis);
                            if (g_oldspeed == 0)
                                g_oldspeed = 0x60;
                            else if (g_oldspeed == 1)
                                g_oldspeed = 0x40;
                            else if (g_oldspeed == 2)
                                g_oldspeed = 0x20;
                            else
                                g_oldspeed = 0x0;
                        }
                        g_exType = 0;
                        pno = MENU_CODE;
                        poldno[2] = MENU_CURSOR;
                        pnoindex = 3;
                        break;
                    case KEY_CURSOR_CANCEL:
                        // BmpFillRect(234, 449, 80, 64);
                        BmpFillRect(keyd[KEY_CURSOR_TOP].xpis, keyd[KEY_CURSOR_TOP].ypis,
                                    keyd[KEY_CURSOR_TOP].xsize, keyd[KEY_CURSOR_TOP].ysize);
                        BmpFillRect(keyd[KEY_CURSOR_INSERT].xpis, keyd[KEY_CURSOR_INSERT].ypis,
                                    keyd[KEY_CURSOR_INSERT].xsize, keyd[KEY_CURSOR_INSERT].ysize);

                        if (g_GreatPatType == 1)
                        { //三菱
                            if (g_point_num > 1)
                            {
                                if ((g_dxpos == 0) && (g_dypos == 0))
                                {
                                    g_dxpos = (S16)(SREG[g_draw_p - 2]);
                                    g_dypos = (S16)(SREG[g_draw_p - 1]);
                                    if (g_num_mov_key)
                                    {
                                        f = Comm_Move(g_tmpoxpos - g_dxpos, g_tmpoypos - g_dypos, 80, MENU_CURSOR, 0, 0);
                                        if (f == 0)
                                        {
                                            break;
                                        }
                                        g_tmpoxpos = g_tmpoxpos - g_dxpos;
                                        g_tmpoypos = g_tmpoypos - g_dypos;
                                    }
                                    else
                                    {
                                        g_tmpoxpos = g_tmpoxpos - g_dxpos;
                                        g_tmpoypos = g_tmpoypos - g_dypos;
                                    }
                                    g_draw_p -= 4;
                                    SREG[g_draw_p] = 0;
                                    SREG[g_draw_p + 1] = 0;
                                    SREG[g_draw_p + 2] = 0;
                                    SREG[g_draw_p + 3] = 0;
                                    g_point_num--;
                                    g_array4[0][0]--;
                                    // DrawFillRect(416, 36, 24, 16, mCOLOR ? Color_Silver : Color_White);
                                    // DrawFS32P(416, 36, g_point_num, 3, 0, Color_Black);
                                    DrawFillRect(rect[RECT_CURSOR_P_STR].xpis, rect[RECT_CURSOR_P_STR].ypis,
                                                 rect[RECT_CURSOR_P_STR].xsize, rect[RECT_CURSOR_P_STR].ysize, rect[RECT_CURSOR_P_STR].colorB[0]);
                                    DrawFS32P(rect[RECT_CURSOR_P_STR].xpis + SAFE_DIST4, rect[RECT_CURSOR_P_STR].ypis + SAFE_DIST4,
                                              g_point_num, 3, 0, rect[RECT_CURSOR_P_STR].colorT[0]);
                                    dis_updataP = 1;
                                    //dxorg =0;
                                    //dyorg =0;
                                    //scale1 = 0;
                                    if ((g_point_num == 1) && (g_dxpos == 0) && (g_dypos == 0))
                                    {
                                        dis_updata = 1;
                                        g_ct_status_flag = 0;
                                        if (!g_feed_flag)
                                        {
                                            g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
                                        }
                                    }
                                }
                                else
                                {
                                    if (g_num_mov_key == 0)
                                    {
                                        f = Comm_Move(g_tmpoxpos, g_tmpoypos, 80, MENU_CURSOR, 0, 0);
                                        if (f == 0)
                                        {
                                            break;
                                        }
                                    }
                                    g_dxpos = 0;
                                    g_dypos = 0;
                                    dis_updataP = 1;
                                    //dxorg =0;
                                    //dyorg =0;
                                    //scale1 = 0;
                                }
                            }
                            else
                            {
                                if ((g_num_mov_key == 0) && ((g_dxpos != 0) || (g_dypos != 0)))
                                {
                                    f = Comm_Move(g_tmpoxpos, g_tmpoypos, 80, MENU_CURSOR, 0, 0);
                                    if (f == 0)
                                    {
                                        break;
                                    }
                                    g_disxpos = g_tmpoxpos;
                                    g_disypos = g_tmpoypos;
                                }
                                g_dxpos = 0;
                                g_dypos = 0;

                                dis_updataP = 1;
                                //dxorg =0;
                                //dyorg =0;
                                //scale1 = 0;
                                dis_updata = 1;
                                g_ct_status_flag = 0;
                                if (!g_feed_flag)
                                {
                                    g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
                                }
                                if (g_ct_insert_flag)
                                {
                                    g_ct_status_flag |= (bit8) | (bit6) | (bit12) | (bit13);
                                    ct_insert_flag = g_ct_insert_flag;
                                    // DrawButton2(keyd7[0], Color_White1, keybmpind7[0], 1);
                                    BmpFillRect(keyd[KEY_CURSOR_INSERT].xpis, keyd[KEY_CURSOR_INSERT].ypis,
                                                keyd[KEY_CURSOR_INSERT].xsize, keyd[KEY_CURSOR_INSERT].ysize);
                                    DrawButton(keyd[KEY_CURSOR_INSERT], (U16 *)(ADD_ICONBMP),
                                               keybmpind[KEY_CURSOR_INSERT].border[0], keybmpind[KEY_CURSOR_INSERT].icon[0]);
                                }
                                if ((g_pf_mode) && (g_point_num == 1))
                                {
                                    if (S_PFOOT)
                                    {
                                        if (g_pf_dis < 0)
                                        {
                                            g_pf_absval += g_pf_dis;
                                            f = Write_Cmd(C_PFEMOV, 1, abs(g_pf_dis));
                                        }
                                        else
                                        {
                                            g_pf_absval -= g_pf_dis;
                                            f = Write_Cmd(C_PFEMOV, 2, g_pf_dis);
                                        }
                                        for (i = 0; i < RDTIMES; i++)
                                        {
                                            Read_D(D_Address[DISP] + D_CMDSTATUS, 1, (U16 *)(&DREG[D_CMDSTATUS])); // 读状态
                                            if ((DREG[D_CMDSTATUS]) == 100)
                                                break;
                                            DelayMs(WAITTIME);
                                        }
                                    }
                                    else
                                    {
                                        f = Read_D(D_Address[SYS] + SYS_PFOOTNOW, 1, (U16 *)(&YREG[SYS_PFOOTNOW]));
                                        //读当前中压脚修正量
                                        if (f == 0)
                                        {
                                            pno = MENU_RWHELP;
                                            hleppara = 15;
                                            poldno[2] = MENU_CURSOR;
                                            pnoindex = 3;
                                            return;
                                        }
                                        f = Write_Cmd(C_PFOOTACTION, YREG[SYS_PFOOTNOW] - g_pf_dis, 0);
                                        for (i = 0; i < RDTIMES; i++)
                                        {
                                            Read_D(D_Address[DISP] + D_CMDSTATUS, 1, (U16 *)(&DREG[D_CMDSTATUS])); // 读状态
                                            if ((DREG[D_CMDSTATUS]) == 100)
                                                break;
                                            DelayMs(WAITTIME);
                                        }
                                    }
                                    g_pf_mode = 0;
                                    g_pf_dis = 0;
                                    g_updata_pf_valflg = 1;
                                }
                            }
                        }
                        else if (g_GreatPatType == 2)
                        { //兄弟
                            if (g_point_num > 1)
                            {
                                if ((g_dxpos == 0) && (g_dypos == 0))
                                {
                                    //									Comm_RelationMove(2*xpos,2*ypos,MENU_CURSOR,1);
                                    g_point_num--;
                                    g_array4[0][0]--;
                                    g_oxpos = (S16)g_array4[g_point_num][0];
                                    g_oypos = (S16)g_array4[g_point_num][1];
                                    g_dxpos = (S16)g_array5[g_point_num][0];
                                    g_dypos = (S16)g_array5[g_point_num][1];
                                    //printf("g_oxpos = %d  g_oypos = %d  g_dxpos = %d g_dypos = %d \r\n",g_oxpos,g_oypos,g_dxpos,g_dypos);
                                    if (g_num_mov_key)
                                    {
                                        Comm_Move(g_oxpos - mult1 * g_dxpos, g_oypos - mult1 * g_dypos, 80, MENU_CURSOR, 1, 1);
                                        g_oxpos = g_tmpoxpos - mult1 * g_dxpos;
                                        g_oypos = g_tmpoypos - mult1 * g_dypos;
                                        g_tmpoxpos = g_oxpos;
                                        g_tmpoypos = g_oypos;
                                        g_disxpos = g_tmpoxpos + mult1 * g_dxpos;
                                        g_disypos = g_tmpoypos + mult1 * g_dypos;
                                    }
                                    else
                                    {
                                        g_tmpoxpos = g_oxpos - mult1 * g_dxpos;
                                        g_tmpoypos = g_oypos - mult1 * g_dypos;
                                    }

                                    // DrawFillRect(416, 36, 24, 16, mCOLOR ? Color_Silver : Color_White);
                                    // DrawFS32P(416, 36, g_point_num, 3, 0, Color_Black);
                                    DrawFillRect(rect[RECT_CURSOR_P_STR].xpis, rect[RECT_CURSOR_P_STR].ypis,
                                                 rect[RECT_CURSOR_P_STR].xsize, rect[RECT_CURSOR_P_STR].ysize, rect[RECT_CURSOR_P_STR].colorB[0]);
                                    DrawFS32P(rect[RECT_CURSOR_P_STR].xpis + SAFE_DIST4, rect[RECT_CURSOR_P_STR].ypis + SAFE_DIST4,
                                              g_point_num, 3, 0, rect[RECT_CURSOR_P_STR].colorT[0]);
                                    dis_updataP = 1;
                                    //dxorg =0;
                                    //dyorg =0;
                                    //scale1 = 0;
                                    if ((g_point_num == 1) && (g_dxpos == 0) && (g_dypos == 0))
                                    {
                                        dis_updata = 1;
                                        g_ct_status_flag = 0;
                                        if (!g_feed_flag)
                                        {
                                            g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
                                        }
                                    }
                                }
                                else
                                {
                                    g_dxpos = 0;
                                    g_dypos = 0;
                                    if (g_num_mov_key == 0)
                                    {
                                        Comm_Move(g_tmpoxpos + mult1 * g_dxpos, g_tmpoypos + mult1 * g_dypos, 80, MENU_CURSOR, 1, 1);
                                        g_oxpos = g_tmpoxpos + mult1 * g_dxpos;
                                        g_oypos = g_tmpoypos + mult1 * g_dypos;

                                        g_disxpos = g_tmpoxpos;
                                        g_disypos = g_tmpoypos;
                                    }
                                    else
                                    {
                                        g_disxpos = g_tmpoxpos;
                                        g_disypos = g_tmpoypos;
                                    }
                                    dis_updataP = 1;
                                    //dxorg =0;
                                    //dyorg =0;
                                    //scale1 = 0;
                                    //dxorg =0;
                                    //dyorg =0;
                                    //scale1 = 0;
                                }
                            }
                            else
                            {
                                if ((g_num_mov_key == 0) && ((g_dxpos != 0) || (g_dypos != 0)))
                                {
                                    f = Comm_Move(g_tmpoxpos, g_tmpoypos, 80, MENU_CURSOR, 1, 0);
                                    if (f == 0)
                                    {
                                        break;
                                    }
                                    g_oxpos = g_tmpoxpos;
                                    g_oypos = g_tmpoypos;
                                }
                                datxy = 0;
                                g_disxpos = g_oxpos;
                                g_disypos = g_oypos;
                                g_dxpos = 0;
                                g_dypos = 0;
                                dis_updata = 1;
                                dis_updataP = 1;
                                //dxorg =0;
                                //dyorg =0;
                                //scale1 = 0;
                                g_ct_status_flag = 0;
                                if (!g_feed_flag)
                                {
                                    g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
                                }
                                if (g_ct_insert_flag)
                                {
                                    g_ct_status_flag |= (bit8) | (bit6) | (bit12) | (bit13);
                                    ct_insert_flag = g_ct_insert_flag;
                                    // DrawButton2(keyd7[0], Color_White1, keybmpind7[0], 1);
                                    BmpFillRect(keyd[KEY_CURSOR_INSERT].xpis, keyd[KEY_CURSOR_INSERT].ypis,
                                                keyd[KEY_CURSOR_INSERT].xsize, keyd[KEY_CURSOR_INSERT].ysize);
                                    DrawButton(keyd[KEY_CURSOR_INSERT], (U16 *)(ADD_ICONBMP),
                                               keybmpind[KEY_CURSOR_INSERT].border[0], keybmpind[KEY_CURSOR_INSERT].icon[0]);
                                }
                                //array4[0][0]--;

                                if ((g_pf_mode) && (g_point_num == 1))
                                {
                                    if (S_PFOOT)
                                    {
                                        if (g_pf_dis < 0)
                                        {
                                            g_pf_absval += g_pf_dis;
                                            f = Write_Cmd(C_PFEMOV, 1, abs(g_pf_dis));
                                        }
                                        else
                                        {
                                            g_pf_absval -= g_pf_dis;
                                            f = Write_Cmd(C_PFEMOV, 2, g_pf_dis);
                                        }
                                        for (i = 0; i < RDTIMES; i++)
                                        {
                                            Read_D(D_Address[DISP] + D_CMDSTATUS, 1, (U16 *)(&DREG[D_CMDSTATUS])); // 读状态
                                            if ((DREG[D_CMDSTATUS]) == 100)
                                                break;
                                            DelayMs(WAITTIME);
                                        }
                                    }
                                    else
                                    {
                                        f = Read_D(D_Address[SYS] + SYS_PFOOTNOW, 1, (U16 *)(&YREG[SYS_PFOOTNOW]));
                                        //读当前中压脚修正量
                                        if (f == 0)
                                        {
                                            pno = MENU_RWHELP;
                                            hleppara = 15;
                                            poldno[2] = MENU_CURSOR;
                                            pnoindex = 3;
                                            return;
                                        }
                                        f = Write_Cmd(C_PFOOTACTION, YREG[SYS_PFOOTNOW] - g_pf_dis, 0);
                                        for (i = 0; i < RDTIMES; i++)
                                        {
                                            Read_D(D_Address[DISP] + D_CMDSTATUS, 1, (U16 *)(&DREG[D_CMDSTATUS])); // 读状态
                                            if ((DREG[D_CMDSTATUS]) == 100)
                                                break;
                                            DelayMs(WAITTIME);
                                        }
                                    }
                                    g_pf_mode = 0;
                                    g_pf_dis = 0;
                                    g_updata_pf_valflg = 1;
                                }
                            }
                        }
                        tonear = 0;
                        otonear = tonear;
                        getNearflag = 2;

                        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                        Wait_Move_End(); //等待平台移动结束
                        break;

                    case KEY_CURSOR_TACKING:
                        pno = MENU_TACKING;
                        poldno[2] = MENU_CURSOR;
                        pnoindex = 3;
                        break;

                    case KEY_CURSOR_SPEED:
                        g_speed = g_speed + 0x20;
                        if ((g_speed != 0x20) && (g_speed != 0x40) && (g_speed != 0x60))
                            g_speed = 0;
                        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                        break;

                    case KEY_CURSOR_MUP:

                        if ((!(S_CLAMP)) && (P_OST == 0))
                        {
                            pno = MENU_RWHELP;
                            hleppara = 13;
                            poldno[2] = MENU_CURSOR;
                            pnoindex = 3;
                            break;
                        }
                        tonear = 0;
                        getNearflag = 2;
                        if (g_GreatPatType == 1)
                        {
                            if (g_feedc < g_feedsum)
                            {
                                //								dat1 = g_pat_p - (g_feedsum - g_feedc) * 2;
                                dat1 = 52000 + g_feedc * 2;
                                if ((g_feedc < g_feedsum) && (uplock == 1))
                                {
                                    dat = SREG[dat1] & 0x00ff;
                                    if ((dat == 0x61) || (dat == 0x41) || (dat == 0x21) || (dat == 0x1))
                                    {
                                        if (((SREG[dat1] & 0xff00) != 0))
                                        {
                                            pfootval = Mit_CailPadOffestPF(g_feedc, 0, 0); //计算jog_point之前的中压脚高度变化量
                                            temp_PfVal = PfootOffVal + pfootval + (S8)(SREG[dat1] >> 8);
                                            if (tmp_pfoot == 0)
                                            {
                                                pfootval = 0;
                                            }
                                            else
                                            {
                                                pfootval = (S8)(SREG[dat1] >> 8);
                                            }
                                        }
                                        Up = 1;
                                        Dn = 0;
                                    }
                                    else if ((dat == 0x1b) || (dat == 0x03))
                                    { // 空送
                                        Up = 0;
                                        Dn = 1;
                                        if (tmp_pfoot)
                                        {
                                            Send_Pfoot(1, MENU_CURSOR, 1); // 压脚升
                                            i = 0;
                                            while ((tmp_pfoot) && (i < 5))
                                            {
                                                Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                                if (tmp_pfoot != (U8)(S_PFOOT))
                                                {
                                                    tmp_pfoot = S_PFOOT;
                                                }
                                                i++;
                                                DelayMs(200);
                                            }

                                            break;
                                        }
                                    }
                                    uplock = 0;
                                }
                                if (((SREG[dat1] & 0x00ff) == 0x1) || ((SREG[dat1] & 0x00ff) == 0x21) || ((SREG[dat1] & 0x00ff) == 0x41) || ((SREG[dat1] & 0x00ff) == 0x61))
                                { //缝纫
                                    if (Dn == 1)
                                    {
                                        Send_Pfoot(2, MENU_CURSOR, 1); //压脚降
                                        Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                        tmp_pfoot = 0xff;
                                        Up = 1;
                                        Dn = 0;
                                    }
                                    if (old_PfootOffVal != temp_PfVal)
                                    {
                                        old_PfootOffVal = temp_PfVal;

                                        if (pfootval > 0)
                                            f = Write_Cmd(C_PFEMOV, 1, pfootval);
                                        else
                                            f = Write_Cmd(C_PFEMOV, 2, (-pfootval));

                                        for (i = 0; i < RDTIMES; i++)
                                        {
                                            Read_D(D_Address[DISP] + D_CMDSTATUS, 1, (U16 *)(&DREG[D_CMDSTATUS])); // 读状态
                                            if ((DREG[D_CMDSTATUS]) == 100)
                                                break;
                                            DelayMs(WAITTIME);
                                        }
                                    }
                                }
                                else if ((Up == 1) && (((SREG[dat1] & 0x00ff) == 0x03) || ((SREG[dat1] & 0x00ff) == 0x1b)))
                                { //空送
                                    Up = 0;
                                    Dn = 1;
                                    if (tmp_pfoot)
                                    {
                                        Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                        i = 0;
                                        while ((tmp_pfoot) && (i < 5))
                                        {
                                            Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                            if (tmp_pfoot != (U8)(S_PFOOT))
                                            {
                                                tmp_pfoot = S_PFOOT;
                                            }
                                            i++;
                                            DelayMs(200);
                                        }
                                        break;
                                    }
                                }
                                else if (((SREG[dat1] & 0x00ff) == 0x07))
                                {                    //跳缝
                                    Wait_Move_End(); //等待平台移动结束
                                    if (Up == 1)
                                    { //压脚在下面,压脚升
                                        Up = 0;
                                        Dn = 1;
                                        Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                        Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                        tmp_pfoot = 0xff;
                                    }
                                    else
                                    {                                  //压脚在上面,将压脚放下再抬起来
                                        Send_Pfoot(2, MENU_CURSOR, 1); //压脚降
                                        Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                        Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                        Up = 0;
                                        Dn = 1;
                                        tmp_pfoot = 0xff;
                                    }
                                }

                                dat = SREG[dat1] & 0x00ff;
                                if ((dat == 0x61) || (dat == 0x41) || (dat == 0x21) || (dat == 0x1) || (dat == 0x1b) || (dat == 0x3))
                                {
                                    if ((SREG[dat1 + 2] & 0xff00) != 0)
                                    {
                                        if (tmp_pfoot == 0)
                                        {
                                            pfootval = Mit_CailPadOffestPF(g_feedc, 0, 0); //计算jog_point之前的中压脚高度变化量
                                            temp_PfVal = PfootOffVal + pfootval + (S8)(SREG[dat1 + 2] >> 8);
                                        }
                                        else
                                        {
                                            pfootval = (S8)(SREG[dat1 + 2] >> 8);
                                            temp_PfVal += pfootval;
                                        }
                                    }

                                    dat = SREG[dat1 + 1];
                                    x = dat & 0x000000ff;
                                    y = ((U32)(dat >> 8)) & 0x000000ff;
                                    if (x >= 0x80)
                                    {
                                        x -= 0x80;
                                        g_dxpos = -x;
                                        g_temp_oxpos -= (S16)(x);
                                    }
                                    else
                                    {
                                        g_dxpos = x;
                                        g_temp_oxpos += (S16)(x);
                                    }
                                    if (y >= 0x80)
                                    {
                                        y -= 0x80;
                                        g_dypos = -y;
                                        g_temp_oypos -= (S16)(y);
                                    }
                                    else
                                    {
                                        g_dypos = y;
                                        g_temp_oypos += (S16)(y);
                                    }

                                    f = Comm_RelationMove(g_dxpos, g_dypos, MENU_CURSOR, 0, 0);
                                    if (f == 0)
                                    {
                                        break;
                                    }
                                }
                                else
                                {
                                    if ((dat == 0x05) || (dat == 0x0b) || (dat == 0x0c) || (dat == 0x0d) || (dat == 0x1d))
                                    { //附加功能
                                        excode = 0;
                                        if (dat == 0x05)
                                            excode = 0x01;
                                        else if (dat == 0x0b)
                                            excode = 0x02;
                                        else if (dat == 0x0c)
                                            excode = 0x04;
                                        else if (dat == 0x0d)
                                            excode = 0x08;
                                        else
                                        {
                                            excode = (SREG[dat1] & 0xff00) >> 8;
                                            if (excode > 3)
                                                excode = 0;
                                            excode = (1 << (excode + 4));
                                        }
                                        if (excode != 0)
                                        {
                                            OutputExcode1(excode, MENU_CURSOR, 0);
                                        }
                                    }
                                    else if (dat == 0x3c)
                                    {
                                        g_pointPinAng = (SREG[dat1] & 0xff00) >> 8;
                                    }
                                    else if (dat == 0x3d)
                                    {
                                        g_pointSetPara1 = (SREG[dat1] & 0xff00) >> 8;
                                    }
                                    else if (dat == 0x3e)
                                    {
                                        g_pointSetPara2 = (SREG[dat1] & 0xff00) >> 8;
                                    }
                                    sendExCodeCmd();
                                    g_dxpos = 0;
                                    g_dypos = 0;
                                }
                                if (dat == 0x3a)
                                { // 面线张力指令，计算当前面线张力
                                    lforceval = Mit_CailPadOffestLF(g_feedc, 0);
                                    g_lineforceValSetNow = g_lineforceValSet + lforceval + (S8)(SREG[dat1 + 1]);
                                }

                                g_feedc++;
                                getFeedPos(g_feedc, F_FILETYPE, &fpx, &fpy);
                                // g_oxpos = fpx; //修改BUG
                                // g_oypos = fpy;
                                vposx = fpx;
                                vposy = fpy;
                                RecoveData2();

                                vscale = pat_getFinalScale(scale, scale1);
                                posx1 = (S32)(fpx * (vscale) / 1000 + xorg);
                                posy1 = (S32)(tmuly * fpy * (vscale) / 1000 + yorg);
                                if (posx1 <= patV.xpis || posx1 >= (patV.xpis + patV.xsize) ||
                                    posy1 <= patV.ypis || posy1 >= (patV.ypis + patV.ysize))
                                { //针点超出显示范围
                                    xorg = ORG_X;
                                    yorg = ORG_Y;
                                    xorg += (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                    yorg += tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                    xo = xorg + (xorg - (S32)((vposx)*vscale / 1000 + xorg));
                                    yo = yorg + (yorg - (S32)(tmuly * (vposy)*vscale / 1000 + yorg));

                                    xorg = xo - (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                    yorg = yo - tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                    // DrawFillRect(patV.xpis, patV.ypis, patV.xsize, patV.ysize, keybmpind[KEY_CURSOR_IMG].icon[0]);
                                    // newDrawPat(g_feedc == g_feedsum ? 19 : 18, scale1, xo, yo, 0, 0);
                                    patRulesTmp = (g_feedc == g_feedsum) ? PATRULES_CREATE1 : PATRULES_CREATE3;
                                    pat_setPatRule(patRulesTmp);
                                    pat_clearConvas(patRule.h_patConvasIndex);
                                    pat_drawPattern(patRulesTmp, scale1, xo, yo, F_FILETYPE, F_FILELEN, 0, 0, NULL);
                                }
                                else
                                {
                                    ReadPointData2(posx1 - 4, posy1 - 4);
                                    Draw_SmallCrossLimit(posx1, posy1, COLOR_CROSS, patRule.h_patConvasIndex);
                                }
                                //newDrawPoint(4,g_feedc,0,0,0,0);

                                //------2017-12-6增加  显示下一针增量
                                dat = SREG[dat1 + 2] & 0x00ff;
                                if ((dat == 0x61) || (dat == 0x41) || (dat == 0x21) || (dat == 0x1) || (dat == 0x1b) || (dat == 0x3))
                                {
                                    dat = SREG[dat1 + 3];
                                    x = (U8)(dat);
                                    y = (U8)((U16)(dat >> 8));
                                    if (x >= 0x80)
                                    {
                                        x -= 0x80;
                                        g_dxpos = -x;
                                    }
                                    else
                                    {
                                        g_dxpos = x;
                                    }
                                    if (y >= 0x80)
                                    {
                                        y -= 0x80;
                                        g_dypos = -y;
                                    }
                                    else
                                    {
                                        g_dypos = y;
                                    }
                                }
                                else
                                {
                                    g_dxpos = 0;
                                    g_dypos = 0;
                                }
                                //-------------------------------
                                dat = SREG[dat1 + 2];

                                dis_data(dat, 0);

                                if (g_feedc == g_feedsum)
                                {
                                    g_ct_status_flag = 0;
                                    dismove = 0;
                                    if (!g_feed_flag)
                                    {
                                        g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
                                    }
                                    g_dxpos = 0;
                                    g_dypos = 0;
                                    g_temp_pno = 0xffffffff;
                                    dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                                    dis_updata = 1;
                                    dis_updata1 = 1;
                                    dis_updataP = 1;
                                    dis_pattern = 0;
                                    g_cttohome = 0;
                                    Write_Cmd(C_PFOOTACTION, g_pf_absval, 0); //将中压脚高度设置为追后一针的高度
                                    Read_Status();

                                    g_ct_insert_flag = 0;
                                    if (ct_insert_flag)
                                    {
                                        BmpFillRect(keyd[KEY_CURSOR_INSERT].xpis, keyd[KEY_CURSOR_INSERT].ypis,
                                                    keyd[KEY_CURSOR_INSERT].xsize, keyd[KEY_CURSOR_INSERT].ysize);
                                        ct_insert_flag = 0;
                                    }
                                }
                            }
                            g_updata_pf_valflg = 1;
                        }
                        else if (g_GreatPatType == 2)
                        {
                            if (g_feedc < g_feedsum)
                            {
                                if (stflag == 0)
                                { //在机械原点位置
                                    if (Up == 1)
                                    {
                                        Up = 0;
                                        Dn = 1;
                                        EnUPflag = 1;
                                        Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                        tmp_pfoot = 0xff;
                                    }
                                    tmpxdat1 = g_patd.orgX;
                                    tmpydat1 = g_patd.orgY;
                                    g_ExCode = 0;
                                    g_curExCode = 0;
                                    g_pointPinAng = 0;
                                    g_pointSetPara1 = 0;
                                    g_pointSetPara2 = 0;
                                    if (GoHome == 0)
                                    {                                                             //XY同时移动
                                        Comm_RelationMove(tmpxdat1, tmpydat1, MENU_CURSOR, 1, 1); //移动到次原点位置
                                    }
                                    else if (GoHome == 1)
                                    { //X先回原点,Y后回原点
                                        //先移动Y,后移动X
                                        Comm_RelationMove(0, tmpydat1, MENU_CURSOR, 1, 1);
                                        Wait_Move_End(); //等待平台移动结束
                                        Comm_RelationMove(tmpxdat1, 0, MENU_CURSOR, 1, 1);
                                    }
                                    else
                                    {
                                        //先移动x,后移动y
                                        Comm_RelationMove(tmpxdat1, 0, MENU_CURSOR, 1, 1);
                                        Wait_Move_End(); //等待平台移动结束
                                        Comm_RelationMove(0, tmpydat1, MENU_CURSOR, 1, 1);
                                    }
                                    if (g_patd.orgX != 0 || g_patd.orgY != 0)
                                    { //次原点
                                        stflag = 1;
                                        g_BorSTflag = stflag;
                                        g_dxpos = 0;
                                        g_dypos = 0;
                                        dis_data(0x06, 1);
                                    }
                                    else
                                    {
                                        stflag = 2;
                                        g_BorSTflag = stflag;
                                        Bor_feedInfo(g_feedc + 1, g_CtPatLen, &Borcmd, &tmpxdat1, &tmpydat1, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &Borpooft, &Borpfdis); //查找当前原花样结束点坐标
                                        Borpooft += g_pfootd.base;
                                        g_pf_bdis = Borpfdis;
                                        //										g_pf_absval = Borpooft;
                                        dat = cmdAny(Borcmd);
                                        dis_data(dat, 1);
                                    }
                                    getFeedPos(g_feedc, F_FILETYPE, &fpx, &fpy);
                                    vposx = fpx;
                                    vposy = fpy;
                                    RecoveData2();

                                    vscale = pat_getFinalScale(scale, scale1);
                                    posx1 = (S32)(fpx * (vscale) / 1000 + xorg);
                                    posy1 = (S32)(mult2 * tmuly * fpy * (vscale) / 1000 + yorg);
                                    if (posx1 <= patV.xpis || posx1 >= (patV.xpis + patV.xsize) ||
                                        posy1 <= patV.ypis || posy1 >= (patV.ypis + patV.ysize))
                                    { //针点超出显示范围
                                        xorg = ORG_X;
                                        yorg = ORG_Y;
                                        xorg += (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                        yorg += tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                        xo = xorg + (xorg - (S32)((vposx)*vscale / 1000 + xorg));
                                        yo = yorg + (yorg - (S32)(mult2 * tmuly * (vposy)*vscale / 1000 + yorg));

                                        xorg = xo - (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                        yorg = yo - tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                        // DrawFillRect(patV.xpis, patV.ypis, patV.xsize, patV.ysize, keybmpind[KEY_CURSOR_IMG].icon[0]);
                                        // newDrawPat(g_feedc == g_feedsum ? 19 : 18, scale1, xo, yo, 0, 0);
                                        patRulesTmp = (g_feedc == g_feedsum) ? PATRULES_CREATE1 : PATRULES_CREATE3;
                                        pat_setPatRule(patRulesTmp);
                                        pat_clearConvas(patRule.h_patConvasIndex);
                                        pat_drawPattern(patRulesTmp, scale1, xo, yo, F_FILETYPE, F_FILELEN, 0, 0, NULL);
                                    }
                                    else
                                    {
                                        ReadPointData2(posx1 - 4, posy1 - 4);
                                        Draw_SmallCrossLimit(posx1, posy1, COLOR_CROSS, patRule.h_patConvasIndex);
                                    }
                                }
                                else if (stflag == 1)
                                { //查找显示下一针数据指令
                                    stflag = 2;
                                    g_BorSTflag = stflag;
                                    Bor_feedInfo(g_feedc + 1, g_CtPatLen, &Borcmd, &tmpxdat1, &tmpydat1, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &Borpooft, &Borpfdis); //查找当前原花样结束点坐标
                                    Borpooft += g_pfootd.base;
                                    g_pf_bdis = Borpfdis;
                                    //									g_pf_absval = Borpooft;

                                    dat = cmdAny(Borcmd);
                                    dis_data(dat, 1);
                                    getFeedPos(g_feedc, F_FILETYPE, &fpx, &fpy);
                                    vposx = fpx;
                                    vposy = fpy;
                                    RecoveData2();
                                    posx1 = (S32)(fpx * (vscale) / 1000 + xorg);
                                    posy1 = (S32)(mult2 * tmuly * fpy * (vscale) / 1000 + yorg);
                                    if (posx1 <= patV.xpis || posx1 >= (patV.xpis + patV.xsize) ||
                                        posy1 <= patV.ypis || posy1 >= (patV.ypis + patV.ysize))
                                    { //针点超出显示范围
                                        xorg = ORG_X;
                                        yorg = ORG_Y;
                                        xorg += (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                        yorg += tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                        xo = xorg + (xorg - (S32)((vposx)*vscale / 1000 + xorg));
                                        yo = yorg + (yorg - (S32)(mult2 * tmuly * (vposy)*vscale / 1000 + yorg));

                                        xorg = xo - (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                        yorg = yo - tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                        // DrawFillRect(patV.xpis, patV.ypis, patV.xsize, patV.ysize, keybmpind[KEY_CURSOR_IMG].icon[0]);
                                        // newDrawPat(g_feedc == g_feedsum ? 19 : 18, scale1, xo, yo, 0, 0);
                                        patRulesTmp = (g_feedc == g_feedsum) ? PATRULES_CREATE1 : PATRULES_CREATE3;
                                        pat_setPatRule(patRulesTmp);
                                        pat_clearConvas(patRule.h_patConvasIndex);
                                        pat_drawPattern(patRulesTmp, scale1, xo, yo, F_FILETYPE, F_FILELEN, 0, 0, NULL);
                                    }
                                    else
                                    {
                                        ReadPointData2(posx1 - 4, posy1 - 4);
                                        Draw_SmallCrossLimit(posx1, posy1, COLOR_CROSS, patRule.h_patConvasIndex);
                                    }
                                }
                                else
                                {
                                    Bor_feedInfo(g_feedc + 1, g_CtPatLen, &Borcmd, &tmpxdat1, &tmpydat1, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &Borpooft, &Borpfdis); //查找当前原花样结束点坐标
                                    Borpooft += g_pfootd.base;
                                    g_pf_bdis = Borpfdis;
                                    //									g_pf_absval = Borpooft;
                                    if (Borpooft > PF_ABS_MAX)
                                        Borpooft = PF_ABS_MAX;
                                    if (Borpooft < PF_ABS_MIN)
                                        Borpooft = PF_ABS_MIN;
                                    if (((Borcmd & 0xf000) == 0x2000) || (Borcmd == 0xfd00))
                                    { //空送,剪线
                                        EnUPflag = 1;
                                        Wait_Move_End(); //等待平台移动结束
                                        if (Up == 1)
                                        {
                                            Up = 0;
                                            Dn = 1;
                                            Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                            Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                            tmp_pfoot = 0xff;
                                            if ((Borcmd & 0xf000) == 0x2000)
                                            {
                                                break;
                                            }
                                        }
                                        if ((Borcmd & 0xf000) == 0x2000)
                                        {
                                            movfeed = 1;
                                        }
                                    }
                                    else if ((Borcmd & 0xf000) == 0x6000)
                                    { //缝纫
                                        if ((Dn == 1) && (EnUPflag == 1))
                                        {
                                            Up = 1;
                                            Dn = 0;
                                            Wait_Move_End();               //等待平台移动结束
                                            Send_Pfoot(2, MENU_CURSOR, 1); //压脚降
                                            Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                            tmp_pfoot = 0xff;
                                            break;
                                        }
                                        EnUPflag = 0;
                                    }
                                    else if ((Borcmd & 0xff00) == 0xf000)
                                    {                    //中压脚调整
                                        Wait_Move_End(); //等待平台移动结束
                                        if (Dn == 1)
                                        {
                                            Up = 1;
                                            Dn = 0;
                                            Send_Pfoot(2, MENU_CURSOR, 1); //压脚降
                                            Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                            tmp_pfoot = 0xff;
                                            break;
                                        }
                                        if (g_pf_bdis > 0)
                                        { //中压脚上升
                                            f = Write_Cmd(C_PFEMOV, 1, g_pf_bdis);
                                        }
                                        else if (g_pf_bdis < 0)
                                        { //中压脚下降
                                            f = Write_Cmd(C_PFEMOV, 2, -g_pf_bdis);
                                        }
                                    }
                                    else if ((Borcmd & 0xff00) == 0xf400)
                                    {                    //跳缝
                                        Wait_Move_End(); //等待平台移动结束
                                        if (Up == 1)
                                        { //压脚在下面,压脚升
                                            Up = 0;
                                            Dn = 1;
                                            Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                            Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                            tmp_pfoot = 0xff;
                                        }
                                        else
                                        {                                  //压脚在上面,将压脚放下再抬起来
                                            Send_Pfoot(2, MENU_CURSOR, 1); //压脚降
                                            Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                            Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                            Up = 0;
                                            Dn = 1;
                                            tmp_pfoot = 0xff;
                                        }
                                    }
                                    else if ((Borcmd & 0xff00) == 0xfc00)
                                    { //附加功能
                                        excode = Borcmd & 0xff;
                                        if (excode != 0)
                                        {
                                            OutputExcode1(excode, MENU_CURSOR, 0);
                                        }
                                    }
                                    sendExCodeCmd();
                                    Comm_RelationMove(g_dxpos, g_dypos, MENU_CURSOR, 1, movfeed);
                                    //Comm_Move(tmpxdat1+g_dxpos,tmpydat1+g_dypos,movfeed?80:50,MENU_CURSOR,1,movfeed);
                                    g_feedc++;

                                    getFeedPos(g_feedc, F_FILETYPE, &fpx, &fpy);
                                    vposx = fpx;
                                    vposy = fpy;
                                    RecoveData2();
                                    posx1 = (S32)(fpx * (vscale) / 1000 + xorg);
                                    posy1 = (S32)(mult2 * tmuly * fpy * (vscale) / 1000 + yorg);
                                    if (posx1 <= patV.xpis || posx1 >= (patV.xpis + patV.xsize) ||
                                        posy1 <= patV.ypis || posy1 >= (patV.ypis + patV.ysize))
                                    { //针点超出显示范围
                                        xorg = ORG_X;
                                        yorg = ORG_Y;
                                        xorg += (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                        yorg += tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                        xo = xorg + (xorg - (S32)((vposx)*vscale / 1000 + xorg));
                                        yo = yorg + (yorg - (S32)(mult2 * tmuly * (vposy)*vscale / 1000 + yorg));

                                        xorg = xo - (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                        yorg = yo - tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                        // DrawFillRect(patV.xpis, patV.ypis, patV.xsize, patV.ysize, keybmpind[KEY_CURSOR_IMG].icon[0]);
                                        // newDrawPat(g_feedc == g_feedsum ? 19 : 18, scale1, xo, yo, 0, 0);
                                        patRulesTmp = (g_feedc == g_feedsum) ? PATRULES_CREATE1 : PATRULES_CREATE3;
                                        pat_setPatRule(patRulesTmp);
                                        pat_clearConvas(patRule.h_patConvasIndex);
                                        pat_drawPattern(patRulesTmp, scale1, xo, yo, F_FILETYPE, F_FILELEN, 0, 0, NULL);
                                    }
                                    else
                                    {
                                        ReadPointData2(posx1 - 4, posy1 - 4);
                                        Draw_SmallCrossLimit(posx1, posy1, COLOR_CROSS, patRule.h_patConvasIndex);
                                    }

                                    movfeed = 0;
                                    Bor_feedInfo(g_feedc + 1, g_CtPatLen, &Borcmd, &tmpxdat1, &tmpydat1, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &Borpooft, &Borpfdis); //查找当前原花样结束点坐标
                                    Borpooft += g_pfootd.base;
                                    g_pf_bdis = Borpfdis;
                                    //									g_pf_absval = Borpooft;
                                    dat = cmdAny(Borcmd);
                                    dis_data(dat, 1);
                                    if (g_feedc == g_feedsum)
                                    {
                                        dis_updataP = 1;
                                        g_dxpos = 0;
                                        g_dypos = 0;
                                    }
                                }
                                g_updata_pf_valflg = 1;
                            }
                            else
                            {
                                if (stflag == 0)
                                { //在机械原点位置
                                    g_ExCode = 0;
                                    g_curExCode = 0;
                                    g_pointPinAng = 0;
                                    g_pointSetPara1 = 0;
                                    g_pointSetPara2 = 0;
                                    if (Up == 1)
                                    {
                                        Up = 0;
                                        Dn = 1;
                                        EnUPflag = 1;
                                        Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                        tmp_pfoot = 0xff;
                                    }
                                    tmpxdat1 = g_patd.orgX;
                                    tmpydat1 = g_patd.orgY;

                                    if (GoHome == 0)
                                    {                                                             //XY同时移动
                                        Comm_RelationMove(tmpxdat1, tmpydat1, MENU_CURSOR, 1, 1); //移动到次原点位置
                                    }
                                    else if (GoHome == 1)
                                    { //X先回原点,Y后回原点
                                        //先移动Y,后移动X
                                        Comm_RelationMove(0, tmpydat1, MENU_CURSOR, 1, 1);
                                        Wait_Move_End(); //等待平台移动结束
                                        Comm_RelationMove(tmpxdat1, 0, MENU_CURSOR, 1, 1);
                                    }
                                    else
                                    {
                                        //先移动x,后移动y
                                        Comm_RelationMove(tmpxdat1, 0, MENU_CURSOR, 1, 1);
                                        Wait_Move_End(); //等待平台移动结束
                                        Comm_RelationMove(0, tmpydat1, MENU_CURSOR, 1, 1);
                                    }
                                    stflag = 1;
                                    g_BorSTflag = stflag;
                                    getFeedPos(g_feedc, F_FILETYPE, &fpx, &fpy);
                                    vposx = fpx;
                                    vposy = fpy;
                                    RecoveData2();
                                    posx1 = (S32)(fpx * (vscale) / 1000 + xorg);
                                    posy1 = (S32)(mult2 * tmuly * fpy * (vscale) / 1000 + yorg);
                                    if (posx1 <= patV.xpis || posx1 >= (patV.xpis + patV.xsize) ||
                                        posy1 <= patV.ypis || posy1 >= (patV.ypis + patV.ysize))
                                    { //针点超出显示范围
                                        xorg = ORG_X;
                                        yorg = ORG_Y;
                                        xorg += (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                        yorg += tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                        xo = xorg + (xorg - (S32)((vposx)*vscale / 1000 + xorg));
                                        yo = yorg + (yorg - (S32)(mult2 * tmuly * (vposy)*vscale / 1000 + yorg));

                                        xorg = xo - (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                        yorg = yo - tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                        // DrawFillRect(patV.xpis, patV.ypis, patV.xsize, patV.ysize, keybmpind[KEY_CURSOR_IMG].icon[0]);
                                        // newDrawPat(g_feedc == g_feedsum ? 19 : 18, scale1, xo, yo, 0, 0);
                                        patRulesTmp = (g_feedc == g_feedsum) ? PATRULES_CREATE1 : PATRULES_CREATE3;
                                        pat_setPatRule(patRulesTmp);
                                        pat_clearConvas(patRule.h_patConvasIndex);
                                        pat_drawPattern(patRulesTmp, scale1, xo, yo, F_FILETYPE, F_FILELEN, 0, 0, NULL);
                                    }
                                    else
                                    {
                                        ReadPointData2(posx1 - 4, posy1 - 4);
                                        Draw_SmallCrossLimit(posx1, posy1, COLOR_CROSS, patRule.h_patConvasIndex);
                                    }

                                    dis_data(0x06, 1);
                                }
                            }
                            //
                        }

                        break;
                    case KEY_CURSOR_MDOWN:
                        if ((!(S_CLAMP)) && (P_OST == 0))
                        {
                            pno = MENU_RWHELP;
                            hleppara = 13;
                            poldno[2] = MENU_CURSOR;
                            pnoindex = 3;
                            break;
                        }

                        //printf("KEY_CURSOR_MDOWN \r\n");
                        if (g_GreatPatType == 1)
                        {
                            if (g_feedc > 0)
                            {
                                dat1 = 52000 + g_feedc * 2;
                                if ((Up == 1) && (Dn == 1))
                                {
                                    if (tmp_pfoot == 0)
                                    { //pfoot up
                                        Up = 0;
                                    }
                                    else
                                    {
                                        Dn = 0;
                                    }
                                }

                                dat = SREG[dat1 - 2] & 0x00ff;
                                if ((dat == 0x61) || (dat == 0x41) || (dat == 0x21) || (dat == 0x1))
                                {
                                    if ((SREG[dat1 - 2] & 0xff00) != 0)
                                    {
                                        pfootval = Mit_CailPadOffestPF(g_feedc, 0, 0); //计算jog_point之前的中压脚高度变化量
                                        temp_PfVal = PfootOffVal + pfootval - (S8)(SREG[dat1 - 2] >> 8);
                                        if (tmp_pfoot == 0)
                                        {
                                            pfootval = 0;
                                        }
                                        else
                                        {
                                            pfootval = (S8)(SREG[dat1 - 2] >> 8);
                                        }
                                    }
                                }
                                else if ((Up == 1) && ((dat == 0x1b) || (dat == 0x03)))
                                { //空送
                                    Up = 0;
                                    Dn = 1;
                                    if (tmp_pfoot)
                                    {
                                        Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                        i = 0;
                                        while ((tmp_pfoot) && (i < 5))
                                        {
                                            Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                            if (tmp_pfoot != (U8)(S_PFOOT))
                                            {
                                                tmp_pfoot = S_PFOOT;
                                            }
                                            i++;
                                            DelayMs(200);
                                        }
                                        break;
                                    }
                                }
                                else if (dat == 0x07)
                                { //跳缝
                                    EnUPflag = 1;
                                    Wait_Move_End(); //等待平台移动结束
                                    if (Up == 1)
                                    { //压脚在下面,压脚升
                                        Up = 0;
                                        Dn = 1;
                                        Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                        Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                        tmp_pfoot = 0xff;
                                    }
                                    else
                                    {                                  //压脚在上面,将压脚放下再抬起来
                                        Send_Pfoot(2, MENU_CURSOR, 1); //压脚降
                                        Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                        Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                        Up = 0;
                                        Dn = 1;
                                        tmp_pfoot = 0xff;
                                    }
                                }
                                if ((dat == 0x61) || (dat == 0x41) || (dat == 0x21) || (dat == 0x1) || (dat == 0x1b) || (dat == 0x03))
                                {
                                    if ((SREG[dat1 - 2] & 0xff00) == 0)
                                    {
                                        if (uplock == 0)
                                        {
                                            if (old_PfootOffVal != temp_PfVal)
                                            {
                                                temp_PfVal = old_PfootOffVal;
                                            }
                                        }
                                    }
                                }
                                if (uplock == 0)
                                {
                                    uplock = 1;
                                }
                                //if(((SREG[dat1-2]&0x00ff)==0x1)||((SREG[dat1-2]&0x00ff)==0x21)||((SREG[dat1-2]&0x00ff)==0x41)||((SREG[dat1-2]&0x00ff)==0x61)){
                                if ((dat == 0x1) || (dat == 0x21) || (dat == 0x41) || (dat == 0x61))
                                {
                                    if ((old_PfootOffVal != temp_PfVal) || (Dn == 1))
                                    {

                                        //										f = Write_Cmd(C_PFOOTACTION, temp_PfVal, 0);
                                        //										for(i=0;i<RDTIMES;i++){
                                        //											Read_D(D_Address[DISP]+D_CMDSTATUS,1,(U16 *)(&DREG[D_CMDSTATUS]));	// 读状态
                                        //											if((DREG[D_CMDSTATUS]) == 100)break;
                                        //											DelayMs(WAITTIME);
                                        //										}
                                        if (Dn == 1)
                                        {
                                            Send_Pfoot(2, MENU_CURSOR, 1); //压脚降
                                            Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                            tmp_pfoot = 0xff;
                                            Up = 1;
                                            Dn = 0;
                                            break;
                                        }

                                        if (old_PfootOffVal != temp_PfVal)
                                        {
                                            if (pfootval < 0)
                                            {
                                                f = Write_Cmd(C_PFEMOV, 1, (-pfootval));
                                            }
                                            else
                                            {
                                                f = Write_Cmd(C_PFEMOV, 2, pfootval);
                                            }
                                            for (i = 0; i < RDTIMES; i++)
                                            {
                                                Read_D(D_Address[DISP] + D_CMDSTATUS, 1, (U16 *)(&DREG[D_CMDSTATUS])); // 读状态
                                                if ((DREG[D_CMDSTATUS]) == 100)
                                                    break;
                                                DelayMs(WAITTIME);
                                            }
                                        }
                                        old_PfootOffVal = temp_PfVal;
                                    }
                                }

                                dat = SREG[dat1 - 2] & 0x00ff;
                                if ((dat == 0x61) || (dat == 0x41) || (dat == 0x21) || (dat == 0x1) || (dat == 0x1b) || (dat == 0x3))
                                {
                                    dat = SREG[dat1 - 1];
                                    x = dat & 0x000000ff;
                                    y = ((U32)(dat >> 8)) & 0x000000ff;
                                    if (x >= 0x80)
                                    {
                                        x -= 0x80;
                                        g_dxpos = x;
                                        g_temp_oxpos += (S16)(x);
                                    }
                                    else
                                    {
                                        g_dxpos = -x;
                                        g_temp_oxpos -= (S16)(x);
                                    }
                                    if (y >= 0x80)
                                    {
                                        y -= 0x80;
                                        g_dypos = y;
                                        g_temp_oypos += (S16)(y);
                                    }
                                    else
                                    {
                                        g_dypos = -y;
                                        g_temp_oypos -= (S16)(y);
                                    }
                                    dat = SREG[dat1 - 2];
                                    f = Comm_RelationMove(g_dxpos, g_dypos, MENU_CURSOR, 0, 0);
                                    if (f == 0)
                                    {
                                        break;
                                    }
                                }
                                else
                                {
                                    if ((dat == 0x05) || (dat == 0x0b) || (dat == 0x0c) || (dat == 0x0d) || (dat == 0x1d))
                                    { //附加功能
                                        excode = 0;
                                        if (dat == 0x05)
                                            excode = 0x01;
                                        else if (dat == 0x0b)
                                            excode = 0x02;
                                        else if (dat == 0x0c)
                                            excode = 0x04;
                                        else if (dat == 0x0d)
                                            excode = 0x08;
                                        else
                                        {
                                            excode = (SREG[dat1 - 2] & 0xff00) >> 8;
                                            if (excode > 3)
                                                excode = 0;
                                            excode = (1 << (excode + 4));
                                        }
                                        if (excode != 0)
                                        {
                                            OutputExcode1(excode, MENU_CURSOR, 0);
                                        }
                                    }
                                    else if (dat == 0x3c)
                                    {
                                        g_pointPinAng = mit_getExCodeData(52000, 52000 + (g_feedc > 0 ? ((g_feedc - 1) * 2) : 0), 0);
                                    }
                                    else if (dat == 0x3d)
                                    {
                                        g_pointSetPara1 = mit_getExCodeData(52000, 52000 + (g_feedc > 0 ? ((g_feedc - 1) * 2) : 0), 1);
                                    }
                                    else if (dat == 0x3e)
                                    {
                                        g_pointSetPara2 = mit_getExCodeData(52000, 52000 + (g_feedc > 0 ? ((g_feedc - 1) * 2) : 0), 2);
                                    }
                                    sendExCodeCmd();
                                    g_dxpos = 0;
                                    g_dypos = 0;
                                    dat = SREG[dat1 - 2];
                                }

                                if (dat == 0x3a)
                                { // 面线张力指令，计算当前面线张力
                                    lforceval = Mit_CailPadOffestLF(g_feedc, 0);
                                    g_lineforceValSetNow = g_lineforceValSet + lforceval - (S8)(SREG[dat1 - 1]);
                                }
                                if (g_feedc == g_feedsum)
                                {
                                    g_ct_status_flag = 0x7cfdf;
                                    g_ct_status_flag |= bit19;
                                    g_temp_oxpos = g_oxpos;
                                    g_temp_oypos = g_oypos;
                                    dis_updata = 1;
                                    dis_pattern = 1;
                                    dis_updata2 = 1;
                                    //if(g_num_mov_key==0){
                                    //#if USEMULTCOLOR	//彩色
                                    //	DrawColor_Gray1(333,449,267,267);
                                    //#else
                                    //	DrawColor_Gray1(333,449,267,267);
                                    //	FillRectColorChang(333,449,267,267,Color_White1,Color_Gray);
                                    //#endif
                                    //}else{
                                    //#if USEMULTCOLOR	//彩色
                                    //	DrawColor_Gray1(340,456,260,260);
                                    //#else
                                    //	FillRectColorChang(340,456,260,260,Color_White1,Color_Gray);
                                    //#endif
                                    //}
                                    //AnaPattern(0,g_GreatPatType,g_CtPatLen);
                                    //DrawFillRect(patV.xpis,patV.ypis,patV.xsize,patV.ysize,mCOLOR?Color_Silver:Color_White);
                                    //newDrawPat(19,scale1,xo,yo,0,0);
                                }
                                g_feedc--;
                                g_dxpos = -g_dxpos;
                                g_dypos = -g_dypos;
                                getFeedPos(g_feedc, F_FILETYPE, &fpx, &fpy);
                                // g_oxpos = fpx; //修改BUG
                                // g_oypos = fpy;
                                vposx = fpx;
                                vposy = fpy;
                                RecoveData2();

                                vscale = pat_getFinalScale(scale, scale1);
                                posx1 = (S32)(fpx * (vscale) / 1000 + xorg);
                                posy1 = (S32)(tmuly * fpy * (vscale) / 1000 + yorg);
                                if (posx1 <= patV.xpis || posx1 >= (patV.xpis + patV.xsize) ||
                                    posy1 <= patV.ypis || posy1 >= (patV.ypis + patV.ysize))
                                { //针点超出显示范围
                                    xorg = ORG_X;
                                    yorg = ORG_Y;
                                    xorg += (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                    yorg += tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                    xo = xorg + (xorg - (S32)((vposx)*vscale / 1000 + xorg));
                                    yo = yorg + (yorg - (S32)(tmuly * (vposy)*vscale / 1000 + yorg));

                                    xorg = xo - (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                    yorg = yo - tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                    // DrawFillRect(patV.xpis, patV.ypis, patV.xsize, patV.ysize, keybmpind[KEY_CURSOR_IMG].icon[0]);
                                    // newDrawPat(g_feedc == g_feedsum ? 19 : 18, scale1, xo, yo, 0, 0);
                                    patRulesTmp = (g_feedc == g_feedsum) ? PATRULES_CREATE1 : PATRULES_CREATE3;
                                    pat_setPatRule(patRulesTmp);
                                    pat_clearConvas(patRule.h_patConvasIndex);
                                    pat_drawPattern(patRulesTmp, scale1, xo, yo, F_FILETYPE, F_FILELEN, 0, 0, NULL);
                                }
                                else
                                {
                                    ReadPointData2(posx1 - 4, posy1 - 4);
                                    Draw_SmallCrossLimit(posx1, posy1, COLOR_CROSS, patRule.h_patConvasIndex);
                                }
                                dismove = 1;
                                //if(feedc==0)DrawPat(feedc,0,0);
                                dis_data(dat, 0);
                            }
                        }
                        else if (g_GreatPatType == 2)
                        {
                            if (g_feedc > 0)
                            {
                                if (g_feedc == g_feedsum)
                                {
                                    if (dismove == 0)
                                    {
                                        dismove = 1;
                                        g_ct_status_flag = 0x7cfdf;
                                        g_ct_status_flag |= bit19;
                                        dis_updata = 1;
                                        dis_updata2 = 1;
                                        EnUPflag = 1;
                                        Bor_feedInfo(g_feedc - 1, g_CtPatLen, &Borcmd, &tmpxdat1, &tmpydat1, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &Borpooft, &Borpfdis);
                                        if (Up == 1)
                                        {
                                            if (((Borcmd & 0xf000) == 0x2000) || (Borcmd == 0xfd00))
                                            {
                                                Up = 0;
                                                Dn = 1;
                                                Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                                Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                                tmp_pfoot = 0xff;
                                            }
                                        }
                                        break;
                                    }
                                    Bor_feedInfo(g_feedc, g_CtPatLen, &Borcmd, &tmpxdat1, &tmpydat1, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &Borpooft, &Borpfdis);
                                    Comm_RelationMove(-g_dxpos, -g_dypos, MENU_CURSOR, 1, movfeed);
                                    g_feedc--;
                                    stflag = 2;

                                    Bor_feedInfo(g_feedc, g_CtPatLen, &Borcmd, &tmpxdat1, &tmpydat1, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &Borpooft, &Borpfdis);
                                    sendExCodeCmd();
                                    if ((Borcmd & 0xf000) == 0x2000)
                                        movfeed = 1;
                                    Borpooft += g_pfootd.base;
                                    g_pf_bdis = Borpfdis;
                                    //									g_pf_absval = Borpooft;
                                    dat = cmdAny(Borcmd);
                                    dis_data(dat, 1);

                                    g_BorSTflag = stflag;
                                    getFeedPos(g_feedc, F_FILETYPE, &fpx, &fpy);
                                    vposx = fpx;
                                    vposy = fpy;
                                    RecoveData2();
                                    posx1 = (S32)(fpx * (vscale) / 1000 + xorg);
                                    posy1 = (S32)(mult2 * tmuly * fpy * (vscale) / 1000 + yorg);
                                    if (posx1 <= patV.xpis || posx1 >= (patV.xpis + patV.xsize) ||
                                        posy1 <= patV.ypis || posy1 >= (patV.ypis + patV.ysize))
                                    { //针点超出显示范围
                                        xorg = ORG_X;
                                        yorg = ORG_Y;
                                        xorg += (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                        yorg += tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                        xo = xorg + (xorg - (S32)((vposx)*vscale / 1000 + xorg));
                                        yo = yorg + (yorg - (S32)(mult2 * tmuly * (vposy)*vscale / 1000 + yorg));

                                        xorg = xo - (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                        yorg = yo - tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                        // DrawFillRect(patV.xpis, patV.ypis, patV.xsize, patV.ysize, keybmpind[KEY_CURSOR_IMG].icon[0]);
                                        // newDrawPat(g_feedc == g_feedsum ? 19 : 18, scale1, xo, yo, 0, 0);
                                        patRulesTmp = (g_feedc == g_feedsum) ? PATRULES_CREATE1 : PATRULES_CREATE3;
                                        pat_setPatRule(patRulesTmp);
                                        pat_clearConvas(patRule.h_patConvasIndex);
                                        pat_drawPattern(patRulesTmp, scale1, xo, yo, F_FILETYPE, F_FILELEN, 0, 0, NULL);
                                    }
                                    else
                                    {
                                        ReadPointData2(posx1 - 4, posy1 - 4);
                                        Draw_SmallCrossLimit(posx1, posy1, COLOR_CROSS, patRule.h_patConvasIndex);
                                    }

                                    //									Comm_Move(tmpxdat1+g_dxpos,tmpydat1+g_dypos,movfeed?120:80,MENU_CURSOR,1,movfeed);
                                    break;
                                }
                                Bor_feedInfo(g_feedc, g_CtPatLen, &Borcmd, &tmpxdat1, &tmpydat1, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &Borpooft, &Borpfdis);
                                Borpooft += g_pfootd.base;
                                g_pf_bdis = Borpfdis;
                                //								g_pf_absval = Borpooft;
                                //#if Debug
                                //printf("g_feedc = %d  Borcmd = %04x \r\n",g_feedc,Borcmd);
                                //#endif
                                if (((Borcmd & 0xf000) == 0x2000) || (Borcmd == 0xfd00))
                                { //空送,剪线
                                    EnUPflag = 1;
                                    Wait_Move_End(); //等待平台移动结束
                                    if (Up == 1)
                                    {
                                        Up = 0;
                                        Dn = 1;
                                        Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                        Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                        tmp_pfoot = 0xff;
                                        if ((Borcmd & 0xf000) == 0x2000)
                                        {
                                            break;
                                        }
                                    }
                                    if ((Borcmd & 0xf000) == 0x2000)
                                    {
                                        movfeed = 1;
                                    }
                                }
                                else if ((Borcmd & 0xf000) == 0x6000)
                                { //缝纫
                                    if ((Dn == 1) && (EnUPflag == 1))
                                    {
                                        Up = 1;
                                        Dn = 0;
                                        Wait_Move_End();               //等待平台移动结束
                                        Send_Pfoot(2, MENU_CURSOR, 1); //压脚降
                                        Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                        tmp_pfoot = 0xff;
                                        break;
                                    }
                                    EnUPflag = 0;
                                }
                                else if ((Borcmd & 0xff00) == 0xf000)
                                {                    //中压脚调整
                                    Wait_Move_End(); //等待平台移动结束
                                    if (Dn == 1)
                                    {
                                        Up = 1;
                                        Dn = 0;
                                        Send_Pfoot(2, MENU_CURSOR, 1); //压脚降
                                        Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                        tmp_pfoot = 0xff;
                                        break;
                                    }
                                    if (g_pf_bdis < 0)
                                    { //中压脚上升
                                        f = Write_Cmd(C_PFEMOV, 1, -g_pf_bdis);
                                    }
                                    else if (g_pf_bdis > 0)
                                    { //中压脚下降
                                        f = Write_Cmd(C_PFEMOV, 2, g_pf_bdis);
                                    }
                                }
                                else if ((Borcmd & 0xff00) == 0xf400)
                                { //跳缝
                                    EnUPflag = 1;
                                    Wait_Move_End(); //等待平台移动结束
                                    if (Up == 1)
                                    { //压脚在下面,压脚升
                                        Up = 0;
                                        Dn = 1;
                                        Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                        Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                        tmp_pfoot = 0xff;
                                    }
                                    else
                                    {                                  //压脚在上面,将压脚放下再抬起来
                                        Send_Pfoot(2, MENU_CURSOR, 1); //压脚降
                                        Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                        Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                                        Up = 0;
                                        Dn = 1;
                                        tmp_pfoot = 0xff;
                                    }
                                }
                                else if ((Borcmd & 0xff00) == 0xfc00)
                                { //附加功能
                                    excode = Borcmd & 0xff;
                                    if (excode != 0)
                                    {
                                        OutputExcode1(excode, MENU_CURSOR, 0);
                                    }
                                }
                                else if ((Borcmd & 0xff00) == 0xec00 || (Borcmd & 0xff00) == 0xea00 || (Borcmd & 0xff00) == 0xeb00)
                                { //针角度,设置一,设置二
                                    if (g_feedc)
                                        Bor_feedInfo(g_feedc - 1, g_patd.pat_len, &tBorcmd, &ttemp_oxpos1, &ttemp_oypos1, (S16 *)&tdxpos, (S16 *)&tdypos, (U8 *)&toldspeed, &tBorpooft, &tBorpfdis);
                                    else
                                    {
                                        g_pointPinAng = 0;
                                        g_pointSetPara1 = 0;
                                        g_pointSetPara2 = 0;
                                    }
                                }
                                sendExCodeCmd();
                                Comm_RelationMove(-g_dxpos, -g_dypos, MENU_CURSOR, 1, movfeed);
                                //								Comm_Move(tmpxdat1,tmpydat1,movfeed?80:50,MENU_CURSOR,1,movfeed);
                                g_feedc--;
                                getFeedPos(g_feedc, F_FILETYPE, &fpx, &fpy);
                                vposx = fpx;
                                vposy = fpy;
                                RecoveData2();
                                posx1 = (S32)(fpx * (vscale) / 1000 + xorg);
                                posy1 = (S32)(mult2 * tmuly * fpy * (vscale) / 1000 + yorg);
                                if (posx1 <= patV.xpis || posx1 >= (patV.xpis + patV.xsize) ||
                                    posy1 <= patV.ypis || posy1 >= (patV.ypis + patV.ysize))
                                { //针点超出显示范围
                                    xorg = ORG_X;
                                    yorg = ORG_Y;

                                    xorg += (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                    yorg += tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                    xo = xorg + (xorg - (S32)((vposx)*vscale / 1000 + xorg));
                                    yo = yorg + (yorg - (S32)(mult2 * tmuly * (vposy)*vscale / 1000 + yorg));

                                    xorg = xo - (g_maxX + g_minX) / 2 * (vscale) / 1000;
                                    yorg = yo - tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                                    // DrawFillRect(patV.xpis, patV.ypis, patV.xsize, patV.ysize, keybmpind[KEY_CURSOR_IMG].icon[0]);
                                    // newDrawPat(g_feedc == g_feedsum ? 19 : 18, scale1, xo, yo, 0, 0);
                                    patRulesTmp = (g_feedc == g_feedsum) ? PATRULES_CREATE1 : PATRULES_CREATE3;
                                    pat_setPatRule(patRulesTmp);
                                    pat_clearConvas(patRule.h_patConvasIndex);
                                    pat_drawPattern(patRulesTmp, scale1, xo, yo, F_FILETYPE, F_FILELEN, 0, 0, NULL);
                                }
                                else
                                {
                                    ReadPointData2(posx1 - 4, posy1 - 4);
                                    Draw_SmallCrossLimit(posx1, posy1, COLOR_CROSS, patRule.h_patConvasIndex);
                                }

                                movfeed = 0;
                                dat = cmdAny(Borcmd);
                                dis_data(dat, 1);
                            }
                        }
                        g_updata_pf_valflg = 1;

                        break;

                    case KEY_CURSOR_MMSP:
                    case KEY_CURSOR_NUMMSP:
                        dis_updata3 = 1;
                        SpeedClass++;
                        if (SpeedClass > 4)
                            SpeedClass = 1;

                        if (SpeedClass == 1)
                        {
                            g_Ptya = 1;
                        }
                        else if (SpeedClass == 2)
                        {
                            if ((P_TYA > 1) && (P_TYA < 5))
                                g_Ptya = P_TYA;
                            else
                                g_Ptya = 2;
                        }
                        else if (SpeedClass == 3)
                        {
                            if ((P_TYA > 4) && (P_TYA < 9))
                                g_Ptya = P_TYA;
                            else
                                g_Ptya = 5;
                        }
                        else
                        {
                            if ((P_TYA > 8) && (P_TYA < 16))
                                g_Ptya = P_TYA;
                            else
                                g_Ptya = 9;
                        }
                        break;

                    case KEY_CURSOR_CLR:
                        if (g_editflag)
                        {
                            g_dypos = g_dypos / 10;
                            datxy = g_dypos;
                        }
                        else
                        {
                            g_dxpos = g_dxpos / 10;
                            datxy = g_dxpos;
                        }

                        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                        if ((g_dxpos == 0) && (g_dypos == 0) && (g_point_num < 2))
                        {
                            g_ct_status_flag = 0;
                            if (!g_feed_flag)
                            {
                                g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
                            }
                            dis_updata = 1;
                        }

                        if (g_GreatPatType == 2)
                        {
                            g_disxpos = g_tmpoxpos + mult1 * g_dxpos;
                            g_disypos = g_tmpoypos + mult1 * g_dypos;
                        }
                        break;

                    case KEY_CURSOR_SIGN:
                        if (g_editflag)
                        { // +/-
                            if (g_dypos == 0)
                            {
                                if (g_signflag)
                                    g_signflag = 0;
                                else
                                    g_signflag = 1;
                            }
                            else
                                g_dypos *= (-1);
                        }
                        else
                        {
                            if (g_dxpos == 0)
                            {
                                if (g_signflag)
                                    g_signflag = 0;
                                else
                                    g_signflag = 1;
                            }
                            else
                                g_dxpos *= (-1);
                        }
                        dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                        //							if(g_signflag){
                        //								if(g_editflag){
                        //									Draw24X24FStr(74,68,"-",Color_White);
                        //								}else{
                        //									Draw24X24FStr(74,36,"-",Color_White);
                        //								}
                        //							}
                        if (g_GreatPatType == 2)
                        {
                            g_disxpos = g_tmpoxpos + mult1 * g_dxpos;
                            g_disypos = g_tmpoypos + mult1 * g_dypos;
                        }
                        break;

                    case KEY_CURSOR_XY:
                        if (g_editflag)
                            g_editflag = 0;
                        else
                            g_editflag = 1; // X/Y
                        // dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                        g_signflag = 0;
                        break;

                    case KEY_CURSOR_DX:
                        if (g_editflag)
                        {
                            g_editflag = 0;
                            // dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                            g_signflag = 0;
                        }
                        break;

                    case KEY_CURSOR_DY:
                        if (g_editflag == 0)
                        {
                            g_editflag = 1;
                            // dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                            g_signflag = 0;
                        }
                        break;

                    case KEY_CURSOR_ZOUT:
                        if (scale1)
                        {
                            scale1 -= 50;
                            if (g_ct_insert_flag == 1)
                                dis_updataP = 2;
                            else
                                dis_updataP = 1;
                        }
                        else
                        {
                            if (bResetCaonvas)
                            {
                                bResetCaonvas = 0;

                                xo = patConvas.conOrgX;
                                yo = patConvas.conOrgY;
                                scale1 = 0;
                                vflag = 0;
                                okeyxpct = keyxpct;
                                okeyypct = keyypct;

                                if (g_ct_insert_flag == 1)
                                    dis_updataP = 2;
                                else
                                    dis_updataP = 1;
                            }
                        }
                        break;

                    case KEY_CURSOR_ZIN:
                        scale1 += 50;
                        bResetCaonvas = 1;
                        if (g_ct_insert_flag == 1)
                            dis_updataP = 2;
                        else
                            dis_updataP = 1;
                        break;

                    case KEY_CURSOR_IMG:
                        if (beeponf > 1)
                        {
                            if ((absInt(keyxpct - okeyxpct) <= 10) && (absInt(keyypct - okeyypct) <= 10) && (absInt(keyxpct - stkeyxpct) <= 10) && (absInt(keyypct - stkeyypct) <= 10) && (absInt(okeyxpct - stkeyxpct) <= 10) && (absInt(okeyypct - stkeyypct) <= 10) && (beeponf == 10))
                            {
                                xo = ORG_X;
                                yo = ORG_Y;
                                scale1 = 0;
                                vflag = 0;
                                okeyxpct = keyxpct;
                                okeyypct = keyypct;
                                Beep_On(BELLT);
                            }
                            else
                            {
                                xo += (keyxpct - okeyxpct);
                                yo += (keyypct - okeyypct);
                                okeyxpct = keyxpct;
                                okeyypct = keyypct;
                                if (vflag == 1)
                                    vflag = 2;
                            }
                        }
                        else
                        {
                            okeyxpct = keyxpct;
                            okeyypct = keyypct;
                            stkeyxpct = keyxpct;
                            stkeyypct = keyypct;
                        }
                        bResetCaonvas = 1;
                        if (g_ct_insert_flag == 1)
                            dis_updataP = 2;
                        else
                            dis_updataP = 1;

                        break;

                    case KEY_CURSOR_TOP:
                        tmpxpos = g_dxpos;
                        tmpypos = g_dypos;

                        g_dxpos = (nearpx - g_tmpoxpos) / mult1;
                        g_dypos = (nearpy - g_tmpoypos) / mult1;

                        f = Comm_Move(g_tmpoxpos + mult1 * g_dxpos, g_tmpoypos + mult1 * g_dypos, 50, MENU_MODIFY1, (F_FILETYPE == PAT_MIT) ? 0 : 1, 0);

                        if (f == 0)
                        {
                            g_dxpos = tmpxpos;
                            g_dypos = tmpypos;
                        }
                        // DrawFillRect(26, 34, 50, 40, mCOLOR ? Color_Silver : Color_White);
                        // DrawFS32P(26, 36, g_dxpos, 6, 1, Color_Black);
                        // DrawFS32P(26, 56, g_dypos, 6, 1, Color_Black);
                        DrawFillRect(rect[RECT_CURSOR_X_STR].xpis, rect[RECT_CURSOR_X_STR].ypis,
                                     rect[RECT_CURSOR_X_STR].xsize, rect[RECT_CURSOR_X_STR].ysize, rect[RECT_CURSOR_X_STR].colorB[0]);
                        DrawFS32P(rect[RECT_CURSOR_X_STR].xpis + SAFE_DIST3, rect[RECT_CURSOR_X_STR].ypis + SAFE_DIST4,
                                  g_dxpos, 6, 1, rect[RECT_CURSOR_X_STR].colorT[0]);

                        DrawFillRect(rect[RECT_CURSOR_Y_STR].xpis, rect[RECT_CURSOR_Y_STR].ypis,
                                     rect[RECT_CURSOR_Y_STR].xsize, rect[RECT_CURSOR_Y_STR].ysize, rect[RECT_CURSOR_Y_STR].colorB[0]);
                        DrawFS32P(rect[RECT_CURSOR_Y_STR].xpis + SAFE_DIST3, rect[RECT_CURSOR_Y_STR].ypis + SAFE_DIST4,
                                  g_dxpos, 6, 1, rect[RECT_CURSOR_Y_STR].colorT[0]);

                        posx1 = (S32)((g_tmpoxpos + mult1 * g_dxpos) * (vscale) / 1000 + xorg);
                        posy1 = (S32)(mult2 * tmuly * (g_tmpoypos + mult1 * g_dypos) * (vscale) / 1000 + yorg);
                        if (((posx1 < patV.xpis) || (posx1 > patV.xpis + patV.xsize) || (posy1 < patV.ypis) || (posy1 > patV.ypis + patV.ysize)))
                        {
                            dis_updataP = 1;
                        }
                        else
                        {
                            RecoveData2();
                            ReadPointData2(posx1 - 4, posy1 - 4);
                            Draw_SmallCrossLimit(posx1, posy1, COLOR_CROSS, patRule.h_patConvasIndex);
                        }
                        break;

                    case KEY_CURSOR_INSERT:
                        if (g_GreatPatType == 2 && g_feedc == 0 && g_BorSTflag == 0)
                        {
                            break;
                        }
                        if (g_ct_insert_flag == 1)
                        {
                            g_ct_insert_flag = 2;
                            g_ct_status_flag = 0;
                            dismove = 0;
                            if (!g_feed_flag)
                            {
                                g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
                            }
                            g_ct_status_flag |= (bit5 | bit12 | bit13 | bit8 | bit6);
                            g_dxpos = 0;
                            g_dypos = 0;
                            g_temp_pno = 0xffffffff;
                            dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
                            dis_updata = 1;
                            dis_updata1 = 1;
                            dis_pattern = 0;

                            if (g_GreatPatType == 1)
                            {
                                mitPinmsg = mit_getPinsMsg((U16 *)SREG, 52000, g_feedc);

                                g_oxpos = mitPinmsg.posx;
                                g_oypos = mitPinmsg.posy;
                                g_inoxpos = g_oxpos;
                                g_inoypos = g_oypos;
                                g_dxpos = 0;
                                g_dypos = 0;
                            }
                            else if (g_GreatPatType == 2)
                            {
                                if (g_feedc < g_feedsum)
                                {
                                    Bor_feedInfo(g_feedc + 1, g_CtPatLen, &Borcmd, (S16 *)&g_oxpos, (S16 *)&g_oypos, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &Borpooft, &Borpfdis);
                                    if (g_oldspeed == 0)
                                        g_oldspeed = 0x60;
                                    else if (g_oldspeed == 1)
                                        g_oldspeed = 0x40;
                                    else if (g_oldspeed == 2)
                                        g_oldspeed = 0x20;
                                    else
                                        g_oldspeed = 0x0;

                                    g_inoxpos = g_oxpos;
                                    g_inoypos = g_oypos;
                                    g_dxpos = 0;
                                    g_dypos = 0;
                                }
                            }
                        }
                        else if (g_ct_insert_flag == 2)
                        {
                            g_ct_insert_flag = 1;
                            dismove = 1;
                            g_ct_status_flag = 0x7cfdf;
                            g_ct_status_flag |= bit19;
                            dis_updata = 1;
                            dis_updata2 = 1;
                        }
                        break;
                    }
                }
            }

            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            if (keyon == KEY_CURSOR_SCRNSVR || keyon == KEY_CURSOR_IMG) //不需要显示的按键
            {
            }
            else if (keyon == KEY_CURSOR_DX || keyon == KEY_CURSOR_DY) //非常规按键
            {
                DrawButtonOnZoomInRes(keyd[keyon]);
            }
            //绘制颜色文字按键
            else //常规按键
            {
                DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);
            }

            keyon = 0;
            beeponf = 0;
            pressKey = 0;
            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
            Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4,
                         MEM_TITLE_ADD + (U32)((g_num_mov_key) ? rect[0].index[1] : rect[0].index[0]) * TitleLengthMax,
                         SheetPage, (g_num_mov_key) ? rect[0].index[1] : rect[0].index[0], rect[0].colorT[0]); //显示回打板界面
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*begin]**********************************************************
        if (beeponf == 0)
        {
        }
        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*end]**********************************************************

        // /[吸附按钮功能绘制*begin]**********************************************************
        if (getNearflag && pressKey == 0)
        {
            S32 topPosX = 0, topPosY = 0; //吸附点坐标-屏幕坐标系
            if (getNearflag == 1)
            {
                tonear = getctNearPointPos(g_tmpoxpos + mult1 * g_dxpos, g_tmpoypos + mult1 * g_dypos, &nearpx, &nearpy);

                topPosX = (S32)(nearpx * (vscale) / 1000 + xorg);
                topPosY = (S32)(-nearpy * (vscale) / 1000 + yorg);
            }
            if (tonear != otonear)
            {

                if (tonear)
                {

                    // DrawButton2(keyd6[0], Color_White1, 0, 1);
                    // DrawFPBMPBTN(236, 450, 24, 24, 62, 0xffff);
                    // DrawFChar(240, 470, "X", Color_Black);
                    // DrawFChar(240, 490, "Y", Color_Black);
                    DrawButton(keyd[KEY_CURSOR_TOP], (U16 *)(ADD_ICONBMP),
                               keybmpind[KEY_CURSOR_TOP].border[0], keybmpind[KEY_CURSOR_TOP].icon[0]);
                    DrawFChar(keyd[KEY_CURSOR_TOP].xpis + SAFE_DIST4, keyd[KEY_CURSOR_TOP].ypis + SAFE_DIST9,
                              "X", keybmpind[KEY_CURSOR_TOP].textColor[0]);
                    DrawFChar(keyd[KEY_CURSOR_TOP].xpis + SAFE_DIST4, keyd[KEY_CURSOR_TOP].ypis + SAFE_DIST9 + TYPE_SIZE26,
                              "Y", keybmpind[KEY_CURSOR_TOP].textColor[0]);

                    Timer_ms1 = 0;
                    //vnear =0;
                    // onearpx = nearpx;
                    // onearpy = nearpy;

                    // nearposx = (S32)((nearpx) * (vscale) / 1000 + xorg);
                    // nearposy = (S32)(mult2 * tmuly * (nearpy) * (vscale) / 1000 + yorg);
                    //新增-绘制吸附点
                    // ReadPointData1(topPosX - 4, topPosY - 4); //新建一个读取区域
                }
                else
                {
                    BmpFillRect(keyd[KEY_CURSOR_TOP].xpis, keyd[KEY_CURSOR_TOP].ypis, keyd[KEY_CURSOR_TOP].xsize, keyd[KEY_CURSOR_TOP].ysize);
                    patRulesTmp = PATRULES_CREATE2;
                    pat_setPatRule(patRulesTmp);
                    pat_clearConvas(patRule.h_patConvasIndex);
                    pat_drawPattern(patRulesTmp, scale1, xo, yo, F_FILETYPE, F_FILELEN, 0, 0, NULL);
                    nearpx = 0;
                    nearpy = 0;
                }
                otonear = tonear;
            }
            if (tonear)
            {
                if (onearpx != nearpx || onearpy != nearpy)
                {

                    // nearposx = (S32)((nearpx) * (vscale) / 1000 + xorg);
                    // nearposy = (S32)(mult2 * tmuly * (nearpy) * (vscale) / 1000 + yorg);

                    DrawFillRect(keyd[KEY_CURSOR_TOP].xpis + SAFE_DIST4 + TYPE_SIZE1,
                                 keyd[KEY_CURSOR_TOP].ypis + SAFE_DIST4 + TYPE_SIZE4,
                                 (keyd[KEY_CURSOR_TOP].xsize - SAFE_DIST4) - (SAFE_DIST4 + TYPE_SIZE1),
                                 (keyd[KEY_CURSOR_TOP].ysize - SAFE_DIST4) - (SAFE_DIST4 + TYPE_SIZE4),
                                 keybmpind[KEY_CURSOR_TOP].textColor[1]);

                    onearpx = nearpx;
                    onearpy = nearpy;
                    //新增-绘制吸附点
                    patRulesTmp = PATRULES_CREATE2;
                    pat_setPatRule(patRulesTmp);
                    pat_clearConvas(patRule.h_patConvasIndex);
                    pat_drawPattern(patRulesTmp, scale1, xo, yo, F_FILETYPE, F_FILELEN, topPosX, topPosY, NULL);
                }
#if MOVEUNIT == 1
                if (g_curPTtype == 2)
                {
                    DrawFS32P(252, 470, nearpx / mult1 * vimut, 7, 2, Color_Black);
                    DrawFS32P(252, 490, nearpy / mult1 * vimut, 7, 2, Color_Black);
                }
                else
                {
                    DrawFS32P(260, 470, nearpx / mult1, 6, 1, Color_Black);
                    DrawFS32P(260, 490, nearpy / mult1, 6, 1, Color_Black);
                }
#else
                DrawFS32P(keyd[KEY_CURSOR_TOP].xpis + SAFE_DIST4 + TYPE_SIZE1, keyd[KEY_CURSOR_TOP].ypis + SAFE_DIST9,
                          nearpx / mult1, 5, 1, keybmpind[KEY_CURSOR_TOP].textColor[0]);
                DrawFS32P(keyd[KEY_CURSOR_TOP].xpis + SAFE_DIST4 + TYPE_SIZE1, keyd[KEY_CURSOR_TOP].ypis + SAFE_DIST9 + TYPE_SIZE26,
                          nearpy / mult1, 5, 1, keybmpind[KEY_CURSOR_TOP].textColor[0]);
#endif

                //ViewPoint(posx1,posy1,COLOR_CROSS,1);
            }

            getNearflag = 0;
        }
        // /[吸附按钮功能绘制*end]**********************************************************

        // /[中压脚设置模式？？*begin]**********************************************************
        if (g_pf_mode)
        {
            if ((g_ct_status_flag != 0x8f5f6) && (g_ct_status_flag != 0x8f7f6))
            {
                //g_ct_status_flag = 0xf5f6;
                if (g_GreatPatType == 2)
                {
                    g_ct_status_flag = 0xf5b6;
                }
                else
                {
                    g_ct_status_flag = 0xf5f6;
                }
                if (!g_feed_flag)
                    g_ct_status_flag |= bit9;
                //		status_flag |= bit19;
                dis_updata = 1;
            }
        }
        // /[中压脚设置模式？？*end]**********************************************************

        // /[当针点不在最后一针位置时，执行段插入功能提示*begin]**********************************************************
        if (dis_updata2)
        {
            dis_updata2 = 0;

            if (g_num_mov_key == 0)
            {
                // DrawColor_Gray1(333, 449, 267, 267);
                // FillRectColorChang(333, 449, 267, 267, Color_White1, Color_Gray);
                DrawColor_Gray1(keyd[KEY_CURSOR_NUMMSP].xpis, keyd[KEY_CURSOR_NUMMSP].ypis,
                                keyd[KEY_CURSOR_DDOWN].xsize * 4, keyd[KEY_CURSOR_DDOWN].ysize * 4);
                FillRectColorChang(keyd[KEY_CURSOR_NUMMSP].xpis, keyd[KEY_CURSOR_NUMMSP].ypis,
                                   keyd[KEY_CURSOR_DDOWN].xsize * 4, keyd[KEY_CURSOR_DDOWN].ysize * 4,
                                   Color_White1, Color_Gray);
            }
            else
            {
                // FillRectColorChang(340, 456, 260, 260, Color_White1, Color_Gray);
                DrawColor_Gray1(keyd[KEY_CURSOR_MUL].xpis, keyd[KEY_CURSOR_MUL].ypis,
                                keyd[KEY_CURSOR_MDR].xsize * 3, keyd[KEY_CURSOR_MDR].ysize * 3);
                FillRectColorChang(keyd[KEY_CURSOR_MUL].xpis, keyd[KEY_CURSOR_MUL].ypis,
                                   keyd[KEY_CURSOR_MDR].xsize * 3, keyd[KEY_CURSOR_MDR].ysize * 3,
                                   Color_White1, Color_Gray);
            }
            AnaPattern(0, g_GreatPatType, g_CtPatLen);

            scale = pat_getScale(patRule.h_patConvasIndex, patRulesTmp);
            vscale = pat_getFinalScale(scale, scale1);
            xorg = xo - (g_maxX + g_minX) / 2 * (vscale) / 1000;
            yorg = yo - tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;
            posx1 = (S32)((vposx) * (vscale) / 1000 + xorg);
            posy1 = (S32)(mult2 * tmuly * (vposy) * (vscale) / 1000 + yorg);
            if ((((posx1 < patV.xpis) || (posx1 > patV.xpis + patV.xsize) || (posy1 < patV.ypis) || (posy1 > patV.ypis + patV.ysize)) && (vflag == 0)) || vflag == 1)
            {

                xorg = ORG_X;
                yorg = ORG_Y;
                xorg += (g_maxX + g_minX) / 2 * (vscale) / 1000;
                yorg += tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                xo = xorg + (xorg - (S32)((vposx)*vscale / 1000 + xorg));
                yo = yorg + (yorg - (S32)(mult2 * tmuly * (vposy)*vscale / 1000 + yorg));

                xorg = xo - (g_maxX + g_minX) / 2 * (vscale) / 1000;
                yorg = yo - tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;
                vflag = 1;
            }
            //  DrawFillRect(patV.xpis, patV.ypis, patV.xsize, patV.ysize, keybmpind[KEY_CURSOR_IMG].icon[0]);
            // newDrawPat(g_feedc == g_feedsum ? 19 : 18, scale1, xo, yo, 0, 0);
            patRulesTmp = (g_feedc == g_feedsum) ? PATRULES_CREATE1 : PATRULES_CREATE3;
            pat_setPatRule(patRulesTmp);
            pat_clearConvas(patRule.h_patConvasIndex);
            pat_drawPattern(patRulesTmp, scale1, xo, yo, F_FILETYPE, F_FILELEN, 0, 0, NULL);

            DrawButton(keyd[KEY_CURSOR_INSERT], (U16 *)(ADD_ICONBMP),
                       keybmpind[KEY_CURSOR_INSERT].border[0], keybmpind[KEY_CURSOR_INSERT].icon[0]);
            g_ct_insert_flag = 1;
            dis_updata4 = 1;
            ct_insert_flag = g_ct_insert_flag;
        }
        // /[当针点不在最后一针位置时，执行段插入功能提示*end]**********************************************************

        // /[绘制段插入按钮*begin]**********************************************************
        if (dis_updata4 && pressKey == 0)
        {
            dis_updata4 = 0;
            ct_insert_flag = g_ct_insert_flag;
            if (g_ct_insert_flag)
            {
                BmpFillRect(keyd[KEY_CURSOR_INSERT].xpis, keyd[KEY_CURSOR_INSERT].ypis,
                            keyd[KEY_CURSOR_INSERT].xsize, keyd[KEY_CURSOR_INSERT].ysize);
                // DrawButton2(keyd7[0], Color_White1, keybmpind7[0], 1);
                DrawButton(keyd[KEY_CURSOR_INSERT], (U16 *)(ADD_ICONBMP),
                           keybmpind[KEY_CURSOR_INSERT].border[0],
                           keybmpind[KEY_CURSOR_INSERT].icon[0]);
                ct_insert_flag = 1;
            }

            //DelayMs(2000);
        }

        if (g_ct_insert_flag >= 1)
        {
            if (g_ct_insert_flag_temp != g_ct_insert_flag)
            {
                g_ct_insert_flag_temp = g_ct_insert_flag;
                BmpFillRect(keyd[KEY_CURSOR_INSERT].xpis, keyd[KEY_CURSOR_INSERT].ypis,
                            keyd[KEY_CURSOR_INSERT].xsize, keyd[KEY_CURSOR_INSERT].ysize);
                DrawButton(keyd[KEY_CURSOR_INSERT], (U16 *)(ADD_ICONBMP),
                           (g_ct_insert_flag == 2) ? keybmpind[KEY_CURSOR_INSERT].border[1] : keybmpind[KEY_CURSOR_INSERT].border[0],
                           (g_ct_insert_flag == 2) ? keybmpind[KEY_CURSOR_INSERT].icon[1] : keybmpind[KEY_CURSOR_INSERT].icon[0]);
            }
        }
        // /[绘制段插入按钮*end]**********************************************************

        // /[执行段插入功能*begin]**********************************************************
        if (old_ct_insert_flag != g_ct_insert_flag)
        {
            if (g_GreatPatType == 2)
            {
                g_Ctendaddr = sew_getPinAddr((U16 *)SREG, g_CtPatLen, g_feedc, g_ct_insert_flag == 0 ? 1 : 0);
            }

            if (g_ct_insert_flag == 0)
            {
                if (g_GreatPatType == 1)
                {
                    mitPinmsg = mit_getPinsMsg((U16 *)SREG, 52000, g_feedc);
                    //printf(" px = %d py =%d  dx = %d  dy = %d \r\n",mitPinmsg.posx,mitPinmsg.posy,mitPinmsg.dx,mitPinmsg.dy);
                }
                else if (g_GreatPatType == 2)
                {
                    if ((g_input_method == 4 || g_input_method == 5) && ((g_point_num > 1) && (g_dxpos != 0 || g_dypos != 0)))
                    {
                    }
                    else
                    {
                        Bor_feedInfo(g_feedc, g_CtPatLen, &Borcmd, (S16 *)&g_oxpos, (S16 *)&g_oypos, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_speed, &Borpooft, &Borpfdis);
                        if (g_speed == 0)
                            g_speed = 0x60;
                        else if (g_speed == 1)
                            g_speed = 0x40;
                        else if (g_speed == 2)
                            g_speed = 0x20;
                        else
                            g_speed = 0x0;

                        g_oxpos += g_dxpos;
                        g_oypos += g_dypos;
                        g_dxpos = 0;
                        g_dypos = 0;
                    }
                }
            }

            old_ct_insert_flag = g_ct_insert_flag;
        }
        // /[执行段插入功能*end]**********************************************************

        // /[更新当前花样的显示*begin]**********************************************************
        if (dis_updataP)
        {

            scale = pat_getScale(patRule.h_patConvasIndex, patRulesTmp);
            vscale = pat_getFinalScale(scale, scale1);
            xorg = xo - (g_maxX + g_minX) / 2 * (vscale) / 1000;
            yorg = yo - tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

            posx1 = (S32)((vposx) * (vscale) / 1000 + xorg);
            posy1 = (S32)(mult2 * tmuly * (vposy) * (vscale) / 1000 + yorg);
            if ((((posx1 < patV.xpis) || (posx1 > patV.xpis + patV.xsize) || (posy1 < patV.ypis) || (posy1 > patV.ypis + patV.ysize)) && (vflag == 0)) || vflag == 1)
            {

                if (g_ct_insert_flag != 1)
                {
                    xorg = ORG_X;
                    yorg = ORG_Y;
                    xorg += (g_maxX + g_minX) / 2 * (vscale) / 1000;
                    yorg += tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;

                    xo = xorg + (xorg - (S32)((vposx)*vscale / 1000 + xorg));
                    yo = yorg + (yorg - (S32)(mult2 * tmuly * (vposy)*vscale / 1000 + yorg));

                    xorg = xo - (g_maxX + g_minX) / 2 * (vscale) / 1000;
                    yorg = yo - tmuly * (g_maxY + g_minY) / 2 * (vscale) / 1000;
                    vflag = 1;
                }
            }

            // DrawFillRect(patV.xpis, patV.ypis, patV.xsize, patV.ysize, keybmpind[KEY_CURSOR_IMG].icon[0]);
            // newDrawPat(dis_updataP == 2 ? 18 : 17, scale1, xo, yo, 0, 0);
            patRulesTmp = (dis_updataP == 2) ? PATRULES_CREATE3 : PATRULES_CREATE2;
            pat_setPatRule(patRulesTmp);
            pat_clearConvas(patRule.h_patConvasIndex);
            pat_drawPattern(patRulesTmp, scale1, xo, yo, F_FILETYPE, F_FILELEN, 0, 0, NULL);

#if EN_SEWCHECK
            if (F_FILETYPE == PAT_SEW)
            {
                if (sew_Patcheck((U16 *)SREG, g_CtPatLen) == 0)
                {
                    BmpFillRect(234, 449, 60, 48);
                    DrawFStr(234, 449, "Error", Color_Red);
                    DrawFHEX(282, 449, g_sewcheck.flag, 2, Color_Blue);
                    DrawFS32P(234, 465, g_sewcheck.len, 6, 0, Color_Blue);
                    DrawFS32P(234, 481, g_sewcheck.len1, 6, 0, Color_Red);
                }
            }
#endif

            dis_updataP = 0;
        }
        // /[更新当前花样的显示*end]**********************************************************

        // /[方向移动与数字输入按钮更新*begin]**********************************************************
        if (dis_updata1)
        { //方向移动
            dis_updata1 = 0;

            if (g_num_mov_key == 0)
            {
                BmpFillRect(keyd[KEY_CURSOR_NUMMSP].xpis, keyd[KEY_CURSOR_NUMMSP].ypis,
                            keyd[KEY_CURSOR_DDOWN].xsize * 4, keyd[KEY_CURSOR_DDOWN].ysize * 4);

                for (i = KEY_CURSOR_MUL; i <= KEY_CURSOR_MDR; i++)
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
                }
                // DrawFillRect(keyd3[4].xpis + 40, keyd3[4].ypis + 12, 12, 24, mCOLOR ? Color_Silver : Color_White1);
                // DrawMFS32P(keyd3[4].xpis + 40, keyd3[4].ypis + 12, SpeedClass, 1, 0, Color_Black);
                DrawFU32Z(keyd[KEY_CURSOR_MMSP].xpis + keyd[KEY_CURSOR_MMSP].xsize / 2 - 4, keyd[KEY_CURSOR_MMSP].ypis + SAFE_DIST1,
                          SpeedClass, 1, keybmpind[KEY_CURSOR_MMSP].textColor[0]);
            }
            else
            {
                BmpFillRect(keyd[KEY_CURSOR_MUL].xpis, keyd[KEY_CURSOR_MUL].ypis,
                            keyd[KEY_CURSOR_MDR].xsize * 3, keyd[KEY_CURSOR_MDR].ysize * 3);

                for (i = KEY_CURSOR_DUP; i <= KEY_CURSOR_9; i++)
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
                }
                // DrawFillRect(keyd4[2].xpis + 20, keyd4[2].ypis + 4, 12, 24, mCOLOR ? Color_Silver : Color_White1);
                // DrawMFS32P(keyd4[2].xpis + 20, keyd4[2].ypis + 4, SpeedClass, 1, 0, Color_Black);
                DrawFU32Z(keyd[KEY_CURSOR_NUMMSP].xpis + keyd[KEY_CURSOR_NUMMSP].xsize / 2 - 4, keyd[KEY_CURSOR_NUMMSP].ypis + SAFE_DIST1,
                          SpeedClass, 1, keybmpind[KEY_CURSOR_NUMMSP].textColor[0]);
            }
        }
        // /[方向移动与数字输入按钮更新*end]**********************************************************

        // /[更新压脚上下按钮显示*begin]**********************************************************
        if ((tmp_pfoot != (U8)(S_PFOOT)) || (dis_updata))
        {
            tmp_pfoot = S_PFOOT;
            if (tmp_pfoot == 0)
            { //压脚在上
                Up = 0;
                Dn = 1;
            }
            else
            {
                Up = 1;
                Dn = 0;
            }
            if (g_ct_status_flag & bit0)
            { //压脚
                // DrawButton2(keyd[KEY_CURSOR_PFOOT], Color_Gray, (tmp_pfoot == 0) ? 368 : 369, 1);
                DrawButton(keyd[KEY_CURSOR_PFOOT], (U16 *)(ADD_ICONBMP),
                           keybmpind[KEY_CURSOR_PFOOT].border[1],
                           (tmp_pfoot == 0) ? keybmpind[KEY_CURSOR_PFOOT].icon[1] : keybmpind[KEY_CURSOR_PFOOT].icon[3]);
            }
            else
            {
                // DrawButton2(keyd[KEY_CURSOR_PFOOT], Color_White1, (tmp_pfoot == 0) ? 1207 : 1208, 1);
                DrawButton(keyd[KEY_CURSOR_PFOOT], (U16 *)(ADD_ICONBMP),
                           keybmpind[KEY_CURSOR_PFOOT].border[0],
                           (tmp_pfoot == 0) ? keybmpind[KEY_CURSOR_PFOOT].icon[0] : keybmpind[KEY_CURSOR_PFOOT].icon[2]);
            }
            if (PFOOTBT)
            { //设置压脚
                if (((g_feed_flag) && (g_ct_status_flag & bit19) == 0))
                {
                    // DrawButton2(keyd[KEY_CURSOR_PFOOTSET], Color_White1, keybmpind[KEY_CURSOR_PFOOTSET], 1);
                    DrawButton(keyd[KEY_CURSOR_PFOOTSET], (U16 *)(ADD_ICONBMP),
                               keybmpind[KEY_CURSOR_PFOOTSET].border[0], keybmpind[KEY_CURSOR_PFOOTSET].icon[0]);
                }
                else
                {
                    // DrawButton2(keyd[KEY_CURSOR_PFOOTSET], Color_Gray, keybmpind[KEY_CURSOR_PFOOTSET] + 2, 1);
                    DrawButton(keyd[KEY_CURSOR_PFOOTSET], (U16 *)(ADD_ICONBMP),
                               keybmpind[KEY_CURSOR_PFOOTSET].border[2], keybmpind[KEY_CURSOR_PFOOTSET].icon[2]);
                }
            }
        }
        // /[更新压脚上下按钮显示*end]**********************************************************

        // /[更新针杆上升下降按钮显示*begin]**********************************************************
        if ((tmp_needle != (U8)(S_NEEDLE)) || (dis_updata))
        {
            tmp_needle = S_NEEDLE;
            if (g_ct_status_flag & bit3)
            { //针杆
                // DrawButton2(keyd[KEY_CURSOR_NEEDLE], Color_Gray, (tmp_needle == 0x20) ? 370 : 371, 1);
                DrawButton(keyd[KEY_CURSOR_NEEDLE], (U16 *)(ADD_ICONBMP),
                           keybmpind[KEY_CURSOR_NEEDLE].border[1],
                           (tmp_needle == 0x20) ? keybmpind[KEY_CURSOR_NEEDLE].icon[1] : keybmpind[KEY_CURSOR_NEEDLE].icon[3]);
            }
            else
            {
                // DrawButton2(keyd[KEY_CURSOR_NEEDLE], Color_White1, (tmp_needle == 0x20) ? keybmpind[KEY_CURSOR_NEEDLE] : keybmpind[KEY_CURSOR_NEEDLE] + 1, 1);
                DrawButton(keyd[KEY_CURSOR_NEEDLE], (U16 *)(ADD_ICONBMP),
                           keybmpind[KEY_CURSOR_NEEDLE].border[0],
                           (tmp_needle == 0x20) ? keybmpind[KEY_CURSOR_NEEDLE].icon[0] : keybmpind[KEY_CURSOR_NEEDLE].icon[2]);
            }
        }
        // /[更新针杆上升下降按钮显示*end]**********************************************************

        // /[更新禁止按钮显示*begin]**********************************************************
        if (dis_updata)
        {
            dis_updata = 0;
            // 空送 13
            if ((g_ct_status_flag & bit2))
            {
                // DrawButton2(keyd[KEY_CURSOR_FEED], Color_Gray, g_feed_flag == 0 ? 210 : 213, 1);
                DrawButton(keyd[KEY_CURSOR_FEED], (U16 *)(ADD_ICONBMP),
                           keybmpind[KEY_CURSOR_FEED].border[1],
                           (g_feed_flag == 0) ? keybmpind[KEY_CURSOR_FEED].icon[1] : keybmpind[KEY_CURSOR_FEED].icon[3]);
            }
            else
            {
                // DrawButton2(keyd[KEY_CURSOR_FEED], g_feed_flag == 0 ? Color_KeyBlue : Color_White1, g_feed_flag == 0 ? 209 : 211, 1);
                DrawButton(keyd[KEY_CURSOR_FEED], (U16 *)(ADD_ICONBMP),
                           (g_feed_flag == 0) ? keybmpind[KEY_CURSOR_FEED].border[0] : keybmpind[KEY_CURSOR_FEED].border[2],
                           (g_feed_flag == 0) ? keybmpind[KEY_CURSOR_FEED].icon[0] : keybmpind[KEY_CURSOR_FEED].icon[2]);
            }
            // 直线 12
            if ((g_ct_status_flag & bit1))
            {
                // DrawButton2(keyd[KEY_CURSOR_METHOD], Color_Gray, keybmpind[KEY_CURSOR_METHOD] + 3 * (g_input_method - 1) + 2, 1);
                DrawButton(keyd[KEY_CURSOR_METHOD], (U16 *)(ADD_ICONBMP),
                           keybmpind[KEY_CURSOR_METHOD].border[2],
                           keyBmpList[keybmpind[KEY_CURSOR_METHOD].icon[0]][3 * (g_input_method - 1) + 2]);
            }
            else
            {
                // DrawButton2(keyd[KEY_CURSOR_METHOD], g_feed_flag ? Color_KeyBlue : Color_Gray,
                //          g_feed_flag ? (keybmpind[KEY_CURSOR_METHOD] + 3 * (g_input_method - 1) + 1) : (keybmpind[KEY_CURSOR_METHOD] + 3 * (g_input_method - 1) + 2), 1);
                DrawButton(keyd[KEY_CURSOR_METHOD], (U16 *)(ADD_ICONBMP),
                           g_feed_flag ? keybmpind[KEY_CURSOR_METHOD].border[1] : keybmpind[KEY_CURSOR_METHOD].border[2],
                           g_feed_flag ? keyBmpList[keybmpind[KEY_CURSOR_METHOD].icon[0]][3 * (g_input_method - 1) + 1] : keyBmpList[keybmpind[KEY_CURSOR_METHOD].icon[0]][3 * (g_input_method - 1) + 2]);
            }
            // 原点 16
            // DrawButton2(keyd[KEY_CURSOR_HOME], g_ct_status_flag & bit5 ? Color_Gray : Color_White1, g_ct_status_flag & bit5 ? 1209 : keybmpind[KEY_CURSOR_HOME], 1);
            DrawButton(keyd[KEY_CURSOR_HOME], (U16 *)(ADD_ICONBMP),
                       (g_ct_status_flag & bit5) ? keybmpind[KEY_CURSOR_HOME].border[1] : keybmpind[KEY_CURSOR_HOME].border[0],
                       (g_ct_status_flag & bit5) ? keybmpind[KEY_CURSOR_HOME].icon[1] : keybmpind[KEY_CURSOR_HOME].icon[0]);

            // 多重缝 15
            // DrawButton2(keyd[KEY_CURSOR_OFFSET], (g_ct_status_flag & bit4) ? Color_Gray : Color_White1, (g_ct_status_flag & bit4) ? (keybmpind[KEY_CURSOR_OFFSET] + 3 * g_para_offset + 2) : (keybmpind[KEY_CURSOR_OFFSET] + 3 * g_para_offset), 1);
            DrawButton(keyd[KEY_CURSOR_OFFSET], (U16 *)(ADD_ICONBMP),
                       (g_ct_status_flag & bit4) ? keybmpind[KEY_CURSOR_OFFSET].border[2] : keybmpind[KEY_CURSOR_OFFSET].border[0],
                       (g_ct_status_flag & bit4) ? keyBmpList[keybmpind[KEY_CURSOR_OFFSET].icon[0]][3 * (g_para_offset) + 2] : keyBmpList[keybmpind[KEY_CURSOR_OFFSET].icon[0]][3 * (g_para_offset) + 0]);

            // 取消 19
            // DrawButton2(keyd[KEY_CURSOR_RETURN], (g_ct_status_flag & bit8) ? Color_Gray : Color_White1, (g_ct_status_flag & bit8) ? keybmpind[KEY_CURSOR_RETURN] + 1 : keybmpind[KEY_CURSOR_RETURN], 1);
            DrawButton(keyd[KEY_CURSOR_RETURN], (U16 *)(ADD_ICONBMP),
                       (g_ct_status_flag & bit8) ? keybmpind[KEY_CURSOR_RETURN].border[2] : keybmpind[KEY_CURSOR_RETURN].border[0],
                       (g_ct_status_flag & bit8) ? keybmpind[KEY_CURSOR_RETURN].icon[2] : keybmpind[KEY_CURSOR_RETURN].icon[0]);

            // Z字缝 18
            // DrawButton2(keyd[KEY_CURSOR_ZIG], (g_ct_status_flag & bit7) ? Color_Gray : Color_White1, (g_ct_status_flag & bit7) ? (keybmpind[KEY_CURSOR_ZIG] + 3 * g_zig_zag + 2) : (keybmpind[KEY_CURSOR_ZIG] + 3 * g_zig_zag), 1);
            DrawButton(keyd[KEY_CURSOR_ZIG], (U16 *)(ADD_ICONBMP),
                       (g_ct_status_flag & bit7) ? keybmpind[KEY_CURSOR_ZIG].border[2] : keybmpind[KEY_CURSOR_ZIG].border[0],
                       (g_ct_status_flag & bit7) ? keyBmpList[keybmpind[KEY_CURSOR_ZIG].icon[0]][3 * (g_zig_zag) + 2] : keyBmpList[keybmpind[KEY_CURSOR_ZIG].icon[0]][3 * (g_zig_zag) + 0]);

            // 附加功能 17
            // DrawButton2(keyd[KEY_CURSOR_CODE], (g_ct_status_flag & bit6) ? Color_Gray : Color_White1, (g_ct_status_flag & bit6) ? keybmpind[KEY_CURSOR_CODE] + 2 : keybmpind[KEY_CURSOR_CODE], 1);
            DrawButton(keyd[KEY_CURSOR_CODE], (U16 *)(ADD_ICONBMP),
                       (g_ct_status_flag & bit6) ? keybmpind[KEY_CURSOR_CODE].border[2] : keybmpind[KEY_CURSOR_CODE].border[0],
                       (g_ct_status_flag & bit6) ? keybmpind[KEY_CURSOR_CODE].icon[2] : keybmpind[KEY_CURSOR_CODE].icon[0]);

            // 前后缝 21
            // DrawButton2(keyd[KEY_CURSOR_TACKING], (g_ct_status_flag & bit10) ? Color_Gray : Color_White1, (g_ct_status_flag & bit10) ? (keybmpind[KEY_CURSOR_TACKING] + 3 * g_bt_mode + 2) : (keybmpind[KEY_CURSOR_TACKING] + 3 * g_bt_mode), 1);
            DrawButton(keyd[KEY_CURSOR_TACKING], (U16 *)(ADD_ICONBMP),
                       (g_ct_status_flag & bit10) ? keybmpind[KEY_CURSOR_TACKING].border[2] : keybmpind[KEY_CURSOR_TACKING].border[0],
                       (g_ct_status_flag & bit10) ? keyBmpList[keybmpind[KEY_CURSOR_TACKING].icon[0]][3 * (g_bt_mode) + 2] : keyBmpList[keybmpind[KEY_CURSOR_TACKING].icon[0]][3 * (g_bt_mode) + 0]);

            // 速度修正 20
            // DrawButton2(keyd[KEY_CURSOR_SPEED], (g_ct_status_flag & bit9) ? Color_Gray : Color_White1, (g_ct_status_flag & bit9) ? keybmpind[KEY_CURSOR_SPEED] + 2 : keybmpind[KEY_CURSOR_SPEED], 1);
            DrawButton(keyd[KEY_CURSOR_SPEED], (U16 *)(ADD_ICONBMP),
                       (g_ct_status_flag & bit9) ? keybmpind[KEY_CURSOR_SPEED].border[2] : keybmpind[KEY_CURSOR_SPEED].border[0],
                       (g_ct_status_flag & bit9) ? keybmpind[KEY_CURSOR_SPEED].icon[2] : keybmpind[KEY_CURSOR_SPEED].icon[0]);

            // 取消 22
            // DrawButton2(keyd[KEY_CURSOR_CANCEL], (g_ct_status_flag & bit11) ? Color_Gray : Color_White1, (g_ct_status_flag & bit11) ? keybmpind[KEY_CURSOR_CANCEL] + 1 : keybmpind[KEY_CURSOR_CANCEL], 1);
            DrawButton(keyd[KEY_CURSOR_CANCEL], (U16 *)(ADD_ICONBMP),
                       (g_ct_status_flag & bit11) ? keybmpind[KEY_CURSOR_CANCEL].border[1] : keybmpind[KEY_CURSOR_CANCEL].border[0],
                       (g_ct_status_flag & bit11) ? keybmpind[KEY_CURSOR_CANCEL].icon[1] : keybmpind[KEY_CURSOR_CANCEL].icon[0]);

            // UP 前进
            // DrawButton2(keyd1[0], g_ct_status_flag & bit12 ? Color_Gray : Color_White1, g_ct_status_flag & bit12 ? keybmpind1[0] + 1 : keybmpind1[0], 1); //前进
            DrawButton(keyd[KEY_CURSOR_MUP], (U16 *)(ADD_ICONBMP),
                       (g_ct_status_flag & bit12) ? keybmpind[KEY_CURSOR_MUP].border[1] : keybmpind[KEY_CURSOR_MUP].border[0],
                       (g_ct_status_flag & bit12) ? keybmpind[KEY_CURSOR_MUP].icon[1] : keybmpind[KEY_CURSOR_MUP].icon[0]);

            // DOWN	后退
            // DrawButton2(keyd1[1], g_ct_status_flag & bit13 ? Color_Gray : Color_White1, g_ct_status_flag & bit13 ? keybmpind1[1] + 1 : keybmpind1[1], 1); //后退
            DrawButton(keyd[KEY_CURSOR_MDOWN], (U16 *)(ADD_ICONBMP),
                       (g_ct_status_flag & bit13) ? keybmpind[KEY_CURSOR_MDOWN].border[1] : keybmpind[KEY_CURSOR_MDOWN].border[0],
                       (g_ct_status_flag & bit13) ? keybmpind[KEY_CURSOR_MDOWN].icon[1] : keybmpind[KEY_CURSOR_MDOWN].icon[0]);

            // 菜单按钮
            // DrawButton2(keyd[KEY_CURSOR_MENU], (g_ct_status_flag & bit14) ? Color_Gray : Color_White1, (g_ct_status_flag & bit14) ? 364 : keybmpind[KEY_CURSOR_MENU], 1);
            DrawButton(keyd[KEY_CURSOR_MENU], (U16 *)(ADD_ICONBMP),
                       (g_ct_status_flag & bit14) ? keybmpind[KEY_CURSOR_MENU].border[1] : keybmpind[KEY_CURSOR_MENU].border[0],
                       (g_ct_status_flag & bit14) ? keybmpind[KEY_CURSOR_MENU].icon[1] : keybmpind[KEY_CURSOR_MENU].icon[0]);

            // TOP按纽	BACK
            //			if((g_ct_status_flag&bit15)){
            //				DrawButton(keyd[KEY_CURSOR_BACK],(U16 *)(STARTWLBMPADD),KEY_Gray,365);
            //			}else{
            //				DrawButton(keyd[KEY_CURSOR_BACK],(U16 *)(STARTWLBMPADD),KEY_Silver,keybmpind[KEY_CURSOR_BACK]);
            //			}
            // 图形显示按钮
            //			if((g_ct_status_flag&bit16))	{
            //				  DrawButton(keyd[KEY_CURSOR_PAT],(U16 *)(STARTWLBMPADD),KEY_Gray,366);
            //			}else{
            //				DrawButton(keyd[KEY_CURSOR_PAT],(U16 *)(STARTWLBMPADD),KEY_Silver,keybmpind[KEY_CURSOR_PAT]);
            //			}
            // ENTER
            // DrawButton2(keyd[KEY_CURSOR_ENTER], (g_ct_status_flag & bit17) ? Color_Gray : Color_White1, (g_ct_status_flag & bit17) ? 125 : keybmpind[KEY_CURSOR_ENTER], 1);
            DrawButton(keyd[KEY_CURSOR_ENTER], (U16 *)(ADD_ICONBMP),
                       (g_ct_status_flag & bit17) ? keybmpind[KEY_CURSOR_ENTER].border[1] : keybmpind[KEY_CURSOR_ENTER].border[0],
                       (g_ct_status_flag & bit17) ? keybmpind[KEY_CURSOR_ENTER].icon[1] : keybmpind[KEY_CURSOR_ENTER].icon[0]);

            ViewPage(usepageno);
        }
        // /[更新禁止按钮显示*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1 == 0)
        {
            ErrorMsg(MENU_CURSOR);
            if (S_LIMIT)
            {
                DelayMs(2);
                Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS]));
                if (S_LIMIT)
                {
                    pno = MENU_RWHELP;
                    hleppara = 20;
                    poldno[2] = MENU_CURSOR;
                    pnoindex = 3;
                }
            }
        }
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[更新压框移动速度等级*begin]**********************************************************
        if (dis_updata3)
        {
            dis_updata3 = 0;
            if (g_num_mov_key == 0)
            {
                DrawFillRect(keyd[KEY_CURSOR_MMSP].xpis + keyd[KEY_CURSOR_MMSP].xsize / 2 - 4, keyd[KEY_CURSOR_MMSP].ypis + SAFE_DIST1,
                             9, 16, keybmpind[KEY_CURSOR_MMSP].textColor[1]);
                // DrawMFS32P(keyd3[4].xpis + 40, keyd3[4].ypis + 12, SpeedClass, 1, 0, Color_Black);
                DrawFU32Z(keyd[KEY_CURSOR_MMSP].xpis + keyd[KEY_CURSOR_MMSP].xsize / 2 - 4, keyd[KEY_CURSOR_MMSP].ypis + SAFE_DIST1,
                          SpeedClass, 1, keybmpind[KEY_CURSOR_MMSP].textColor[0]);
            }
            else
            {
                // DrawFillRect(keyd4[2].xpis + 20, keyd4[2].ypis + 4, 12, 24, mCOLOR ? Color_Silver : Color_White1);
                // DrawMFS32P(keyd4[2].xpis + 20, keyd4[2].ypis + 4, SpeedClass, 1, 0, Color_Black);
                DrawFillRect(keyd[KEY_CURSOR_NUMMSP].xpis + keyd[KEY_CURSOR_NUMMSP].xsize / 2 - 4, keyd[KEY_CURSOR_NUMMSP].ypis + SAFE_DIST1,
                             9, 16, keybmpind[KEY_CURSOR_NUMMSP].textColor[1]);
                DrawFU32Z(keyd[KEY_CURSOR_NUMMSP].xpis + keyd[KEY_CURSOR_NUMMSP].xsize / 2 - 4, keyd[KEY_CURSOR_NUMMSP].ypis + SAFE_DIST1,
                          SpeedClass, 1, keybmpind[KEY_CURSOR_NUMMSP].textColor[0]);
            }
        }
        // /[更新压框移动速度等级*end]**********************************************************

        // /[更新X,Y与压脚高度绝对值*begin]**********************************************************
        if (Timer_ms > 200)
        {
            Timer_ms = 0;
            if (Read_xyposi())
            {
                // DrawFillRect(118, 34, 56, 40, mCOLOR ? Color_Silver : Color_White);
                DrawFillRect(rect[RECT_CURSOR_XX_STR].xpis, rect[RECT_CURSOR_XX_STR].ypis,
                             rect[RECT_CURSOR_XX_STR].xsize, rect[RECT_CURSOR_XX_STR].ysize, rect[RECT_CURSOR_XX_STR].colorB[0]);
                DrawFS32P(rect[RECT_CURSOR_XX_STR].xpis + SAFE_DIST3, rect[RECT_CURSOR_XX_STR].ypis + SAFE_DIST4,
                          g_xabspos, 6, 1, rect[RECT_CURSOR_XX_STR].colorT[0]);
                DrawFillRect(rect[RECT_CURSOR_XY_STR].xpis, rect[RECT_CURSOR_XY_STR].ypis,
                             rect[RECT_CURSOR_XY_STR].xsize, rect[RECT_CURSOR_XY_STR].ysize, rect[RECT_CURSOR_XY_STR].colorB[0]);
                DrawFS32P(rect[RECT_CURSOR_XY_STR].xpis + SAFE_DIST3, rect[RECT_CURSOR_XY_STR].ypis + SAFE_DIST4,
                          g_yabspos, 6, 1, rect[RECT_CURSOR_XY_STR].colorT[0]);
                // #if MOVEUNIT == 1
                //                 if (g_curPTtype == 2)
                //                 {
                //                     DrawFS32P(118, 36, g_xabspos * vimut, 7, 2, Color_Black);
                //                     DrawFS32P(118, 56, g_yabspos * vimut, 7, 2, Color_Black);
                //                 }
                //                 else
                //                 {
                //                     DrawFS32P(118, 36, g_xabspos, 6, 1, Color_Black);
                //                     DrawFS32P(118, 56, g_yabspos, 6, 1, Color_Black);
                //                 }

                // #else
                //                 DrawFS32P(118, 36, g_xabspos, 6, 1, Color_Black);
                //                 DrawFS32P(118, 56, g_yabspos, 6, 1, Color_Black);
                // #endif
                // DrawFillRect(226, 56, 32, 16, mCOLOR ? Color_Silver : Color_White);
                // DrawFS32P(226, 56, g_pf_absdis, 4, 1, Color_Black);
                DrawFillRect(rect[RECT_CURSOR_XPF_STR].xpis, rect[RECT_CURSOR_XPF_STR].ypis,
                             rect[RECT_CURSOR_XPF_STR].xsize, rect[RECT_CURSOR_XPF_STR].ysize, rect[RECT_CURSOR_XPF_STR].colorB[0]);
                DrawFS32P(rect[RECT_CURSOR_XPF_STR].xpis + SAFE_DIST3 + TYPE_SIZE20, rect[RECT_CURSOR_XPF_STR].ypis + SAFE_DIST4,
                          g_pf_absdis, 4, 1, rect[RECT_CURSOR_XPF_STR].colorT[0]);
            }
        }
        // /[更新X,Y与压脚高度绝对值*end]**********************************************************

        // /[更新X,Y*begin]**********************************************************
        if (chEditflagTemp != g_editflag || bEditFlashFlag == 1)
        {
            chEditflagTemp = g_editflag;
            dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);
        }
        // /[更新X,Y*end]**********************************************************

        // /[记录打板开始时中压脚高度*begin]**********************************************************
        if (g_zhouDown)
        {
            g_zhouDown = 0;
            Write_Cmd(C_LDOWMPF, 0, 0);
            Read_Status();
        }
        // /[记录打板开始时中压脚高度*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if (pno != MENU_CURSOR)
        {
            plastno = MENU_CURSOR;
            g_temp_pno = pno;
            break;
        }
        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

#define KEY_INMENU_BACK 1   //1 返回
#define KEY_INMENU_RETEND 2 //2 空送回原点并结束
#define KEY_INMENU_END 3    //3 结束
#define KEY_INMENU_RET 4    //4 空送回原点
#define KEY_INMENU_NUM 5    //5 数字输入
#define KEY_INMENU_MODIFY 6 //6 修改
#define KEY_INMENU_IMG 7    //7 花样预览

#define KEY_INMENU_PITCH 8    //8 针距
#define KEY_INMENU_READ 9     //9 读取花样
#define KEY_INMENU_SKIPJOG 10 //10 跳针设置
#define KEY_INMENU_LFORCE 11  //11 松线设置
#define KEY_INMENU_BACKTOP 12 //12 返回花样打板首页

#define KEY_INMENU_EXPF 13 //13 伸缩压框

#define KEY_INMENU_MAX 14

#define RECT_INMENU_TIT 1  //1 标题
#define RECT_INMENU_BASE 2 //2 底色

#define RECT_INMENU_MAX 3

void Menu_CtInputMenu(void)
{
    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
    /****按键相关参数end****/

    /****标志位相关参数begin****/
    U32 i, j;
    U8 f;
    U32 add1, add2, ii, kk;
    U32 dat2;
    U16 checksum;
    /****标志位相关参数end***/

    const U8 keynum = {KEY_INMENU_MAX};
    const KEYPAD keyd[] = {
        {0, 0, 0, 0},
        {TYPE_X11, TYPE_Y4, KEY_X1, KEY_Y1}, //1 返回

        {TYPE_X1, 343, KEY_X7, KEY_Y7},                                        //2 空送回原点并结束
        {TYPE_X1 + KEY_X7 + SAFE_DIST1, 343, KEY_X1, KEY_X1},                  //3 结束
        {TYPE_X1 + KEY_X7 + SAFE_DIST1 * 2 + KEY_X1, 343, KEY_X1, KEY_X1},     //4 空送回原点
        {TYPE_X1 + KEY_X7 + SAFE_DIST1 * 3 + KEY_X1 * 2, 343, KEY_X1, KEY_X1}, //5 数字输入
        {TYPE_X1 + KEY_X7 + SAFE_DIST1 * 4 + KEY_X1 * 3, 343, KEY_X1, KEY_X1}, //6 修改
        {TYPE_X1 + KEY_X7 + SAFE_DIST1 * 5 + KEY_X1 * 4, 343, KEY_X1, KEY_X1}, //7 花样预览

        {TYPE_X1 + KEY_X7 + SAFE_DIST1, TYPE_Y4, KEY_X1, KEY_X1},                  //8 针距
        {TYPE_X1 + KEY_X7 + SAFE_DIST1 * 2 + KEY_X1, TYPE_Y4, KEY_X1, KEY_X1},     //9 读取花样
        {TYPE_X1 + KEY_X7 + SAFE_DIST1 * 3 + KEY_X1 * 2, TYPE_Y4, KEY_X1, KEY_X1}, //10 跳针设置
        {TYPE_X1 + KEY_X7 + SAFE_DIST1 * 4 + KEY_X1 * 3, TYPE_Y4, KEY_X1, KEY_X1}, //11 松线设置
        {TYPE_X1 + KEY_X7 + SAFE_DIST1 * 5 + KEY_X1 * 4, TYPE_Y4, KEY_X1, KEY_X1}, //12 返回花样打板首页

        {TYPE_X1 + KEY_X7 + SAFE_DIST1 * 6 + KEY_X1 * 7, 343, KEY_X1, KEY_X1}, //13 伸缩压框

    };

    const tydDisSrcIndex keybmpind[] = {
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},

        {{KEY_Silver}, {0}, {72}, {1, 0, 0, 0}, {0}}, //1 返回

        {{KEY_Silver, KEY_Gray}, {0}, {499, 500, 503, 504}, {2, 0, 0, 0}, {0}},    //2 空送回原点并结束
        {{KEY_Silver, KEY_Gray}, {0}, {505, 506}, {3, 0, 0, 0}, {0}},              //3 结束
        {{KEY_Silver, KEY_Gray}, {0}, {507, 508}, {4, 0, 0, 0}, {0}},              //4 空送回原点
        {{KEY_Blue, KEY_Blue}, {0}, {495, 496}, {5, 11, 0, 0}, {0}},               //5 数字输入
        {{KEY_Silver, KEY_Gray}, {0}, {497, 498}, {6, 0, 0, 0}, {0}},              //6 修改
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {11, 13, 12}, {13, 0, 0, 0}, {0}}, //7 花样预览

        {{KEY_Silver, KEY_Gray}, {0}, {384, 385}, {7, 0, 0, 0}, {0}},              //8 针距
        {{KEY_Silver, KEY_Gray}, {0}, {276, 277}, {8, 0, 0, 0}, {0}},              //9 读取花样
        {{KEY_Silver, KEY_Gray}, {0}, {509}, {9, 0, 0, 0}, {0}},                   //10 跳针设置
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {28, 30, 29}, {10, 0, 0, 0}, {0}}, //11 松线设置
        {{KEY_Silver, KEY_Gray}, {0}, {241, 242}, {12, 0, 0, 0}, {0}},             //12 返回花样打板首页

        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}}, //13 伸缩压框

    };

    const RECTPAD rect[] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {0}},
        {TYPE_X13, 311, LCD_WIDTH, TYPE_SIZE5, {Color_DarkBlue}, {Color_White}, {0}}, //1 标题
        {TYPE_X13, 311 + TYPE_SIZE5, LCD_WIDTH, 137, {Color_Gray}, {0}, {0}},         //2 底色

    };

    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_INMENU); //设置当前文字显示雷人在P1页面，对应40.bin
    // InitScreen();
    // initViewStatus();
    // pnoindex = 0;

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    g_fbmac = 0;
    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************

    //画出方框
    for (i = 1; i < RECT_INMENU_MAX; i++)
    {
        DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
    }
    DrawFMenuStrUser(rect[RECT_INMENU_TIT].xpis,
                     rect[RECT_INMENU_TIT].ypis,
                     keybmpind[0].titleStr[0],
                     rect[RECT_INMENU_TIT].colorB[0], rect[RECT_INMENU_TIT].colorT[0]);

    //画出按键显示
    for (i = 1; i < KEY_INMENU_MAX; i++)
    {
        if (((i == KEY_INMENU_LFORCE) && (TENSIONBT == 0)) ||
            (i == KEY_INMENU_NUM) || (i == KEY_INMENU_EXPF && g_fbmac == 0))
        {
        }
        else if (i == KEY_INMENU_RETEND)
        {
            DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                       keybmpind[i].border[0], (g_ModToCt) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
        }
        else
        {
            DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
        }
    }
    if (g_ct_insert_flag == 2)
    {
        for (i = 1; i < KEY_INMENU_MAX; i++)
        {
            if (i == KEY_INMENU_END ||
                i == KEY_INMENU_RET || i == KEY_INMENU_BACKTOP || i == KEY_INMENU_MODIFY)
            {
                DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[1], keybmpind[i].icon[1]);
            }
            else if (i == KEY_INMENU_RETEND)
            {
                DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                           keybmpind[i].border[1], (g_ModToCt) ? keybmpind[i].icon[3] : keybmpind[i].icon[1]);
            }
        }
    }
    else if (g_ModToCt)
    {
        for (i = 1; i < keynum; i++)
        {
            if (i == KEY_INMENU_READ || i == KEY_INMENU_END ||
                i == KEY_INMENU_RET || i == KEY_INMENU_BACKTOP || i == KEY_INMENU_MODIFY)
            {
                DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[1], keybmpind[i].icon[1]);
            }
        }
    }
    DrawButton(keyd[KEY_INMENU_NUM], (U16 *)(ADD_ICONBMP),
               g_num_mov_key == 0 ? keybmpind[KEY_INMENU_NUM].border[0] : keybmpind[KEY_INMENU_NUM].border[1],
               g_num_mov_key == 0 ? keybmpind[KEY_INMENU_NUM].icon[0] : keybmpind[KEY_INMENU_NUM].icon[1]);
    DrawButton(keyd[KEY_INMENU_LFORCE], (U16 *)(ADD_ICONBMP),
               g_feed_flag == 1 ? keybmpind[KEY_INMENU_LFORCE].border[0] : keybmpind[KEY_INMENU_LFORCE].border[1],
               g_feed_flag == 1 ? keybmpind[KEY_INMENU_LFORCE].icon[0] : keybmpind[KEY_INMENU_LFORCE].icon[1]);

    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        keydata = get_keydata((KEYPAD *)keyd, keynum, 0); //获取键值

        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            //带有连续按键功能的按键
            if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > 0) //按键按下的键值预处理    与提示性信息处理
        {
            //特定情况下不生效按键
            if ((keydata == KEY_INMENU_LFORCE) && (TENSIONBT == 0))
            {
                keydata = 0;
            }
            else if ((keydata == KEY_INMENU_LFORCE) && (g_feed_flag == 0))
            {
                keydata = 0;
            }
            else if ((keydata == KEY_INMENU_EXPF) && (g_fbmac == 0))
            {
                keydata = 0;
            }
            else if (g_ct_insert_flag == 2 &&
                     (keydata != KEY_INMENU_BACK && keydata != KEY_INMENU_PITCH &&
                      keydata != KEY_INMENU_NUM && keydata != KEY_INMENU_SKIPJOG &&
                      keydata != KEY_INMENU_LFORCE && keydata != KEY_INMENU_READ &&
                      keydata != KEY_INMENU_IMG && keydata != KEY_INMENU_EXPF))
            {
                keydata = 0;
            }
            else if (g_ModToCt && g_ct_insert_flag != 2 &&
                     (keydata != KEY_INMENU_BACK && keydata != KEY_INMENU_PITCH &&
                      keydata != KEY_INMENU_NUM && keydata != KEY_INMENU_SKIPJOG &&
                      keydata != KEY_INMENU_LFORCE && keydata != KEY_INMENU_IMG &&
                      keydata != KEY_INMENU_EXPF && keydata != KEY_INMENU_RETEND))
            {
                keydata = 0;
            }
            else
            {

                if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时
                {
                    keyon = keydata;
                    //无按键特效
                    //非常规按键-//绘制颜色文字按键
                    DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]); //常规按键
                    Times = 0;
                    delay = KEYDT; //按键防抖次数
                }
                else if (keyon != keydata) //已有按键按下，不处理新按键信息
                {
                    keydata = 0;
                }

                if (Times > delay) //按键防抖
                {
                    if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                    {
                        beeponf = 1;

                        if (g_keyBellT) //按键时蜂鸣器发声时间
                            Beep_On(g_keyBellT);

                        switch (keyon) //按键按下标题提示语显示
                        {

                        case KEY_INMENU_NUM:
                            DrawFMenuStrUser(rect[RECT_INMENU_TIT].xpis,
                                             rect[RECT_INMENU_TIT].ypis,
                                             g_num_mov_key == 0 ? keybmpind[keyon].titleStr[0] : keybmpind[keyon].titleStr[1],
                                             rect[RECT_INMENU_TIT].colorB[0], rect[RECT_INMENU_TIT].colorT[0]);
                            break;
                        case KEY_INMENU_EXPF:
                            DrawFMenuStrP1(rect[RECT_INMENU_TIT].xpis,
                                           rect[RECT_INMENU_TIT].ypis, MENU_CURSOR, TLFNADD_READCOV + 32);
                            break;
                        default:
                            DrawFMenuStrUser(rect[RECT_INMENU_TIT].xpis,
                                             rect[RECT_INMENU_TIT].ypis,
                                             keybmpind[keyon].titleStr[0],
                                             rect[RECT_INMENU_TIT].colorB[0], rect[RECT_INMENU_TIT].colorT[0]);
                            break;
                        }

                        delay = KEYFT;
                    }
                    else if (beeponf == 1) //第二次进入
                    {
                        beeponf = 2;
                    }
                    else if (beeponf < 20)
                    {
                        beeponf++;
                    }

                    //带有长按连续功能按键的功能
                    Times = 0;
                }
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            switch (keyoff)
            {
            case KEY_INMENU_BACK:
                pno = MENU_CURSOR;
                break;
            case KEY_INMENU_RETEND: //三菱：结束并返回次原点	兄弟：结束
                if (g_GreatPatType == 1)
                { //三菱
                    if (0 == NeddleUp(MENU_CURSOR))
                        break;

                    if (g_ModToCt)
                    {
                        if (g_feed_sew)
                        { // 缝纫标志
                            SREG[g_draw_p++] = 0x201;
                            SREG[g_draw_p++] = 0;
                            SREG[g_draw_p++] = 0;
                            SREG[g_draw_p++] = 0;
                            SREG[g_line_p++] = g_line_sum++;
                            SREG[g_pat_p++] = 0x2;
                            SREG[g_pat_p++] = 0;
                            g_feed_sew = 0; // 空送标志
                            g_DoTrim = 0;
                        }
                        SREG[g_draw_p++] = 0x1f01;
                        SREG[g_draw_p++] = 0;
                        SREG[g_draw_p++] = 0;
                        SREG[g_draw_p++] = 0;
                        SREG[g_line_p++] = g_line_sum++;
                        SREG[g_pat_p++] = 0x1f;
                        SREG[g_pat_p++] = 0;

                        mit_CtToMod();
                        AnaPattern(0, PAT_MIT, 0);
                        g_jog_point = g_patd.feed_sum;
                        g_Tsavetimes = 0;
                        g_savetimes = 0;
                        g_modcordflag = 0;
                        pno = MENU_MODIFY;
                        pnoindex = 2;
                        g_modifyflag1 = 1;
                    }
                    else
                    {
                        if (g_line_sum)
                        {
                            if (g_feed_sew) // 缝纫标志
                            {
                                SREG[g_draw_p++] = 0x201;
                                SREG[g_draw_p++] = 0;
                                SREG[g_draw_p++] = 0;
                                SREG[g_draw_p++] = 0;
                                SREG[g_line_p++] = g_line_sum++;
                                SREG[g_pat_p++] = 0x2;
                                SREG[g_pat_p++] = 0;
                                g_feed_sew = 0; // 空送标志
                                g_DoTrim = 0;
                            }
                            g_dxpos = -g_oxpos;
                            g_dypos = -g_oypos;
                            if (g_home_2flag)
                            {
                                g_dxpos += g_home_2xpos;
                                g_dypos += g_home_2ypos;
                            }
                            g_feed_flag = 0;
                            if ((g_dxpos) || (g_dypos))
                            {
                                Mit_Create_Data(1);
                                Send_Pfoot(1, MENU_CURSOR, 1);
                                Comm_Move(g_oxpos, g_oypos, 120, MENU_CURSOR, 0, 0);

                                //Write_Cmd(C_PFOOTACTION, pf_absval, 0);
                            }
                        }
                        SREG[g_draw_p++] = 0x1f01;
                        SREG[g_draw_p++] = 0;
                        SREG[g_draw_p++] = 0;
                        SREG[g_draw_p++] = 0;
                        SREG[g_line_p++] = g_line_sum++;
                        SREG[g_pat_p++] = 0x1f;
                        SREG[g_pat_p++] = 0;

                        j = 0;
                        g_jog_point = 0;
                        for (i = 52000; i < g_pat_p; i += 2)
                        {
                            if (SREG[i] == 0x06) //找到次原点
                            {
                                g_jog_point = j;
                                break;
                            }
                            j++;
                        }
                        pno = MENU_INHELP;
                        hleppara = 0;
                        g_endtype = 1;
                    }
                }
                else if (F_FILETYPE == PAT_SEW)
                {
                    if (g_ModToCt)
                    {
                        g_Ctendaddr = sew_getPinAddr((U16 *)SREG, g_CtPatLen, g_feedc, 1);
                        g_Ctstaddr = g_Ctendaddr;
                        Bor_doEndcmd((U16 *)SREG, (U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, &g_patd.feed_sum);
                        g_jog_point = g_patd.feed_sum;
                        HREG[5] = (g_CtPatLen >> 16) & 0xffff;
                        HREG[4] = g_CtPatLen & 0xffff;
                        pno = MENU_MODIFY;
                        pnoindex = 2;

                        g_modifyflag1 = 1;
                        g_savetimes = 0;
                        g_Tsavetimes = g_savetimes;
                        for (i = 0; i < MAXBLIND; i++)
                        {
                            BLKIND[i] = 0;
                        }
                        for (i = 0; i < MAXBLKBUF; i++)
                        {
                            BLKBUF[i] = 0;
                        }
                        BackupSREG(g_Tsavetimes, 0, g_CtPatLen, 1);
                        //							g_savetimes =0;
                        //							g_modifyflag = 1;
                        //							g_Tsavetimes = g_savetimes;
                        //							g_Tsavetimes++;
                        //							g_savetimes = g_Tsavetimes;
                        //							BackupSREG(g_Tsavetimes,0,g_CtPatLen,1);
                    }
                    else
                    {
                        g_Ctstaddr = g_Ctendaddr;
                        Bor_doEndcmd((U16 *)SREG, (U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, &g_patd.feed_sum);
                        HREG[5] = (g_CtPatLen >> 16) & 0xffff;
                        HREG[4] = g_CtPatLen & 0xffff;
                        g_jog_point = g_patd.feed_sum;
                        pno = MENU_INHELP;
                        hleppara = 0;
                        g_endtype = 1;
                    }
                }
                //					g_isBAT = 0;	//清除跳缝标志
                break;
            case KEY_INMENU_END: //三菱：结束   兄弟：回到次原点

                if (g_GreatPatType == 1)
                { //三菱
                    if (g_feed_sew || g_DoTrim)
                    { // 缝纫标志
                        SREG[g_draw_p++] = 0x201;
                        SREG[g_draw_p++] = 0;
                        SREG[g_draw_p++] = 0;
                        SREG[g_draw_p++] = 0;
                        SREG[g_line_p++] = g_line_sum++;
                        SREG[g_pat_p++] = 0x2;
                        SREG[g_pat_p++] = 0;
                        g_feed_sew = 0; // 空送标志
                        g_DoTrim = 0;
                    }

                    SREG[g_draw_p++] = 0x1f01;
                    SREG[g_draw_p++] = 0;
                    SREG[g_draw_p++] = 0;
                    SREG[g_draw_p++] = 0;
                    SREG[g_line_p++] = g_line_sum++;
                    SREG[g_pat_p++] = 0x1f;
                    SREG[g_pat_p++] = 0;
                    g_modifyflag |= 1;
                    pno = MENU_INHELP;
                    hleppara = 0;
                    g_endtype = 1;
                    //printf("g_feedsum = %d  g_patd.feed_sum = %d \r\n",g_feedsum,g_patd.feed_sum);
                    g_jog_point = g_feedsum;
                }
                else
                {
                    if (0 == NeddleUp(MENU_CURSOR))
                        break;
                    g_Ctstaddr = g_Ctendaddr;
                    if (1 == Bor_dofeedOrg((U16 *)SREG, (U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen))
                    {
                        g_modifyflag |= 1;
                    }
                    Bor_CreatBack((U16 *)&g_Ctsavetimes, g_Ctstaddr, g_Ctendaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);
                    g_dxpos = 0;
                    g_dypos = 0;
                    g_disxpos = g_patd.orgX;
                    g_disypos = g_patd.orgY;
                    g_ct_status_flag = 0;
                    g_feedsum = g_patd.feed_sum;
                    g_feedc = g_patd.feed_sum;
                    dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);

                    Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                    Comm_Move(g_patd.orgX, g_patd.orgY, 120, MENU_CURSOR, 1, 1);
                    pno = MENU_CURSOR;
                    pnoindex = 2;
                }
                //					g_isBAT = 0;	//清除跳缝标志
                //					printf("F_IND_NO = %d \r\n",F_IND_NO);
                break;
            case KEY_INMENU_RET: //三菱：回到原点	兄弟：结束并回到次原点
                if (0 == NeddleUp(MENU_CURSOR))
                    break;

                if (g_GreatPatType == 1)
                { //三菱
                    if (g_line_sum)
                    {
                        if (g_feed_sew)
                        { // 缝纫标志
                            SREG[g_draw_p++] = 0x201;
                            SREG[g_draw_p++] = 0;
                            SREG[g_draw_p++] = 0;
                            SREG[g_draw_p++] = 0;
                            SREG[g_line_p++] = g_line_sum++;
                            SREG[g_pat_p++] = 0x2;
                            SREG[g_pat_p++] = 0;
                            g_feed_sew = 0; // 空送标志
                        }
                        g_dxpos = -g_oxpos;
                        g_dypos = -g_oypos;
                        if (g_home_2flag)
                        {
                            g_dxpos += g_home_2xpos;
                            g_dypos += g_home_2ypos;
                        }
                        g_feed_flag = 0;
                        if ((g_dxpos) || (g_dypos))
                        {
                            Mit_Create_Data(1);
                            Send_Pfoot(1, MENU_CURSOR, 1);
                            Comm_Move(g_oxpos, g_oypos, 120, MENU_CURSOR, 0, 0);
                        }
                    }
                    pno = MENU_CURSOR;
                    pnoindex = 2;
                }
                else if (g_GreatPatType == 2)
                { //兄弟
                    g_Ctstaddr = g_Ctendaddr;

                    if (1 == Bor_dofeedOrg((U16 *)SREG, (U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen))
                    {
                        g_modifyflag |= 1;
                    }

                    g_dxpos = 0;
                    g_dypos = 0;
                    g_disxpos = 0;
                    g_disypos = 0;
                    g_ct_status_flag = 0;
                    g_feedsum = g_patd.feed_sum;
                    g_feedc = g_patd.feed_sum;

                    g_Ctstaddr = g_Ctendaddr;
                    Bor_doEndcmd((U16 *)SREG, (U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, &g_patd.feed_sum);
                    HREG[5] = (g_CtPatLen >> 16) & 0xffff;
                    HREG[4] = g_CtPatLen & 0xffff;

                    Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                    Comm_Move(g_patd.orgX, g_patd.orgY, 120, MENU_CURSOR, 1, 1);
                    g_jog_point = 0;
                    g_BorSTflag = 1;
                    pno = MENU_INHELP;
                    hleppara = 0;
                    g_endtype = 1;
                }
                //					g_isBAT = 0;	//清除跳缝标志
                break;

            case KEY_INMENU_NUM:
                pno = MENU_CURSOR;
                pnoindex = 2;
                if (g_num_mov_key)
                    g_num_mov_key = 0;
                else
                    g_num_mov_key = 1;
                break;

            case KEY_INMENU_MODIFY:
                tmppnoindex = pnoindex;

                if (g_feedsum == 0)
                {
                    pno = MENU_RWHELP;
                    hleppara = 113;
                    poldno[pnoindex] = MENU_CURSOR;
                    pnoindex++;
                    break;
                }

                //清除备份缓冲
                for (i = 0; i < MAXBLIND; i++)
                {
                    BLKIND[i] = 0;
                }
                for (i = 0; i < MAXBLKBUF; i++)
                {
                    BLKBUF[i] = 0;
                }
                g_modcordflag = 0;
                if (g_GreatPatType == 1)
                { //三菱
                    //先回到原点
                    if (P_FHP)
                    {
                        g_jog_point = g_feedsum;
                        Go_Home(MENU_CURSOR, 2); //0
                    }

                    //合并为花样数据
                    add1 = SREG[g_draw_p - 4];
                    add2 = SREG[g_pat_p - 2];
                    if ((add1 != 0x1f01) && (add1 != 0x1e01) && (add2 != 0x1f) && (add2 != 0x1e))
                    {
                        SREG[g_draw_p++] = 0x1f01;
                        SREG[g_draw_p++] = 0;
                        SREG[g_draw_p++] = 0;
                        SREG[g_draw_p++] = 0;
                        SREG[g_line_p++] = g_line_sum++;
                        SREG[g_pat_p++] = 0x1f;
                        SREG[g_pat_p++] = 0;
                        g_feedc++;
                        g_feedsum++;
                    }
                    add1 = (SREG[2] + 0x40) / 2;
                    add2 = add1 + ((((U32)(SREG[5]) << 16) + SREG[4]) / 4);
                    dat2 = g_line_p - add1;
                    g_line_p = g_draw_p;
                    for (ii = 0; ii < dat2; ii++)
                    {
                        SREG[g_line_p++] = SREG[add1 + ii];
                        kk++;
                    }
                    g_pat_p = g_line_p;
                    for (ii = 0; ii < dat2; ii++)
                    {
                        SREG[g_pat_p++] = SREG[add2++];
                        SREG[g_pat_p++] = SREG[add2++];
                    }
                    // ****************************************
                    for (add2 = g_pat_p; add2 < MAXSREG; add2++)
                    {
                        SREG[add2] = 0;
                    }
                    SREG[2] = g_draw_p * 2 - 0x40;
                    SREG[4] = (U16)(dat2 * 4);
                    SREG[5] = (U16)((dat2 * 4) >> 16);

                    ///////////////////////////////////////////保存电子夹线器基准高度
                    f = Read_D(D_Address[SYS] + SYS_LFORCESET, 1, (U16 *)(&YREG[SYS_LFORCESET]));
                    //读电子夹线器基准高度
                    if (f == 0)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 15;
                        poldno[pnoindex] = MENU_CURSOR;
                        pnoindex++;
                        break;
                    }
                    SREG[0x0a] = YREG[SYS_LFORCESET];
                    ////////////////////////////////////

                    f = Read_D(D_Address[SYS] + SYS_PFOOTSET, 1, (U16 *)(&YREG[SYS_PFOOTSET]));
                    //读设定中压脚修正量
                    if (f == 0)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 15;
                        poldno[pnoindex] = MENU_CURSOR;
                        pnoindex++;
                        break;
                    }
                    SREG[0x19] = YREG[SYS_PFOOTSET] << 8;

                    i = ((SREG[2] + 0x40) / 2) + ((((U32)(SREG[5]) << 16) + SREG[4]) / 4) * 3;
                    checksum = 0;

                    for (ii = 0; ii < i; ii++)
                    {
                        if (ii != 0x20)
                            checksum += SREG[ii];
                    }
                    SREG[0x20] = checksum;

                    g_init_flag = 1;

                    //把花样数据拆分为修改模式格式
                    //g_jog_point = HREG[HREG_FEED_C];
                    g_reorigin = 0; // 不自动反回原点
                    g_jog_point = 0;
                    if ((SREG[30] & 0x00ff) != MLK_G)
                    {
                        Mit_Analyse_SplineData();
                    }
                    Mit_SaveSplPatData();
                    Mit_AnalyseDataCorrect(); //检查花样数据的正确性并校正
                    f = Mit_CreateAllData();

                    //#if Debug
                    //printf("test  ConvertMultiDraw\r\n");
                    //#endif
                    if (1 == Mit_ConvertMultiDraw())
                    {

                        f = Mit_CreateAllData();
                    }

                    g_jogmode = 1;
                    f = Read_D(D_Address[SYS] + SYS_PFOOTSET, 1, (U16 *)(&YREG[SYS_PFOOTSET]));

                    if (f == 0)
                    { //读设定中压脚修正量
                        pno = MENU_RWHELP;
                        hleppara = 15;
                        poldno[pnoindex] = MENU_CURSOR;
                        pnoindex++;
                        break;
                    }
                    g_tmp_PfootValSet = YREG[SYS_PFOOTSET]; //暂存中压脚设置值

                    g_savetimes = 0;
                    g_Tsavetimes = 0;
                    //						BackupSREG(g_Tsavetimes,0,0,0);
                }
                else if (g_GreatPatType == 2)
                { //兄弟

                    HREG[4] = (U16)(g_CtPatLen & 0xffff); //文件长度
                    HREG[5] = (U16)((g_CtPatLen >> 16) & 0xffff);
                    f = Read_D(D_Address[SYS] + SYS_PFOOTSET, 1, (U16 *)(&YREG[SYS_PFOOTSET]));

                    if (f == 0)
                    { //读设定中压脚修正量
                        pno = MENU_RWHELP;
                        hleppara = 15;
                        poldno[pnoindex] = MENU_CURSOR;
                        pnoindex++;
                        break;
                    }

                    g_tmp_PfootValSet = YREG[SYS_PFOOTSET]; //暂存中压脚设置值
                    g_Tsavetimes = 0;
                    g_savetimes = 0;
                    BackupSREG(g_Tsavetimes, 0, F_FILELEN, 1);
                }
                g_ExCode = 0;
                g_curExCode = 0;
                //					g_jog_point = 0;
                g_pointPinAng = 0;
                g_pointSetPara1 = 0;
                g_pointSetPara2 = 0;
                sendExCodeCmd();

                g_jog_point = g_patd.feed_sum;
                Go_Home(MENU_CURSOR, 1); //0

                pno = MENU_MODIFY;
                g_savetimes = 0;
                tmppnoindex = pnoindex;
                poldno[pnoindex] = MENU_CURSOR;
                pnoindex++;
                break;
            case KEY_INMENU_PITCH:
                pno = MENU_PITCH;
                break;

            case KEY_INMENU_READ:

                for (i = 0; i < MAXSREG; i++)
                { //先备份当前花样数据
                    BLKSREG[i] = SREG[i];
                    NEWSREG[i] = SREG[i];
                }
                for (i = 0; i < MAXHREG; i++)
                { //先备份当前花样文件信息
                    BLKHREG[i] = HREG[i];
                }
                g_disppicflag = 0;
                pno = MENU_CALLFILE;
                poldno[pnoindex] = MENU_CURSOR;
                pnoindex++;
                break;

            case KEY_INMENU_SKIPJOG:
                pno = MENU_SKIPJOG;
                break;

            case KEY_INMENU_LFORCE:
                pno = MENU_LINEFORCE;
                g_para0 = 2;
                break;

            case KEY_INMENU_BACKTOP:
                if ((g_temp_clr_flag == 1) && (g_feedc == 0) && (g_feedsum == 0))
                { //无任何操作,重新从主板读回数据
                    g_temp_clr_flag = 0;
                    g_ImageDis = 1;
                    g_modifyflag = 0;
                }
                if (g_modifyflag)
                {
                    if (F_FILETYPE == PAT_MIT)
                    {
                        SREG[g_draw_p++] = 0x1e01;
                        SREG[g_draw_p++] = 0;
                        SREG[g_draw_p++] = 0;
                        SREG[g_draw_p++] = 0;
                        SREG[g_line_p++] = g_line_sum++;
                        SREG[g_pat_p++] = 0x1e;
                        SREG[g_pat_p++] = 0;
                        g_NoEndCode = 1;
                    }
                    else
                    {
                        g_Ctstaddr = g_Ctendaddr;
                        Bor_doEndcmd((U16 *)SREG, (U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, &g_patd.feed_sum);
                        HREG[5] = (g_CtPatLen >> 16) & 0xffff;
                        HREG[4] = g_CtPatLen & 0xffff;
                        g_jog_point = g_patd.feed_sum;
                        HREG[5] = (g_CtPatLen >> 16) & 0xffff;
                        HREG[4] = g_CtPatLen & 0xffff;
                    }
                    hleppara = 0;
                    pnoindex = 2;
                    pno = MENU_INHELP;
                    poldno[pnoindex] = MENU_CURSOR;
                    pnoindex++;
                }
                else
                {
                    if (g_pfootd.oldbase != g_pfootd.base)
                    { //还原原来基准值
                        g_pfootd.base = g_pfootd.oldbase;
                        //设置中压脚基准值
                        f = Write_Cmd(C_PFOOTACTION, g_pfootd.base, 0);
                        Read_Status();
                        Write_Cmd2(C_PFEST, 1, 2, 0);
                        Read_Status();
                    }
                    if (g_tdtensiond.base != g_tdtensiond.oldbase)
                    { //还原原来基准值
                        g_tdtensiond.base = g_tdtensiond.oldbase;
                        f = Write_Cmd2(C_SETLFORCE, g_tdtensiond.base, 0, 0); //向主板发送保存面线张力基准值命令
                        Read_Status();
                    }
                    pno = MENU_INPUT;
                    pnoindex = 2;
                }
                g_endtype = 1;
                break;

            case KEY_INMENU_IMG:
                AnaPattern(0, g_GreatPatType, g_CtPatLen);
                pno = MENU_MOIMAGE;
                g_imgpara = MOIMAGE_CVIEW; //新增
                poldno[2] = MENU_CURSOR;   //花样显示界面
                pnoindex = 3;
                break;

            case KEY_INMENU_EXPF: //内压板伸缩
                //printf("-------------\r\n");
                if (Write_Cmd(C_ECLAMP, 0, 0) == 0)
                { //伸缩板
                    pno = MENU_RWHELP;
                    hleppara = 16;
                    poldno[2] = MENU_CURSOR;
                    pnoindex = 3;
                    break;
                }
                if (Read1_Status(10) == 0)
                {
                    pno = MENU_RWHELP;
                    hleppara = 15;
                    poldno[2] = MENU_CURSOR;
                    pnoindex = 3;
                    break;
                }
                else if (DREG[D_CMDSTATUS] != 100)
                {
                    pno = MENU_RWHELP;
                    hleppara = 16;
                    poldno[2] = MENU_CURSOR;
                    pnoindex = 3;
                    break;
                }
                break;
            }
            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            //不需要显示的按键
            //非常规按键-//绘制颜色文字按键
            //常规按键
            DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);

            keyon = 0;
            beeponf = 0;

            DrawFillRect(rect[RECT_INMENU_TIT].xpis, rect[RECT_INMENU_TIT].ypis,
                         rect[RECT_INMENU_TIT].xsize, rect[RECT_INMENU_TIT].ysize, rect[RECT_INMENU_TIT].colorB[0]); //显示回“目录模式”
            DrawFMenuStrUser(rect[RECT_INMENU_TIT].xpis,
                             rect[RECT_INMENU_TIT].ypis,
                             keybmpind[keyon].titleStr[0],
                             rect[RECT_INMENU_TIT].colorB[0], rect[RECT_INMENU_TIT].colorT[0]);
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if (Timerms > 1000)
        {
            Timerms = 0;
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1)
        {
        }
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if (pno != MENU_INMENU)
        {
            plastno = MENU_CURSOR;
            break;
        }
        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

/********************************************************/
//-----------------------------------
//返回值	0-该绘图数据有针数据和线条数据
//			1-该绘图数据没有有针数据和线条数据
//备注:有些绘图数据无对应的线条数据(中压脚/人字缝)
//	   有些多个绘图数据对应一个线条数据,需要处理一下(圆/圆弧/曲线)
U8 NoLineAndPin(U16 dat)
{
    U8 res = 0;
    switch (dat)
    {
    case 0x2001: //Z缝/多重缝
    case 0x2401: //前端倒缝
    case 0x2501: //后端倒缝
    case 0x2601: //重叠缝
    case 0x2a01: //中压脚
    case 0x01cc: //圆(开始点)
    case 0x01ce: //圆Z缝(开始点)
    case 0x19cc: //圆离边(开始点)
    case 0x19ce: //圆Z缝离边(开始点)
    case 0x09cc: //圆多重缝-空送顺向(开始点)
    case 0x09ce: //圆Z缝多重缝-空送顺向(开始点)
    case 0x11cc: //圆多重缝-空送逆向(开始点)
    case 0x11ce: //圆Z缝多重缝-空送逆向(开始点)
    case 0x89cc: //圆多重缝-缝纫顺向(开始点)
    case 0x89ce: //圆Z缝多重缝-缝纫顺向(开始点)
    case 0x91cc: //圆多重缝-缝纫逆向(开始点)
    case 0x91ce: //圆Z缝多重缝-缝纫逆向(开始点)

    case 0x01d0: //圆弧(开始点)
    case 0x01d2: //圆弧Z缝(开始点)
    case 0x19d0: //圆弧离边(开始点)
    case 0x19d2: //圆弧Z缝离边(开始点)
    case 0x09d0: //圆弧多重缝-空送顺向(开始点)
    case 0x09d2: //圆弧Z缝多重缝-空送顺向(开始点)
    case 0x11d0: //圆弧多重缝-空送逆向(开始点)
    case 0x11d2: //圆弧Z缝多重缝-空送逆向(开始点)
    case 0x89d0: //圆弧多重缝-缝纫顺向(开始点)
    case 0x89d2: //圆弧Z缝多重缝-缝纫顺向(开始点)
    case 0x91d0: //圆弧多重缝-缝纫逆向(开始点)
    case 0x91d2: //圆弧Z缝多重缝-缝纫逆向(开始点)

    case 0x01d4: //曲线(开始点)
    case 0x01d6: //曲线Z缝(开始点)
    case 0x02d4: //曲线(转折点)
    case 0x02d6: //曲线Z缝(转折点)
    case 0x19d4: //曲线离边(开始点)
    case 0x19d6: //曲线Z缝离边(开始点)
    case 0x1ad4: //曲线离边(转折点)
    case 0x1ad6: //曲线Z缝离边(转折点)
    case 0x09d4: //曲线多重缝-空送顺向(开始点)
    case 0x09d6: //曲线Z缝多重缝-空送顺向(开始点)
    case 0x0ad4: //曲线多重缝-空送顺向(转折点)
    case 0x0ad6: //曲线Z缝多重缝-空送顺向(转折点)
    case 0x11d4: //曲线多重缝-空送逆向(开始点)
    case 0x11d6: //曲线Z缝多重缝-空送逆向(开始点)
    case 0x12d4: //曲线多重缝-空送逆向(转折点)
    case 0x12d6: //曲线多重缝-空送逆向(转折点)
    case 0x89d4: //曲线多重缝-缝纫顺向(开始点)
    case 0x89d6: //曲线Z缝多重缝-缝纫顺向(开始点)
    case 0x8ad4: //曲线多重缝-缝纫顺向(转折点)
    case 0x8ad6: //曲线Z缝多重缝-缝纫顺向(转折点)
    case 0x91d4: //曲线多重缝-缝纫逆向(开始点)
    case 0x91d6: //曲线Z缝多重缝-缝纫逆向(开始点)
    case 0x92d4: //曲线多重缝-缝纫逆向(转折点)
    case 0x92d6: //曲线Z缝多重缝-缝纫逆向(转折点)
        res = 1;
        break;

    default:
        res = 0;
        break;
    }
    return res;
}

//返回值 1不需剪线
U8 NoNeedTri(U8 dat)
{
    U8 res = 0;
    switch (dat)
    {
    case 0xc4: //点
    case 0xc8: //直线
    case 0xca: //直线(Z缝)
    case 0xcc: //圆
    case 0xce: //圆(Z缝)
    case 0xd0: //圆弧
    case 0xd2: //圆弧(Z缝)
    case 0xd4: //曲线
    case 0xd6: //曲线(Z缝)
    case 0xd8: //多边形
    case 0xda: //多边形(Z缝)
        res = 1;
        break;

    default:
        res = 0;
        break;
    }
    return res;
}

/********************************************************/

//------------------------------------------------------------------------------
#define KEY_CALLFILE_SCRNSVR 1 //1 屏保
#define KEY_CALLFILE_BACK 2    //2 返回
#define KEY_CALLFILE_OK 3      //3 确认
#define KEY_CALLFILE_FLASH 4   //4 内存
#define KEY_CALLFILE_USB 5     //5 USB
#define KEY_CALLFILE_SD 6      //6 SD
#define KEY_CALLFILE_VIEWPIC 7 //7 显示当前花样信息
#define KEY_CALLFILE_PREV 8    //8 上一页
#define KEY_CALLFILE_NEXT 9    //9 下一页
#define KEY_CALLFILE_SEL1 10   //10 选框1
#define KEY_CALLFILE_SEL2 11   //11 选框2
#define KEY_CALLFILE_SEL3 12   //12 选框3
#define KEY_CALLFILE_SEL4 13   //13 选框4
#define KEY_CALLFILE_SEL5 14   //14 选框5
#define KEY_CALLFILE_SEL6 15   //15 选框6
#define KEY_CALLFILE_SEL7 16   //16 选框7
#define KEY_CALLFILE_SEL8 17   //17 选框8
#define KEY_CALLFILE_SEL9 18   //18 选框9
#define KEY_CALLFILE_SEL10 19  //19 选框10
#define KEY_CALLFILE_SEL11 20  //20 选框11
#define KEY_CALLFILE_SEL12 21  //21 选框12

#define KEY_CALLFILE_DREAD 22 //22 跳转读取
#define KEY_CALLFILE_START 23 //23 回起始点
#define KEY_CALLFILE_END 24   //24 回终止点

#define KEY_CALLFILE_MAX 25

#define RECT_CALLFILE_SEL1 1   //1 选框1
#define RECT_CALLFILE_SEL2 2   //2 选框2
#define RECT_CALLFILE_SEL3 3   //3 选框3
#define RECT_CALLFILE_SEL4 4   //4 选框4
#define RECT_CALLFILE_SEL5 5   //5 选框5
#define RECT_CALLFILE_SEL6 6   //6 选框6
#define RECT_CALLFILE_SEL7 7   //7 选框7
#define RECT_CALLFILE_SEL8 8   //8 选框8
#define RECT_CALLFILE_SEL9 9   //9 选框9
#define RECT_CALLFILE_SEL10 10 //10 选框10
#define RECT_CALLFILE_SEL11 11 //11 选框11
#define RECT_CALLFILE_SEL12 12 //12 选框12
#define RECT_CALLFILE_PAGE 13  //13 换页提示
#define RECT_CALLFILE_MOD 14   //14 模组按键框

#define RECT_CALLFILE_IMG1 15  //15 选框1
#define RECT_CALLFILE_IMG2 16  //16 选框2
#define RECT_CALLFILE_IMG3 17  //17 选框3
#define RECT_CALLFILE_IMG4 18  //18 选框4
#define RECT_CALLFILE_IMG5 19  //19 选框5
#define RECT_CALLFILE_IMG6 20  //20 选框6
#define RECT_CALLFILE_IMG7 21  //21 选框7
#define RECT_CALLFILE_IMG8 22  //22 选框8
#define RECT_CALLFILE_IMG9 23  //23 选框9
#define RECT_CALLFILE_IMG10 24 //24 选框10
#define RECT_CALLFILE_IMG11 25 //25 选框11
#define RECT_CALLFILE_IMG12 26 //26 选框12

#define RECT_CALLFILE_MAX 27

#define BMP_CALLFILE_SEL1 1   //1 选框1
#define BMP_CALLFILE_SEL2 2   //2 选框2
#define BMP_CALLFILE_SEL3 3   //3 选框3
#define BMP_CALLFILE_SEL4 4   //4 选框4
#define BMP_CALLFILE_SEL5 5   //5 选框5
#define BMP_CALLFILE_SEL6 6   //6 选框6
#define BMP_CALLFILE_SEL7 7   //7 选框7
#define BMP_CALLFILE_SEL8 8   //8 选框8
#define BMP_CALLFILE_SEL9 9   //9 选框9
#define BMP_CALLFILE_SEL10 10 //10 选框10
#define BMP_CALLFILE_SEL11 11 //11 选框11
#define BMP_CALLFILE_SEL12 12 //12 选框12

#define BMP_CALLFILE_MAX 13
//------------------------------------------
// Function   : void MENU_CALLFILE(void)
// Description: 读取花样画面
//------------------------------------------
void Menu_CtCallFile(void)
{
    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
    /****按键相关参数end****/

    /****花样序号，花样名称，花样列表相关参数begin****/
    //	U16 static tmpFno;																 //当前花样信息HREG[0]文件位置(即序号),花样序号缓存
    U16 tmpselectdisno;           //选中的花样序号缓存
                                  //	U16 temp_feed = 0xffff;															 //用于绘制针点的 当前所处针数缓存
                                  //	U16 temp_feed0 = 0xffff;														 //用于绘制针点的 上一个时刻所处的针数缓存
                                  //	U16 tmpS_2HOME = 0, oldtmpS_2HOME = 0;											 //系统状态缓存-回到原点
    U16 tmp_s_2hd = (U16)(S_2HD); //次原点位置缓存
                                  //	U8 pattern_flash = 0, data_flash = 1, jog_flash = 1;							 //pattern_flash花样图案绘制更新标志位 ，data_flash花样数据更新标志位  ，jog_flash跳针数据更新标志位
                                  //	U8 bflag = 0;																	 //0：绘制运行过得线；1：重绘超过部分的针点与线 2：重绘退回的线；3：绘制运行过的针点与线；
    // U8 tmpGroupNO = g_GroupNO, lastGroupNO = g_GroupNO;								 //当前组合模式序号，上一个组合模式序号
    tydPatternList PatternList = {1, 0, 0, 12, 0, 0, 1, 1, 1, 0, 0, 0, 0, {0}, {0}}; //花样列表参数
    /****花样序号，花样名称，花样列表相关参数end****/

    /****花样显示相关参数begin****/
    //	S16 ORG_X = 0, ORG_Y = 0;				//用于显示花样的画布中心点（LCD实际坐标） 原ORG_X = 325, ORG_Y = 262
    // S16 xo = 0, yo = 0;							 //花样数据源的中心点花样数据坐标缓存
    //	S16 xorg = 0, yorg = 0;					//花样图像的中心点坐标 转化到 屏幕的中心点坐标
    S32 /*tscale = 1 , tscale1 = 1, */ Scale = 0; //tscale：图像显示需要调整的缩放比，tscale1：最终的总缩放比，Scale：固定的缩放比
    // S16 fpx, fpy;								 //指定针点的花样数据坐标
    //	S8 tmuly = 1;							//三菱款与兄弟款的Y轴数据比，相反关系
    //	S32 vposx0 = 0, vposy0 = 0;				//上一个的指定花样点的坐标 转化到 屏幕的坐标
    //	S32 vposx, vposy;						//指定花样点的坐标 转化到 屏幕的坐标
    // S16 xtmp, ytmp;								 //倍率计算缓存

    const S16 orgListX[] = {CONVAS_ORG_PX2_1, CONVAS_ORG_PX2_2, CONVAS_ORG_PX2_3, CONVAS_ORG_PX2_4, CONVAS_ORG_PX2_5,
                            CONVAS_ORG_PX2_6, CONVAS_ORG_PX2_7, CONVAS_ORG_PX2_8, CONVAS_ORG_PX2_9, CONVAS_ORG_PX2_10,
                            CONVAS_ORG_PX2_11, CONVAS_ORG_PX2_12};
    const S16 orgListY[] = {CONVAS_ORG_PY2_1, CONVAS_ORG_PY2_2, CONVAS_ORG_PY2_3, CONVAS_ORG_PY2_4, CONVAS_ORG_PY2_5,
                            CONVAS_ORG_PY2_6, CONVAS_ORG_PY2_7, CONVAS_ORG_PY2_8, CONVAS_ORG_PY2_9, CONVAS_ORG_PY2_10,
                            CONVAS_ORG_PY2_11, CONVAS_ORG_PY2_12};
    /****花样显示相关参数end****/

    /****标志位相关参数begin****/
    U32 i, j, patlen = 0; //,ii,jj,ofesst,s
    U8 f = 0;
    U16 dlen = 0;
    U32 Staddr = 0, Endaddr = 0;
    U32 DrawLen;
    ISEWADD sewInfo = {0};
    ISEWCMD sewIcmd = {0};
    S16 Xposmax = 0, Xposmin = 0, Yposmax = 0, Yposmin = 0;
    U32 tmpaddr1 = 0;
    U8 Addtrimflag = 0; //添加剪线标志
    U8 exStflag = 0;
    U16 tmpBorcmd;
    S8 tmpBorpooft, Borpfdis;
    U8 tmp_pfoot = (U8)S_PFOOT;
    U16 tmpdraw_p = 0, tmpline_p = 0, tmpline_sum = 0, tmpdraw_p1 = 0, tmpline_p1 = 0, tmpline_sum1 = 0, tmpfeedsum = 0, tmpfeedsum1 = 0;
    U32 tmppat_p = 0, tmppat_p1 = 0;
    U16 stdraw_p = 0, stline_p = 0;
    U32 stpat_p = 0;
    U16 enddraw_p = 0, endline_p = 0;
    U32 endpat_p = 0;
    S16 x1 = 0, y1 = 0;
    U8 ch, overf = 0;
    U16 dat1;
    U16 delnums = 0, delnums1 = 0;
    U32 tmpCreatstaddr = 0, tmpCreatenaddr = 0;
    S16 tmporgX = 0, tmporgY = 0;
    U16 newhomelines = 0; //调入花样次原点线条数据
    U8 newhomeflag = 0;   //调用花样次原点
    U8 tmpinit_flag = 0;
    U16 addfeeds = 0;
    U16 drawpins = 0; //只有绘图数据的针数(中压脚)
    S16 tmppf_absval = 0;
    S8 tmppfmax = 0, tmppfmin = 0;
    U8 excode = 0;
    U8 tmp_DoTrim = 0;
    S16 tmppx, tmppy, tmpdx, tmpdy;
    U8 tmpspeed;
    U16 tfeedsum = 0;

    U8 SDFlag = 0, SDFlag1 = 0, USBFlag = 0, USBFlag1 = 0;
    U8 StPointFlag = 0, EndPointFlag = 0;

    U8 /*refresh0 = 1, refresh1 = 1,*/ refresh2 = 0, refresh4 = 1, refresh5 = 1; //refresh2更新文件选中编号， refresh4更新内存选择按钮，refresh5更新花样显示图案
    U8 /*disupdata1 = 1, disupdata2 = 0,*/ dis_updata3 = 0, dis_updata4 = 0;     //disupdata1:索引更新标志 disupdata2：当前文件所在索引位置更新标志  disupdata3：花样数据更新标志
    /****标志位相关参数end***/

    const U8 keynum = {KEY_CALLFILE_MAX};
    const KEYPAD keyd[] = {
        {0, 0, 0, 0},

        {0, 0, 128, 32},                                                             //1 屏保
        {TYPE_X1, TYPE_Y4, KEY_X1, KEY_Y1},                                          //2 返回
        {TYPE_X11, TYPE_Y4, KEY_X1, KEY_Y1},                                         //3 确认
        {TYPE_X10, TYPE_Y4, KEY_X1, KEY_Y1},                                         //4 内存
        {TYPE_X10 - KEY_X1, TYPE_Y4, KEY_X1, KEY_Y1},                                //5 USB
        {TYPE_X10 - KEY_X1 * 2, TYPE_Y4, KEY_X1, KEY_Y1},                            //6 SD
        {TYPE_X11, TYPE_Y3, KEY_X1, KEY_Y1},                                         //7 显示当前花样信息
        {TYPE_X11, TYPE_Y14, KEY_X1, KEY_Y1},                                        //8 上一页
        {TYPE_X11, TYPE_Y14 + KEY_Y1 + SAFE_DIST5 * 2 + TYPE_SIZE4, KEY_X1, KEY_Y1}, //9 下一页
        {CONVAS_PX2_1, CONVAS_PY2_1, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},             //10 选框1
        {CONVAS_PX2_2, CONVAS_PY2_2, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},             //11 选框2
        {CONVAS_PX2_3, CONVAS_PY2_3, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},             //12 选框3
        {CONVAS_PX2_4, CONVAS_PY2_4, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},             //13 选框4
        {CONVAS_PX2_5, CONVAS_PY2_5, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},             //14 选框5
        {CONVAS_PX2_6, CONVAS_PY2_6, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},             //15 选框6
        {CONVAS_PX2_7, CONVAS_PY2_7, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},             //16 选框7
        {CONVAS_PX2_8, CONVAS_PY2_8, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},             //17 选框8
        {CONVAS_PX2_9, CONVAS_PY2_9, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},             //18 选框9
        {CONVAS_PX2_10, CONVAS_PY2_10, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},           //19 选框10
        {CONVAS_PX2_11, CONVAS_PY2_11, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},           //20 选框11
        {CONVAS_PX2_12, CONVAS_PY2_12, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},           //21 选框12
        {TYPE_X10 - KEY_X1 * 3 - SAFE_DIST1, TYPE_Y4, KEY_X1, KEY_Y1},               //22 跳转读取
        {TYPE_X10 - KEY_X1 * 4 - SAFE_DIST1 * 2, TYPE_Y4, KEY_X1, KEY_Y1},           //23 回起始点
        {TYPE_X10 - KEY_X1 * 5 - SAFE_DIST1 * 3, TYPE_Y4, KEY_X1, KEY_Y1},           //24 回终止点
    };

    const tydDisSrcIndex keybmpind[] = {
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},
        {{KEY_Silver}, {0}, {0}, {TLFNADD_CALLFILE + 1, 0, 0, 0}, {0}},                                        //1 屏保
        {{KEY_Silver}, {0}, {72, 88}, {TLFNADD_CALLFILE + 2, 0, 0, 0}, {0}},                                   //2 返回
        {{KEY_Silver}, {0}, {71, 87}, {TLFNADD_CALLFILE + 3, 0, 0, 0}, {0}},                                   //3 确认
        {{KEY_Silver, KEY_Blue, KEY_Gray}, {0}, {257, 258, 259}, {TLFNADD_CALLFILE + 7, 0, 0, 0}, {0}},        //4 内存
        {{KEY_Silver, KEY_Blue, KEY_Gray}, {0}, {251, 252, 253}, {TLFNADD_CALLFILE + 8, 0, 0, 0}, {0}},        //5 USB
        {{KEY_Silver, KEY_Blue, KEY_Gray}, {0}, {254, 255, 256}, {TLFNADD_CALLFILE + 9, 0, 0, 0}, {0}},        //6 SD
        {{KEY_Silver, KEY_Blue, KEY_Gray}, {0}, {11, 12, 13}, {TLFNADD_CALLFILE + 6, 0, 0, 0}, {0}},           //7 显示当前花样信息
        {{KEY_Silver}, {0}, {219, 220}, {TLFNADD_CALLFILE + 10, 0, 0, 0}, {0}},                                //8 上一页
        {{KEY_Silver}, {0}, {221, 222}, {TLFNADD_CALLFILE + 11, 0, 0, 0}, {0}},                                //9 下一页
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 12, 0, 0, 0}, {0}},                            //10 选框1
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 13, 0, 0, 0}, {0}},                            //11 选框2
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 14, 0, 0, 0}, {0}},                            //12 选框3
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 15, 0, 0, 0}, {0}},                            //13 选框4
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 16, 0, 0, 0}, {0}},                            //14 选框5
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 17, 0, 0, 0}, {0}},                            //15 选框6
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 18, 0, 0, 0}, {0}},                            //16 选框7
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 19, 0, 0, 0}, {0}},                            //17 选框8
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 20, 0, 0, 0}, {0}},                            //18 选框9
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 21, 0, 0, 0}, {0}},                            //19 选框10
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 22, 0, 0, 0}, {0}},                            //20 选框11
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 23, 0, 0, 0}, {0}},                            //21 选框12
        {{KEY_Silver}, {0}, {243}, {TLFNADD_CALLFILE + 26, 0, 0, 0}, {0}},                                     //22 跳转读取
        {{KEY_Silver, KEY_Silver}, {0}, {491, 492}, {TLFNADD_CALLFILE + 24, TLFNADD_CALLFILE + 4, 0, 0}, {0}}, //23 回起始点
        {{KEY_Silver, KEY_Silver}, {0}, {493, 494}, {TLFNADD_CALLFILE + 25, TLFNADD_CALLFILE + 5, 0, 0}, {0}}, //24 回终止点
    };

    const RECTPAD rect[RECT_CALLFILE_MAX] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {TLFNADD_CALLFILE}},

        {CONVAS_PX2_1, CONVAS_PY2_1 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                                         //1 选框1
        {CONVAS_PX2_2, CONVAS_PY2_2 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                                         //2 选框2
        {CONVAS_PX2_3, CONVAS_PY2_3 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                                         //3 选框3
        {CONVAS_PX2_4, CONVAS_PY2_4 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                                         //4 选框4
        {CONVAS_PX2_5, CONVAS_PY2_5 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                                         //5 选框5
        {CONVAS_PX2_6, CONVAS_PY2_6 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                                         //6 选框6
        {CONVAS_PX2_7, CONVAS_PY2_7 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                                         //7 选框7
        {CONVAS_PX2_8, CONVAS_PY2_8 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                                         //8 选框8
        {CONVAS_PX2_9, CONVAS_PY2_9 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                                         //9 选框9
        {CONVAS_PX2_10, CONVAS_PY2_10 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                                       //10 选框10
        {CONVAS_PX2_11, CONVAS_PY2_11 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                                       //11 选框11
        {CONVAS_PX2_12, CONVAS_PY2_12 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                                       //12 选框12
        {TYPE_X11, TYPE_Y14 + KEY_Y1 + SAFE_DIST5, KEY_X1, TYPE_SIZE4, {Color_White}, {Color_Black}, {0}},                                          //13 换页提示
        {TYPE_X10 - KEY_X1 * 2 - SAFE_DIST4, TYPE_Y4 - SAFE_DIST4, KEY_X1 * 3 + SAFE_DIST1, KEY_Y1 + SAFE_DIST1, {Color_Gray}, {Color_Black}, {0}}, //14 模组按键框
        {CONVAS_PX2_1, CONVAS_PY2_1, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                                      //15 选框1
        {CONVAS_PX2_2, CONVAS_PY2_2, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                                      //16 选框2
        {CONVAS_PX2_3, CONVAS_PY2_3, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                                      //17 选框3
        {CONVAS_PX2_4, CONVAS_PY2_4, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                                      //18 选框4
        {CONVAS_PX2_5, CONVAS_PY2_5, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                                      //19 选框5
        {CONVAS_PX2_6, CONVAS_PY2_6, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                                      //20 选框6
        {CONVAS_PX2_7, CONVAS_PY2_7, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                                      //21 选框7
        {CONVAS_PX2_8, CONVAS_PY2_8, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                                      //22 选框8
        {CONVAS_PX2_9, CONVAS_PY2_9, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                                      //23 选框9
        {CONVAS_PX2_10, CONVAS_PY2_10, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                                    //24 选框10
        {CONVAS_PX2_11, CONVAS_PY2_11, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                                    //25 选框11
        {CONVAS_PX2_12, CONVAS_PY2_12, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                                    //26 选框12

    };

    const BMPPAD disBmp[BMP_CALLFILE_MAX] = {
        //icon
        {0, 0, 0, 0, {0}},

        {CONVAS_PX2_1, CONVAS_PY2_1 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //1 选框1
        {CONVAS_PX2_2, CONVAS_PY2_2 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //2 选框2
        {CONVAS_PX2_3, CONVAS_PY2_3 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //3 选框3
        {CONVAS_PX2_4, CONVAS_PY2_4 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //4 选框4
        {CONVAS_PX2_5, CONVAS_PY2_5 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //5 选框5
        {CONVAS_PX2_6, CONVAS_PY2_6 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //6 选框6
        {CONVAS_PX2_7, CONVAS_PY2_7 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //7 选框7
        {CONVAS_PX2_8, CONVAS_PY2_8 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //8 选框8
        {CONVAS_PX2_9, CONVAS_PY2_9 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //9 选框9
        {CONVAS_PX2_10, CONVAS_PY2_10 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}}, //10 选框10
        {CONVAS_PX2_11, CONVAS_PY2_11 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}}, //11 选框11
        {CONVAS_PX2_12, CONVAS_PY2_12 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}}, //12 选框12

    };
    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_CURSOR); //设置当前文字显示雷人在P1页面，对应41.bin
    InitScreen();
    initViewStatus();
    updateViewStatus();
    pat_resetPatRule();
    pat_setPatRule(PATRULES_READ);

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    if (plastno != MENU_DIRCALLFILE)
    {
        g_disk_memory = 0;
        Read_D(D_Address[SYS] + SYS_LISTTYPE, 1, (U16 *)(&YREG[SYS_LISTTYPE])); // 读主板内存索引类型
        if (YREG[SYS_LISTTYPE] != 0)                                            //当前文件索引不是主板内存 ，读回主板内存索引
        {
            ReadPatList(0, MENU_CALLFILE);
        }
    }

#if 1
    DrawLen = g_CtPatLen / 2;
    if (g_GreatPatType == 1)
    { //三菱
        tmpdraw_p = g_draw_p;
        tmpline_p = g_line_p;
        tmppat_p = g_pat_p;
        tmpline_sum = g_line_sum;
        tmpfeedsum = g_feedsum;
        tmpdraw_p1 = g_draw_p;
        tmpline_p1 = g_line_p;
        tmppat_p1 = g_pat_p;
        tmpline_sum1 = g_line_sum;
        tmpfeedsum1 = g_feedsum;
        tmpinit_flag = g_init_flag;
        g_init_flag = 1;
    }
    else if (g_GreatPatType == 2)
    { //兄弟
        tmpCreatenaddr = g_Ctendaddr;
        tmpCreatstaddr = g_Ctstaddr;
        tmpfeedsum = g_patd.feed_sum;
        tfeedsum = g_patd.feed_sum;
        tmporgX = g_patd.orgX;
        tmporgY = g_patd.orgY;
    }
#endif
    g_disppicflag = 1;
    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + rect[0].index[0] * TitleLengthMax, SheetPage, rect[0].index[0], rect[0].colorT[0]); //读取模式
    //画出方框
    for (i = 1; i < RECT_CALLFILE_MAX; i++)
    {
        if (i < RECT_CALLFILE_PAGE)
        {
            BmpFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize);
        }
        else
        {
            DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
        }
    }
    //画出按键显示
    for (i = 2; i < KEY_CALLFILE_MAX; i++)
    {
        //无效按键

        //不需要显示的按键

        if (i >= KEY_CALLFILE_SEL1 && i <= KEY_CALLFILE_SEL12) //非常规按钮
        {
            // DrawButtonDisPat(keyd[i], keybmpind[i].border[0], keybmpind[i].icon[0]);
        }
        else //常规按钮
        {
            DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
        }
    }
    //画出BMP显示
    for (i = 1; i < BMP_CALLFILE_MAX; i++)
    {
        DrawFPBMPBTN1(disBmp[i].xpis, disBmp[i].ypis, disBmp[i].xsize, disBmp[i].ysize, disBmp[i].icon[0]);
    }
    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************

    ViewPage(usepageno); //设置显示缓存
    if (ExtMemory_Status(USBTF) == 0)
    {
        USBFlag = 1;
        USBFlag1 = 1;
    }
    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    tmpselectdisno = g_Fileno;
    Timer_ms = 30720; //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        keydata = get_keydata((KEYPAD *)keyd, keynum, 0); //获取键值
        if (keydata >= KEY_CALLFILE_START && keydata <= KEY_CALLFILE_END && g_readcovnflag)
        {
            keydata = 0;
        }
        if (keydata >= KEY_CALLFILE_SEL1 && keydata <= KEY_CALLFILE_SEL12) //非常规按键
        {
            f = keydata - KEY_CALLFILE_SEL1;
            if (PatternList.selectEnable[f] == 0)
                keydata = 0;
        }
        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            //带有连续按键功能的按键
            if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {
            if (((keydata == KEY_CALLFILE_USB) && (USBFlag == 0)) || ((keydata == KEY_CALLFILE_SD) && (SDFlag == 0)))
            {
                keydata = 0;
            }
            else
            {
                if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时)
                {
                    keyon = keydata;
                    if (keyon == KEY_CALLFILE_SCRNSVR ||
                        (keyon >= KEY_CALLFILE_SEL1 && keyon <= KEY_CALLFILE_SEL12)) //无按键特效
                    {
                    }
                    //非常规按键
                    else
                    {
                        DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);
                    }
                    Times = 0;
                    delay = KEYDT; //按键防抖次数
                }
                else if (keyon != keydata) //已有按键按下，不处理新按键信息
                {
                    keydata = 0;
                }

                if (Times > delay) //按键防抖
                {
                    if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                    {
                        beeponf = 1;

                        if (g_keyBellT) //按键时蜂鸣器发声时间
                            Beep_On(g_keyBellT);

                        switch (keyon) //按键按下标题提示语显示
                        {
                        default:
                            DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                            break;
                        }

                        delay = KEYFT;
                    }
                    else if (beeponf == 1) //第二次进入
                    {
                        beeponf = 2;
                        delay = KEYNT;
                    }
                    else if (beeponf < 20)
                    {
                        beeponf++;
                    }
                    //带有长按连续功能按键的功能
                    Times = 0; //当前
                }
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            if (keyoff >= KEY_CALLFILE_SEL1 && keyoff <= KEY_CALLFILE_SEL12)
            {

                PatternList.noInPageNow = keyoff - KEY_CALLFILE_SEL1;
                PatternList.bFlashSelectFlag = 1;
            }
            else
            {
                switch (keyoff)
                {
                case KEY_CALLFILE_SCRNSVR:
                    pno = MENU_SCRNSVR;
                    break;
                case KEY_CALLFILE_BACK:
                    if (g_disk_memory != 0)
                    { //重新读回内存文件索引
                        f = ReadFileIndex(C_RDMEMPATLIST, MENU_CALLFILE);
                        if (f == 0)
                        {
                            pno = MENU_RWHELP;
                            hleppara = 15;
                            poldno[pnoindex] = MENU_CALLFILE;
                            pnoindex++;
                            break;
                        }
                        g_disk_memory = 0;
                    }

                    for (i = 0; i < MAXSREG; i++)
                    { //还原当前花样数据
                        SREG[i] = BLKSREG[i];
                    }
                    for (i = 0; i < MAXHREG; i++)
                    { //还原当前花样文件信息
                        HREG[i] = BLKHREG[i];

                        Write_Cmd(C_READMEMORYPAT, F_IND_NO, 0);
                        Read_Status();
                    }

                    if (g_readcovnflag == 0)
                    { //打板进来调用
                        if (g_GreatPatType == 1)
                        { //三菱
                            g_draw_p = tmpdraw_p;
                            g_line_p = tmpline_p;
                            g_pat_p = tmppat_p;
                            g_line_sum = tmpline_sum;
                            g_feedsum = tmpfeedsum;

                            g_pf_absval = g_pfootd.base;
                            for (i = 52000; i < g_pat_p; i += 2)
                            {
                                dat1 = SREG[i] & 0x00ff;
                                if ((dat1 == 0x61) || (dat1 == 0x41) || (dat1 == 0x21) || (dat1 == 0x1) || (dat1 == 0x1b) || (dat1 == 0x3))
                                {
                                    if ((SREG[i] & 0xff00) != 0)
                                    {
                                        g_pf_absval += (S8)(SREG[i] >> 8);
                                    }
                                }
                            }
                        }
                        else if (g_GreatPatType == 2)
                        { //兄弟
                            g_Ctendaddr = tmpCreatenaddr;
                            g_Ctstaddr = tmpCreatstaddr;
                            g_patd.feed_sum = tmpfeedsum;
                            g_patd.orgX = tmporgX;
                            g_patd.orgY = tmporgY;

                            Bor_CalPFval((U16 *)SREG, g_CtPatLen, g_Ctendaddr, (S16 *)&g_pf_absval);
                            g_pf_absval += g_pfootd.base;
                        }

                        Write_Cmd(C_PFOOTACTION, g_pf_absval, 0); //将中压脚高度设置为追后一针的高度
                        Read_Status();
                    }
                    pnoindex--;
                    pno = poldno[pnoindex];
                    break;

                case KEY_CALLFILE_OK:
#if 1
                    f = fun_getPatData(tmpselectdisno, g_disk_memory, MENU_CALLFILE);
                    if (f)
                    {
                        AnaPattern(0, F_FILETYPE, (((F_FILELENH) << 16) | F_FILELENL));
                    }
                    else
                    {
                        break;
                    }
                    wdt();
                    if (g_readcovnflag == 0) //打板进来调用
                    {
                        if (g_GreatPatType == 1)
                        { //生成为三菱

                            //							//查询原花样最后一针是否为空送或剪线，以判断在连接花样数据时是否添加剪线指令
                            //							if(((BLKSREG[tmpdraw_p-4]==0x0088)&&(BLKSREG[tmpdraw_p-3]==0x7800))||((BLKSREG[tmpdraw_p-4]==0x0201)&&(BLKSREG[tmpdraw_p-3]==0x0000))){	//结束针为空送或剪线
                            //								Addtrimflag = 0;
                            //							}else{
                            //								Addtrimflag = 1;
                            //							}
                            Addtrimflag = 0;
                            for (i = 52000; i < tmppat_p; i += 2)
                            {
                                if (((BLKSREG[i] & 0xff) == 0x61) || ((BLKSREG[i] & 0xff) == 0x41) || ((BLKSREG[i] & 0xff) == 0x21) || ((BLKSREG[i] & 0xff) == 0x01))
                                { //缝纫 需要剪线
                                    Addtrimflag = 1;
                                }
                                else if (((BLKSREG[i] & 0xff) == 0x03) || ((BLKSREG[i] & 0xff) == 0x1b) || ((BLKSREG[i] & 0xff) == 0x07))
                                { //空送或跳缝 不需要剪线
                                    Addtrimflag = 0;
                                }
                            }

                            if (F_FILETYPE == PAT_SEW)
                            { //兄弟 转为三菱类型
                                if (Bor_To_Mit(patlen * 2) == 0)
                                { //转换失败  数据超范围
                                    for (i = 0; i < MAXSREG; i++)
                                    { //还原当前花样数据
                                        SREG[i] = BLKSREG[i];
                                        NEWSREG[i] = BLKSREG[i];
                                    }
                                    for (i = 0; i < MAXHREG; i++)
                                    { //还原当前花样文件信息
                                        HREG[i] = BLKHREG[i];
                                    }
                                    wdt();
                                    g_draw_p = tmpdraw_p;
                                    g_line_p = tmpline_p;
                                    g_pat_p = tmppat_p;
                                    g_line_sum = tmpline_sum;
                                    g_feedsum = tmpfeedsum;
                                    hleppara = 120;
                                    pno = MENU_RWHELP;
                                    poldno[pnoindex] = MENU_CALLFILE;
                                    pnoindex++;
                                    break;
                                }

                                AnaPattern(0, PAT_MIT, 0);
                                memset((U8 *)NEWSREG, 0, sizeof(NEWSREG));
                                for (i = 0; i < MAXSREG; i++)
                                {
                                    NEWSREG[i] = BLKSREG[i];
                                }
                            }

                            wdt();
                            if (g_disk_memory && (F_FILETYPE != 2))
                            {
                                for (i = 0; i < MAXSREG; i++)
                                {
                                    NEWSREG[i] = BLKSREG[i];
                                }
                            }

                            for (i = 0; i < MAXHREG; i++)
                            { //还原当前花样文件信息
                                HREG[i] = BLKHREG[i];
                            }

                            stdraw_p = g_patd.draw_add;
                            stline_p = g_patd.line_add;
                            stpat_p = g_patd.pat_add;

                            enddraw_p = g_draw_p;
                            endline_p = g_line_p;
                            endpat_p = g_pat_p;
                            delnums = 0;
                            //计算起点数据地址
                            if (StPointFlag)
                            { //保留原点到起针点的移送
                                for (i = g_patd.draw_add; i < g_draw_p; i += 4)
                                { //调用图型有次原点的话,不要次原点
                                    if ((SREG[i] == 0x0601) && (SREG[i + 1] == 0x0))
                                    { //次原点
                                        newhomeflag = 1;
                                        break;
                                    }
                                    newhomelines++;
                                }
                            }
                            else
                            { //清除原点到起针点的移送

                                //绘图数据
                                for (i = g_patd.draw_add; i < g_draw_p; i += 4)
                                {
                                    if ((SREG[i] != 0x0088) || (SREG[i + 1] != 0x7800))
                                    {
                                        break;
                                    }
                                }
                                if ((SREG[i] == 0x0601) && (SREG[i + 1] == 0x0))
                                { //次原点
                                    stdraw_p = i + 4;
                                }
                                else
                                {
                                    stdraw_p = i;
                                }
                                delnums = (stdraw_p - g_patd.draw_add) / 4;

                                for (i = g_patd.line_add; i < g_line_p; i++)
                                { //线条数据
                                    if (SREG[i] == delnums)
                                    {
                                        stline_p = i;
                                        break;
                                    }
                                }

                                stpat_p = (stline_p - g_patd.line_add) * 2 + g_patd.pat_add; //针数据
                            }

                            wdt();

                            for (i = 0; i < (enddraw_p - stdraw_p); i += 4)
                            { //绘图数据 查找插入图像第一针数据是空送还是缝纫.

                                if ((SREG[stdraw_p + i] == 0x0088) && (SREG[stdraw_p + i + 1] == 0x7800))
                                {
                                    break;
                                }
                                else
                                {
                                    if (NoNeedTri((SREG[stdraw_p + i] & 0xff)))
                                    { //缝纫
                                        if (Addtrimflag)
                                        { //不需要剪线连接
                                            Addtrimflag = 0;
                                        }
                                        break;
                                    }
                                }
                            }

                            wdt();
                            //计算结束点数据地址
                            if (EndPointFlag)
                            { //保留结束点空送
                                for (i = g_patd.draw_add; i < g_draw_p; i += 4)
                                { //绘图数据
                                    if (((SREG[i] == 0x1e01) && (SREG[i + 1] == 0x0)) || ((SREG[i] == 0x1f01) && (SREG[i + 1] == 0x0)))
                                    {
                                        break;
                                    }

                                    if (NoLineAndPin(SREG[i]))
                                    {
                                        drawpins++;
                                    }
                                }
                                enddraw_p = i;
                                if (SREG[enddraw_p - 4] == 0x0201)
                                { //剪线  删除
                                    enddraw_p -= 4;
                                }
                                delnums1 = (enddraw_p - 4 * drawpins - g_patd.draw_add) / 4;

                                for (i = g_patd.line_add; i < g_line_p; i++)
                                { //线条数据
                                    if (SREG[i] == delnums1)
                                    {
                                        endline_p = i;
                                        break;
                                    }
                                }
                                endpat_p = (endline_p - g_patd.line_add) * 2 + g_patd.pat_add; //针数据

                                //#if Debug
                                //	printf("delnums1 = %d  enddraw_p = %d  endline_p = %d  endpat_p = %d\r\n",delnums1,enddraw_p,endline_p,endpat_p);
                                //#endif
                            }
                            else
                            { //清除结束点空送
                                for (i = g_patd.draw_add; i < g_draw_p; i += 4)
                                { //绘图数据
                                    if (((SREG[i] == 0x1e01) && (SREG[i + 1] == 0x0)) || ((SREG[i] == 0x1f01) && (SREG[i + 1] == 0x0)))
                                    {
                                        break;
                                    }
                                    if (((SREG[i] == 0x0088) && (SREG[i + 1] == 0x7800)) || (SREG[i] == 0x0201))
                                    { //空送或剪线不记录
                                    }
                                    else
                                    {
                                        enddraw_p = i + 4;
                                    }

                                    if (NoLineAndPin(SREG[i]))
                                    {
                                        drawpins++;
                                    }
                                }

                                if (SREG[enddraw_p - 4] == 0x0201)
                                { //剪线  删除
                                    enddraw_p -= 4;
                                }
                                delnums1 = (enddraw_p - 4 * drawpins - g_patd.draw_add) / 4;
                                for (i = g_patd.line_add; i < g_line_p; i++)
                                { //线条数据
                                    if (SREG[i] == delnums1)
                                    {
                                        endline_p = i;
                                        break;
                                    }
                                }
                                endpat_p = (endline_p - g_patd.line_add) * 2 + g_patd.pat_add; //针数据

                                //#if Debug
                                //	printf("delnums1 = %d  enddraw_p = %d  endline_p = %d  endpat_p = %d\r\n",delnums1,enddraw_p,endline_p,endpat_p);
                                //#endif
                            }

                            wdt();
                            if (Addtrimflag)
                            { //添加一针剪线
                                NEWSREG[tmpdraw_p1++] = 0x0201;
                                NEWSREG[tmpdraw_p1++] = 0x0;
                                NEWSREG[tmpdraw_p1++] = 0x0;
                                NEWSREG[tmpdraw_p1++] = 0x0;

                                NEWSREG[tmpline_p1++] = tmpline_sum /* + Addtrimflag*/;

                                NEWSREG[tmppat_p1++] = 0x0002;
                                NEWSREG[tmppat_p1++] = 0x0;

                                addfeeds++;
                                tmpline_sum1++;
                            }

                            wdt();
                            for (i = 0; i < (enddraw_p - stdraw_p); i += 4)
                            { //绘图数据
                                if ((SREG[stdraw_p + i] == 0x0601) && (SREG[stdraw_p + i + 1] == 0x0))
                                { //次原点 不要
                                    continue;
                                }
                                NEWSREG[tmpdraw_p1++] = SREG[stdraw_p + i];
                                NEWSREG[tmpdraw_p1++] = SREG[stdraw_p + i + 1];
                                NEWSREG[tmpdraw_p1++] = SREG[stdraw_p + i + 2];
                                NEWSREG[tmpdraw_p1++] = SREG[stdraw_p + i + 3];
                            }

                            wdt();
                            for (i = 0; i < (endline_p - stline_p); i++)
                            { //线条数据
                                if ((newhomeflag == 1) && (SREG[stline_p + i] == newhomelines))
                                { //次原点 不要
                                    delnums++;
                                    continue;
                                }
                                NEWSREG[tmpline_p1++] = SREG[stline_p + i] - delnums + tmpline_sum + Addtrimflag;
                                if (i == 0)
                                {
                                    tmpline_sum1++;
                                }
                                else
                                {
                                    if (SREG[stline_p + i] != SREG[stline_p + i - 1])
                                    {
                                        tmpline_sum1++;
                                    }
                                }
                            }

                            wdt();
                            for (i = 0; i < (endpat_p - stpat_p); i += 2)
                            { //针数据
                                if (SREG[stpat_p + i] == 0x0006)
                                { //次原点 不要
                                    addfeeds--;
                                    continue;
                                }
                                NEWSREG[tmppat_p1++] = SREG[stpat_p + i];
                                NEWSREG[tmppat_p1++] = SREG[stpat_p + i + 1];
                            }
                            addfeeds += (endpat_p - stpat_p) / 2;
                            wdt();
                            memset((U8 *)SREG, 0, sizeof(SREG));
                            for (i = 0; i < MAXSREG; i++)
                            { //生成花样数据
                                SREG[i] = NEWSREG[i];
                            }

                            tmpfeedsum1 += addfeeds;
                            g_draw_p = tmpdraw_p1;
                            g_line_p = tmpline_p1;
                            g_pat_p = tmppat_p1;
                            g_line_sum = tmpline_sum1;

                            g_feedsum = tmpfeedsum1;
                            g_feedc = tmpfeedsum1;
                            g_patd.feed_sum = g_feedsum;

                            overf = 0;
                            tmppf_absval = g_pfootd.base;
                            tmp_DoTrim = g_DoTrim;
                            g_DoTrim = 0;
                            g_tExCode = 0;
                            for (i = 52000; i < tmppat_p1; i += 2)
                            {
                                dat1 = SREG[i] & 0x00ff;
                                if ((dat1 == 0x61) || (dat1 == 0x41) || (dat1 == 0x21) || (dat1 == 0x1))
                                {
                                    g_DoTrim = 1;
                                }
                                else if ((dat1 == 0x1b) || (dat1 == 0x3) || (dat1 == 0x2))
                                {
                                    g_DoTrim = 0;
                                }

                                if ((dat1 == 0x05) || (dat1 == 0x0b) || (dat1 == 0x0c) || (dat1 == 0x0d) || (dat1 == 0x1d))
                                {
                                    if (dat1 == 0x05)
                                        g_tExCode ^= 0x01;
                                    else if (dat1 == 0x0b)
                                        g_tExCode ^= 0x02;
                                    else if (dat1 == 0x0c)
                                        g_tExCode ^= 0x04;
                                    else if (dat1 == 0x0d)
                                        g_tExCode ^= 0x08;
                                    else
                                    {
                                        if (SREG[i] == 0x001d)
                                            g_tExCode ^= 0x10;
                                        else if (SREG[i] == 0x011d)
                                            g_tExCode ^= 0x20;
                                        else if (SREG[i] == 0x021d)
                                            g_tExCode ^= 0x40;
                                        else if (SREG[i] == 0x031d)
                                            g_tExCode ^= 0x80;
                                    }
                                }
                                // if (SREG[3] == 7) //新增-修改原点位置//插入花样忽略原点偏移
                                // {
                                //     x1 += (S16)(SREG[6]);
                                //     y1 += (S16)(SREG[7]);
                                // }
                                if ((dat1 == 0x61) || (dat1 == 0x41) || (dat1 == 0x21) || (dat1 == 0x1) || (dat1 == 0x1b) || (dat1 == 0x3))
                                {

                                    dat1 = SREG[i + 1];
                                    ch = (U8)(dat1);
                                    if (ch >= 0x80)
                                    {
                                        ch -= 0x80;
                                        x1 -= (S16)(ch);
                                    }
                                    else
                                    {
                                        x1 += ch;
                                    }
                                    ch = (U8)((dat1 >> 8));
                                    if (ch >= 0x80)
                                    {
                                        ch -= 0x80;
                                        y1 -= (S16)(ch);
                                    }
                                    else
                                    {
                                        y1 += ch;
                                    }

                                    if ((SREG[i] & 0xff00) != 0)
                                    {
                                        tmppf_absval += (S8)(SREG[i] >> 8);
                                        if (tmppf_absval > PF_ABS_MAX || tmppf_absval < PF_ABS_MIN)
                                        { //中压脚行程超范围
                                            overf = 2;
                                            break;
                                        }
                                    }

                                    if ((x1 < g_Mac.max_xl) || (x1 > g_Mac.max_xr) || (y1 > g_Mac.max_yu) || (y1 < g_Mac.max_yd))
                                    { //图形超范围
                                        overf = 1;
                                        break;
                                    }
                                }
                            }

                            wdt();
                            if (overf)
                            { //图形超范围
                                for (i = 0; i < MAXSREG; i++)
                                { //还原当前花样数据
                                    SREG[i] = BLKSREG[i];
                                    NEWSREG[i] = BLKSREG[i];
                                }
                                g_DoTrim = tmp_DoTrim;
                                g_draw_p = tmpdraw_p;
                                g_line_p = tmpline_p;
                                g_pat_p = tmppat_p;

                                g_line_sum = tmpline_sum;
                                g_feedsum = tmpfeedsum;
                                g_feedc = g_feedsum;
                                g_patd.feed_sum = g_feedsum;

                                if (overf == 1)
                                { //图像超范围
                                    hleppara = 119;
                                }
                                else
                                { //中压脚超范围
                                    hleppara = 143;
                                }

                                pno = MENU_RWHELP;
                                poldno[pnoindex] = MENU_CALLFILE;
                                pnoindex++;
                                break;
                            }
                            g_oxpos = x1;
                            g_oypos = y1;

                            if (tmp_pfoot != 0)
                            {                                    //压脚在下面
                                Send_Pfoot(1, MENU_CALLFILE, 1); //压脚升
                            }
                            Comm_Move(g_oxpos, g_oypos, 120, MENU_CALLFILE, 0, 0);

                            //#if Debug
                            //printf("tmpfeedsum1 = %d \r\n",tmpfeedsum1);
                            //#endif
                            g_pf_absval = tmppf_absval;
                            g_updata_pf_valflg = 1;

                            Write_Cmd(C_PFOOTACTION, g_pf_absval, 0); //将中压脚高度设置为追后一针的高度
                            Read_Status();

                            g_modifyflag = 1;
                            excode = g_ExCode ^ g_tExCode;

                            g_pointPinAng = mit_getExCodeData(52000, 52000 + g_feedc * 2, 0);
                            g_pointSetPara1 = mit_getExCodeData(52000, 52000 + g_feedc * 2, 1);
                            g_pointSetPara2 = mit_getExCodeData(52000, 52000 + g_feedc * 2, 2);

                            sendExCodeCmd();

                            if (g_DoTrim == 0)
                                g_feed_sew = 0;
                            g_init_flag = tmpinit_flag;
                            AnaPattern(0, PAT_MIT, 0);
                        }
                        else if (g_GreatPatType == 2)
                        { //生成花样 兄弟

                            //查询原花样最后一针是否为空送或剪线，以判断在连接花样数据时是否添加剪线指令
                            for (i = 0; i < DrawLen; i++)
                            {
                                if ((BLKSREG[i] == 0x0ccd) && (BLKSREG[i + 3] == 0x0400))
                                {
                                    sewInfo.lenaddr = i + 1;
                                    sewInfo.pataddr = i + 6;
                                    sewInfo.ptsize = ((((BLKSREG[sewInfo.lenaddr] & 0xff) << 8) | ((BLKSREG[sewInfo.lenaddr] >> 8) & 0xff)) << 16) | (((BLKSREG[sewInfo.lenaddr + 1] & 0xff) << 8) | ((BLKSREG[sewInfo.lenaddr + 1] >> 8) & 0xff));
                                    break;
                                }
                            }
                            for (i = 0; i < sewInfo.ptsize / 2;)
                            { //查找前面是否是空送或剪线、跳缝指令，不是则添加剪线
                                f = Bor_DrawCmd((U16 *)&BLKSREG[sewInfo.pataddr + i], &sewIcmd);
                                if (f)
                                {
                                    if (((sewIcmd.cmd & 0xf000) == 0x2000) || (sewIcmd.cmd == 0xfd00) || (sewIcmd.cmd == 0xf400))
                                    {
                                        Addtrimflag = 0;
                                    }
                                    else if ((sewIcmd.cmd & 0xf000) == 0x6000)
                                    {
                                        Addtrimflag = 1;
                                    }
                                    i += sewIcmd.off;
                                }
                                else
                                {
                                    i++;
                                }
                            }
                            if (g_patd.feed_sum == 0)
                            {
                                Addtrimflag = 0;
                            }

                            //#if Debug
                            //printf("DrawPatCmd = %04x  len = %d pataddr = %d F_FILETYPE = %d\r\n",DrawPatCmd,len,pataddr,F_FILETYPE);
                            //#endif
                            wdt();
                            if (F_FILETYPE == PAT_MIT)
                            { //三菱 转为兄弟类型
                                Mit_To_Bor(&patlen);
                                patlen /= 2;
                                memset((U8 *)NEWSREG, 0, sizeof(NEWSREG));
                                for (i = 0; i < MAXSREG; i++)
                                {
                                    NEWSREG[i] = BLKSREG[i];
                                }
                            }
                            wdt();
                            if (g_disk_memory && (F_FILETYPE != 1))
                            {
                                for (i = 0; i < MAXSREG; i++)
                                {
                                    NEWSREG[i] = BLKSREG[i];
                                }
                            }

                            for (i = 0; i < MAXHREG; i++)
                            { //还原当前花样文件信息
                                HREG[i] = BLKHREG[i];
                            }
                            wdt();
                            //计算需要连接的花样数据
                            Bor_AnaInfo((U16 *)SREG, patlen * 2, &sewInfo);

                            g_patd.orgX = ((SREG[sewInfo.orgaddr] & 0xff) << 8) | ((SREG[sewInfo.orgaddr] >> 8 & 0xff));
                            g_patd.orgY = ((SREG[sewInfo.orgaddr + 1] & 0xff) << 8) | ((SREG[sewInfo.orgaddr + 1] >> 8 & 0xff));

                            //#if Debug
                            //printf("len = %d pataddr = %d  patlen = %d\r\n",len,pataddr,patlen);
                            //#endif

                            exStflag = 0;
                            Staddr = sewInfo.pataddr;
                            Endaddr = Staddr + sewInfo.ptsize / 2;

                            wdt();
                            //计算起点数据地址
                            if (StPointFlag)
                            { //保留原点到起针点的移送

                                Staddr = sewInfo.pataddr;
                                if ((g_patd.orgX != 0) || (g_patd.orgY != 0))
                                {
                                    exStflag = 1;
                                }
                                else
                                {
                                    if ((SREG[Staddr] & 0xf0) != 0x20)
                                        Addtrimflag = 0; //不是空送，不需添加剪线
                                }
                            }
                            else
                            { //清除原点到起针点的移送
                                if ((g_patd.orgX != 0) || (g_patd.orgY != 0))
                                {
                                    Staddr = sewInfo.pataddr;
                                    if ((SREG[Staddr] & 0xf0) != 0x20)
                                        Addtrimflag = 0; //不是空送，不需添加剪线
                                }
                                else
                                {
                                    for (i = 0; i < sewInfo.ptsize / 2;)
                                    {
                                        f = Bor_DrawCmd((U16 *)&SREG[sewInfo.pataddr + i], &sewIcmd);
                                        if (f)
                                        {
                                            if (((sewIcmd.cmd & 0xf000) != 0x2000) && (sewIcmd.cmd != 0xfd00) && (sewIcmd.cmd != 0xf400))
                                            {
                                                break;
                                            }
                                            i += sewIcmd.off;
                                            Staddr = sewInfo.pataddr + i;
                                        }
                                        else
                                        {
                                            i++;
                                        }
                                    }
                                    Addtrimflag = 0;
                                }
                            }
                            wdt();
                            //计算结束点数据地址
                            if (EndPointFlag)
                            { //保留结束点空送
                                for (i = 0; i < sewInfo.ptsize / 2;)
                                {
                                    f = Bor_DrawCmd((U16 *)&SREG[sewInfo.pataddr + i], &sewIcmd);
                                    if (f)
                                    {
                                        if (sewIcmd.cmd != 0xff00)
                                        {
                                            Endaddr = sewInfo.pataddr + i + sewIcmd.off;
                                        }
                                        else
                                            break;
                                        i += sewIcmd.off;
                                    }
                                    else
                                    {
                                        i++;
                                    }
                                }
                            }
                            else
                            { //清除结束点空送
                                for (i = 0; i < sewInfo.ptsize / 2;)
                                {
                                    f = Bor_DrawCmd((U16 *)&SREG[sewInfo.pataddr + i], &sewIcmd);
                                    if (f)
                                    {
                                        if (((sewIcmd.cmd & 0xf000) != 0x2000) && (sewIcmd.cmd != 0xfd00) && (sewIcmd.cmd != 0xff00))
                                        {
                                            Endaddr = sewInfo.pataddr + i + sewIcmd.off;
                                        }
                                        i += sewIcmd.off;
                                    }
                                    else
                                    {
                                        i++;
                                    }
                                }
                            }

                            dlen = Endaddr - Staddr + (exStflag == 1 ? 4 : 0) + Addtrimflag;
                            g_Ctstaddr = g_Ctendaddr;
                            tmpaddr1 = g_Ctstaddr;
                            for (i = 0; i < (DrawLen - g_Ctstaddr); i++)
                            { //数据后移8或9个字节长度
                                NEWSREG[DrawLen - 1 - i + dlen] = NEWSREG[DrawLen - 1 - i];
                                //#if Debug
                                //printf("BLKSREG[%d] = %04x   \r\n",DrawLen-1-i+dlen,NEWSREG[DrawLen-1-i+dlen]) ;
                                //#endif
                            }

                            if (Addtrimflag)
                            { //添加剪线指令
                                NEWSREG[g_Ctstaddr] = 0x00fd;
                                g_Ctstaddr += Addtrimflag;
                            }

                            if (exStflag)
                            {
                                if (g_patd.orgX >= 0)
                                { //X+
                                    if ((g_patd.orgY) >= 0)
                                    { //Y+
                                        NEWSREG[g_Ctstaddr] = (((abs(g_patd.orgX) >> 8) & 0xff) << 8) | 0x22;
                                        NEWSREG[g_Ctstaddr + 1] = ((abs(g_patd.orgX) & 0xff) << 8) | 0x00;
                                        NEWSREG[g_Ctstaddr + 2] = (((abs(g_patd.orgY) >> 8) & 0xff) << 8) | 0x0A;
                                        NEWSREG[g_Ctstaddr + 3] = ((abs(g_patd.orgY) & 0xff) << 8) | 0x08;
                                    }
                                    else
                                    { //Y-
                                        NEWSREG[g_Ctstaddr] = (((abs(g_patd.orgX) >> 8) & 0xff) << 8) | 0x22;
                                        NEWSREG[g_Ctstaddr + 1] = ((abs(g_patd.orgX) & 0xff) << 8) | 0x00;
                                        NEWSREG[g_Ctstaddr + 2] = (((abs(g_patd.orgY) >> 8) & 0xff) << 8) | 0x0E;
                                        NEWSREG[g_Ctstaddr + 3] = ((abs(g_patd.orgY) & 0xff) << 8) | 0x0C;
                                    }
                                }
                                else
                                { //X-
                                    if (g_patd.orgY >= 0)
                                    { //Y+
                                        NEWSREG[g_Ctstaddr] = (((abs(g_patd.orgX) >> 8) & 0xff) << 8) | 0x26;
                                        NEWSREG[g_Ctstaddr + 1] = ((abs(g_patd.orgX) & 0xff) << 8) | 0x04;
                                        NEWSREG[g_Ctstaddr + 2] = (((abs(g_patd.orgY) >> 8) & 0xff) << 8) | 0x0A;
                                        NEWSREG[g_Ctstaddr + 3] = ((abs(g_patd.orgY) & 0xff) << 8) | 0x08;
                                    }
                                    else
                                    { //Y-
                                        NEWSREG[g_Ctstaddr] = (((abs(g_patd.orgX) >> 8) & 0xff) << 8) | 0x26;
                                        NEWSREG[g_Ctstaddr + 1] = ((abs(g_patd.orgX) & 0xff) << 8) | 0x04;
                                        NEWSREG[g_Ctstaddr + 2] = (((abs(g_patd.orgY) >> 8) & 0xff) << 8) | 0x0E;
                                        NEWSREG[g_Ctstaddr + 3] = ((abs(g_patd.orgY) & 0xff) << 8) | 0x0C;
                                    }
                                }
                                g_Ctstaddr += 4;
                            }
                            for (i = 0; i < (Endaddr - Staddr); i++)
                            {
                                NEWSREG[g_Ctstaddr + i] = SREG[Staddr + i];
                                //#if Debug
                                //printf("NEWSREG[%d] = %04x   \r\n",g_Ctstaddr+i,NEWSREG[g_Ctstaddr+i]) ;
                                //#endif
                            }

                            memset((U8 *)SREG, 0, sizeof(SREG));
                            for (i = 0; i < MAXSREG; i++)
                            { //生成花样数据
                                SREG[i] = NEWSREG[i];
                            }

                            DrawLen += dlen;
                            Bor_AnaInfo((U16 *)SREG, DrawLen * 2, &sewInfo);

                            sewInfo.ptsize += 2 * dlen;
                            SREG[sewInfo.lenaddr] = (((sewInfo.ptsize >> 16) & 0xff) << 8) | ((sewInfo.ptsize >> 24) & 0xff);
                            SREG[sewInfo.lenaddr + 1] = (((sewInfo.ptsize >> 0) & 0xff) << 8) | ((sewInfo.ptsize >> 8) & 0xff);

                            g_patd.orgX = ((SREG[sewInfo.orgaddr] & 0xff) << 8) | ((SREG[sewInfo.orgaddr] >> 8 & 0xff));
                            g_patd.orgY = ((SREG[sewInfo.orgaddr + 1] & 0xff) << 8) | ((SREG[sewInfo.orgaddr + 1] >> 8 & 0xff));

                            overf = 0;

                            Bor_CalPFlimt((U16 *)&SREG, DrawLen * 2, &tmppfmax, &tmppfmin); //计算中压脚极限
                            //#if Debug
                            //printf("tmppfmax = %d  tmppfmin = %d \r\n",tmppfmax,tmppfmin);
                            //#endif
                            if ((tmppfmax + g_pfootd.base > PF_ABS_MAX) || (tmppfmax + g_pfootd.base < PF_ABS_MIN) || (tmppfmin + g_pfootd.base > PF_ABS_MAX) || (tmppfmin + g_pfootd.base < PF_ABS_MIN))
                            {
                                overf = 2;
                            }
                            //计算修改后花样范围
                            Bor_CalPatLim((U16 *)SREG, DrawLen * 2, &Xposmax, &Xposmin, &Yposmax, &Yposmin, &g_patd.feed_sum);

                            g_ctAddpins = g_patd.feed_sum - tfeedsum;
                            SREG[sewInfo.limaddr] = (((Xposmax)&0xff) << 8) | ((((Xposmax) >> 8) & 0xff));
                            SREG[sewInfo.limaddr + 1] = (((Xposmin)&0xff) << 8) | ((((Xposmin) >> 8) & 0xff));
                            SREG[sewInfo.limaddr + 2] = (((Yposmax)&0xff) << 8) | ((((Yposmax) >> 8) & 0xff));
                            SREG[sewInfo.limaddr + 3] = (((Yposmin)&0xff) << 8) | ((((Yposmin) >> 8) & 0xff));

                            if (DrawLen > MAXSREG)
                            {
                                overf = 3;
                            }
                            if ((Xposmax > 2 * g_Mac.max_xr) || (Xposmin < 2 * g_Mac.max_xl) || (Yposmax > 2 * g_Mac.max_yu) || (Yposmin < 2 * g_Mac.max_yd) || (DrawLen > MAXSREG))
                            {
                                overf = 1;
                            }

                            if (overf)
                            {
                                for (i = 0; i < MAXSREG; i++)
                                { //还原当前花样数据
                                    SREG[i] = BLKSREG[i];
                                    NEWSREG[i] = BLKSREG[i];
                                    //#if Debug
                                    //if(i<g_CtPatLen/2)
                                    //printf("ss SREG[%d] = %04x \r\n",i,SREG[i]);
                                    //#endif
                                }

                                g_Ctendaddr = tmpCreatenaddr;
                                g_Ctstaddr = tmpCreatstaddr;
                                g_patd.feed_sum = tmpfeedsum;
                                g_patd.orgX = tmporgX;
                                g_patd.orgY = tmporgY;

                                if (overf == 3)
                                    hleppara = 120;
                                else if (overf == 2)
                                    hleppara = 143;
                                else
                                    hleppara = 119;
                                pno = MENU_RWHELP;
                                poldno[pnoindex] = MENU_CALLFILE;
                                pnoindex++;
                                break;
                            }
                            if (g_ct_insert_flag == 2)
                            {
                                g_modifyflag = 1;
                                g_Ctendaddr += dlen;
                                g_CtPatLen = 2 * DrawLen;
                                g_feedsum = g_patd.feed_sum;

                                //空送回原来位置
                                //Bor_feedInfo(g_patd.feed_sum,g_CtPatLen,&tmpBorcmd,(S16*)&g_oxpos,(S16*)&g_oypos,(S16*)&g_dxpos,(S16*)&g_dypos,(U8*)&g_oldspeed,&tmpBorpooft,&Borpfdis);  //查找当前原花样结束点坐标
                                Bor_feedInfo(g_feedc + g_ctAddpins + 1, g_CtPatLen, &tmpBorcmd, &tmppx, (S16 *)&tmppy, (S16 *)&tmpdx, (S16 *)&tmpdy, &tmpspeed, &tmpBorpooft, &Borpfdis);
                                //printf("g_oxpos = %d  g_oypos = %d  tmppx = %d  tmppy = %d g_patd.feed_sum =  %d  tfeedsum = %d\r\n",g_oxpos,g_oypos,tmppx,tmppy,g_patd.feed_sum,tfeedsum);
                                if (g_oxpos != tmppx || g_oypos != tmppy)
                                {
                                    g_Ctstaddr = g_Ctendaddr;
                                    f = Bor_CreatData((U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, 0, 0, (g_oxpos - tmppx), (g_oypos - tmppy), 0, (U32 *)&g_CtPatLen, 1, 0);
                                    Bor_CalPatLim((U16 *)SREG, g_CtPatLen, &Xposmax, &Xposmin, &Yposmax, &Yposmin, &g_patd.feed_sum);
                                    //g_ctAddpins += (g_Ctendaddr-g_Ctstaddr)/4 + ((g_Ctendaddr-g_Ctstaddr)%4?1:0);
                                    //printf("- g_patd.feed_sum =  %d  tfeedsum = %d\r\n",g_patd.feed_sum,tfeedsum);
                                }
                                HREG[5] = (g_CtPatLen >> 16) & 0xffff;
                                HREG[4] = g_CtPatLen & 0xffff;
                                //printf("g_patd.patmX = %d  g_patd.patiX = %d  g_patd.patmY = %d  g_patd.patiY = %d \r\n",g_patd.patmX,g_patd.patiX,g_patd.patmY,g_patd.patiY);

                                g_patd.patmX = Xposmax;
                                g_patd.patiX = Xposmin;
                                g_patd.patmY = Yposmax;
                                g_patd.patiY = Yposmin;
                                g_Ctsavetimes = 0;
                                g_blkInset = 0;
                                g_Ctstaddr = sew_getPinAddr((U16 *)SREG, g_CtPatLen, g_feedc, 1);
                                //printf("--g_patd.patmX = %d  g_patd.patiX = %d  g_patd.patmY = %d  g_patd.patiY = %d \r\n",g_patd.patmX,g_patd.patiX,g_patd.patmY,g_patd.patiY);
                                Bor_CreatBack((U16 *)&g_Ctsavetimes, g_Ctstaddr, g_Ctstaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);

                                g_ct_status_flag = 0x7cfdf;
                                g_ct_status_flag |= bit19;
                                g_feedsum = g_patd.feed_sum;

                                g_array4[0][0] = 0;
                                g_point_num = 1;
                                g_ct_insert_flag = 3;
                            }
                            else
                            {
                                Bor_feedInfo(g_patd.feed_sum, g_CtPatLen, &tmpBorcmd, (S16 *)&g_oxpos, (S16 *)&g_oypos, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &tmpBorpooft, &Borpfdis); //查找当前原花样结束点坐标
                                                                                                                                                                                                       //								g_isBAT = 0;	//清除跳缝标志
                                excode = g_ExCode ^ g_tExCode;
                                sendExCodeCmd();

                                if (tmp_pfoot != 0)
                                {                                    //压脚在下面
                                    Send_Pfoot(1, MENU_CALLFILE, 1); //压脚升
                                }
                                Comm_Move(g_oxpos + g_dxpos, g_oypos + g_dypos, 120, MENU_CALLFILE, 1, 0);

                                g_patd.patmX = Xposmax;
                                g_patd.patiX = Xposmin;
                                g_patd.patmY = Yposmax;
                                g_patd.patiY = Yposmin;

                                g_oxpos += g_dxpos;
                                g_oypos += g_dypos;
                                g_disxpos = g_oxpos;
                                g_disypos = g_oypos;
                                g_dxpos = 0;
                                g_dypos = 0;
                                g_feedsum = g_patd.feed_sum;
                                g_feedc = g_patd.feed_sum;

                                g_modifyflag = 1;
                                g_Ctendaddr += dlen;
                                g_CtPatLen = 2 * DrawLen;
                                HREG[5] = (g_CtPatLen >> 16) & 0xffff;
                                HREG[4] = g_CtPatLen & 0xffff;

                                Bor_CreatBack((U16 *)&g_Ctsavetimes, tmpaddr1, g_Ctendaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);
                                g_ct_status_flag = 0;

                                Bor_CalPFval((U16 *)SREG, g_CtPatLen, g_Ctendaddr, (S16 *)&g_pf_absval);
                                g_pf_absval += g_pfootd.base;
                                //							g_pf_absval = tmppfmax+g_pfootd.base;
                                g_updata_pf_valflg = 1;
                                Write_Cmd(C_PFOOTACTION, g_pf_absval, 0); //将中压脚高度设置为追后一针的高度
                                Read_Status();
                            }
                        }
                        if (g_disk_memory != 0)
                        { //重新读回内存文件索引
                            f = ReadFileIndex(C_RDMEMPATLIST, MENU_CALLFILE);
                            if (f == 0)
                            {
                                pno = MENU_RWHELP;
                                hleppara = 15;
                                poldno[pnoindex] = MENU_CALLFILE;
                                pnoindex++;
                                break;
                            }
                            g_disk_memory = 0;
                        }
                        pnoindex--;
                        pno = poldno[pnoindex];

                        if (excode != 0)
                        {
                            OutputExcode(excode, pno);
                        }
                        g_maxX = g_patd.patmX;
                        g_minX = g_patd.patiX;
                        g_maxY = g_patd.patmY;
                        g_minY = g_patd.patiY;
                    }
                    else
                    {

                        if (g_GreatPatType == 1) //生成mit格式
                        {
                        }
                        else if (g_GreatPatType == 2) //生成sew格式
                        {
                            //查询原花样最后一针是否为空送或剪线，以判断在连接花样数据时是否添加剪线指令
                            for (i = 0; i < DrawLen; i++)
                            {
                                if ((BLKSREG[i] == 0x0ccd) && (BLKSREG[i + 3] == 0x0400))
                                {
                                    sewInfo.lenaddr = i + 1;
                                    sewInfo.pataddr = i + 6;
                                    sewInfo.ptsize = ((((BLKSREG[sewInfo.lenaddr] & 0xff) << 8) | ((BLKSREG[sewInfo.lenaddr] >> 8) & 0xff)) << 16) | (((BLKSREG[sewInfo.lenaddr + 1] & 0xff) << 8) | ((BLKSREG[sewInfo.lenaddr + 1] >> 8) & 0xff));
                                    break;
                                }
                            }
                            Addtrimflag = 0;
                            for (i = 0; i < sewInfo.ptsize / 2;)
                            { //查找前面是否是空送或剪线、跳缝指令，不是则添加剪线
                                f = Bor_DrawCmd((U16 *)&BLKSREG[sewInfo.pataddr + i], &sewIcmd);
                                if (f)
                                {
                                    if (((sewIcmd.cmd & 0xf000) == 0x2000) || (sewIcmd.cmd == 0xfd00) || (sewIcmd.cmd == 0xf400))
                                    {
                                        Addtrimflag = 0;
                                    }
                                    else if ((sewIcmd.cmd & 0xf000) == 0x6000)
                                    {
                                        Addtrimflag = 1;
                                    }
                                    i += sewIcmd.off;
                                }
                                else
                                {
                                    i++;
                                }
                            }
                            if (g_patd.feed_sum == 0)
                            {
                                Addtrimflag = 0;
                            }

                            if (F_FILETYPE == PAT_MIT)
                            { //三菱 转为兄弟类型
                                Mit_To_Bor(&patlen);
                                patlen /= 2;
                                memset((U8 *)NEWSREG, 0, sizeof(NEWSREG));
                                for (i = 0; i < MAXSREG; i++)
                                {
                                    NEWSREG[i] = BLKSREG[i];
                                }
                            }
                            patlen = Bor_copyImgs((U16 *)SREG, (U16 *)NEWSREG, patlen * 2);
                            //printf("patlen = %d \r\n",patlen);
                            if (patlen == 0)
                            { //失败
                                for (i = 0; i < MAXSREG; i++)
                                { //还原当前花样数据
                                    SREG[i] = BLKSREG[i];
                                    NEWSREG[i] = BLKSREG[i];
                                    //#if Debug
                                    //if(i<g_CtPatLen/2)
                                    //printf("ss SREG[%d] = %04x   overf = %d \r\n",i,SREG[i],overf);
                                    //#endif
                                }

                                g_Ctendaddr = tmpCreatenaddr;
                                g_Ctstaddr = tmpCreatstaddr;
                                g_patd.feed_sum = tmpfeedsum;
                                g_patd.orgX = tmporgX;
                                g_patd.orgY = tmporgY;

                                hleppara = 119;
                                pno = MENU_RWHELP;
                                poldno[pnoindex++] = MENU_CALLFILE;
                                break;
                            }
                            if (Addtrimflag)
                            {
                                for (i = 0; i < patlen / 2;)
                                { //生成数据第一针是否需要剪线
                                    f = Bor_DrawCmd((U16 *)&NEWSREG[i], &sewIcmd);
                                    if (f)
                                    {
                                        if (((sewIcmd.cmd & 0xf000) == 0x2000))
                                        {
                                            Addtrimflag = 1;
                                            break;
                                        }
                                        else if (((sewIcmd.cmd & 0xf000) == 0x6000) || (sewIcmd.cmd == 0xfd00) || (sewIcmd.cmd == 0xf400))
                                        {
                                            Addtrimflag = 0;
                                            break;
                                        }
                                        i += sewIcmd.off;
                                    }
                                    else
                                    {
                                        i++;
                                    }
                                }
                            }

                            memset((U8 *)SREG, 0, sizeof(SREG));
                            for (i = 0; i < patlen / 2; i++)
                            {
                                SREG[i] = NEWSREG[i];
                                //									#if Debug
                                //									printf("SREG[%d] = %04x \r\n",i,SREG[i]);
                                //									#endif
                            }
                            memset((U8 *)NEWSREG, 0, sizeof(NEWSREG));
                            wdt();

                            for (i = 0; i < MAXSREG; i++)
                            {
                                NEWSREG[i] = BLKSREG[i];
                            }
                            for (i = 0; i < MAXHREG; i++)
                            { //还原当前花样文件信息
                                HREG[i] = BLKHREG[i];
                            }
                            wdt();

                            g_Ctstaddr = g_Ctendaddr;
                            tmpaddr1 = g_Ctstaddr;
                            dlen = patlen + 2 * Addtrimflag;
                            //#if Debug
                            //printf("0 g_Ctstaddr = %d  g_Ctendaddr = %d  g_CtPatLen = %d \r\n",g_Ctstaddr,g_Ctendaddr,g_CtPatLen);
                            //#endif
                            for (i = 0; i < (DrawLen - g_Ctstaddr); i++)
                            {
                                NEWSREG[DrawLen - 1 - i + dlen / 2] = NEWSREG[DrawLen - 1 - i];
                            }
                            if (Addtrimflag)
                            {
                                NEWSREG[g_Ctstaddr] = 0x00fd; //添加剪线
                            }
                            for (i = 0; i < patlen / 2; i++)
                            {
                                NEWSREG[g_Ctstaddr + i + Addtrimflag] = SREG[i];
                            }
                            memset((U8 *)SREG, 0, sizeof(SREG));
                            //生成花样数据
                            for (i = 0; i < MAXSREG; i++)
                            {
                                SREG[i] = NEWSREG[i];
                            }
                            DrawLen += dlen / 2;
                            Bor_AnaInfo((U16 *)SREG, DrawLen * 2, &sewInfo);

                            sewInfo.ptsize += dlen;
                            SREG[sewInfo.lenaddr] = (((sewInfo.ptsize >> 16) & 0xff) << 8) | ((sewInfo.ptsize >> 24) & 0xff);
                            SREG[sewInfo.lenaddr + 1] = (((sewInfo.ptsize >> 0) & 0xff) << 8) | ((sewInfo.ptsize >> 8) & 0xff);

                            g_patd.orgX = ((SREG[sewInfo.orgaddr] & 0xff) << 8) | ((SREG[sewInfo.orgaddr] >> 8 & 0xff));
                            g_patd.orgY = ((SREG[sewInfo.orgaddr + 1] & 0xff) << 8) | ((SREG[sewInfo.orgaddr + 1] >> 8 & 0xff));

                            overf = 0;
                            Bor_CalPFlimt((U16 *)&SREG, DrawLen * 2, &tmppfmax, &tmppfmin); //计算中压脚极限

                            if ((tmppfmax + g_pfootd.base > PF_ABS_MAX) || (tmppfmax + g_pfootd.base < PF_ABS_MIN) || (tmppfmin + g_pfootd.base > PF_ABS_MAX) || (tmppfmin + g_pfootd.base < PF_ABS_MIN))
                            {
                                overf = 2;
                            }
                            //#if Debug
                            //printf("tmppfmax = %d  tmppfmin = %d  overf = %d \r\n",tmppfmax,tmppfmin,overf);
                            //#endif
                            //计算修改后花样范围
                            Bor_CalPatLim((U16 *)SREG, DrawLen * 2, &Xposmax, &Xposmin, &Yposmax, &Yposmin, &g_patd.feed_sum);

                            SREG[sewInfo.limaddr] = (((Xposmax)&0xff) << 8) | ((((Xposmax) >> 8) & 0xff));
                            SREG[sewInfo.limaddr + 1] = (((Xposmin)&0xff) << 8) | ((((Xposmin) >> 8) & 0xff));
                            SREG[sewInfo.limaddr + 2] = (((Yposmax)&0xff) << 8) | ((((Yposmax) >> 8) & 0xff));
                            SREG[sewInfo.limaddr + 3] = (((Yposmin)&0xff) << 8) | ((((Yposmin) >> 8) & 0xff));

                            //#if Debug
                            //printf("Xposmax = %d  Xposmin = %d  Yposmax = %d Yposmin = %d DrawLen = %d\r\n",Xposmax,Xposmin,Yposmax,Yposmin,DrawLen);
                            //printf("g_Mac.max_xr = %d  g_Mac.max_xl = %d  g_Mac.max_yu = %d g_Mac.max_yd = %d \r\n",g_Mac.max_xr,g_Mac.max_xl,g_Mac.max_yu,g_Mac.max_yd);
                            //#endif
                            if (DrawLen > MAXSREG)
                            {
                                overf = 3;
                            }
                            if ((Xposmax > 2 * g_Mac.max_xr) || (Xposmin < 2 * g_Mac.max_xl) || (Yposmax > 2 * g_Mac.max_yu) || (Yposmin < 2 * g_Mac.max_yd) || (DrawLen > MAXSREG))
                            {
                                overf = 1;
                            }

                            if (overf)
                            {
                                for (i = 0; i < MAXSREG; i++)
                                { //还原当前花样数据
                                    SREG[i] = BLKSREG[i];
                                    NEWSREG[i] = BLKSREG[i];
                                    //#if Debug
                                    //if(i<g_CtPatLen/2)
                                    //printf("ss SREG[%d] = %04x   overf = %d \r\n",i,SREG[i],overf);
                                    //#endif
                                }

                                g_Ctendaddr = tmpCreatenaddr;
                                g_Ctstaddr = tmpCreatstaddr;
                                g_patd.feed_sum = tmpfeedsum;
                                g_patd.orgX = tmporgX;
                                g_patd.orgY = tmporgY;

                                if (overf == 3)
                                    hleppara = 120;
                                else if (overf == 2)
                                    hleppara = 143;
                                else
                                    hleppara = 119;
                                pno = MENU_RWHELP;
                                poldno[pnoindex] = MENU_CALLFILE;
                                pnoindex++;
                                break;
                            }

                            Bor_feedInfo(g_patd.feed_sum, g_CtPatLen, &tmpBorcmd, (S16 *)&g_oxpos, (S16 *)&g_oypos, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &tmpBorpooft, &Borpfdis); //查找当前原花样结束点坐标
                                                                                                                                                                                                   //								g_isBAT = 0;	//清除跳缝标志
                            excode = g_ExCode ^ g_tExCode;

                            if (tmp_pfoot != 0)
                            {                                    //压脚在下面
                                Send_Pfoot(1, MENU_CALLFILE, 1); //压脚升
                            }
                            Comm_Move(g_oxpos + g_dxpos, g_oypos + g_dypos, 120, MENU_CALLFILE, 1, 0);

                            g_patd.patmX = Xposmax;
                            g_patd.patiX = Xposmin;
                            g_patd.patmY = Yposmax;
                            g_patd.patiY = Yposmin;

                            g_oxpos += g_dxpos;
                            g_oypos += g_dypos;
                            g_disxpos = g_oxpos;
                            g_disypos = g_oypos;
                            g_dxpos = 0;
                            g_dypos = 0;
                            g_feedsum = g_patd.feed_sum;
                            g_feedc = g_patd.feed_sum;

                            g_modifyflag = 1;
                            g_Ctendaddr += dlen / 2;
                            g_CtPatLen = 2 * DrawLen;
                            HREG[5] = (g_CtPatLen >> 16) & 0xffff;
                            HREG[4] = g_CtPatLen & 0xffff;

                            Bor_CreatBack((U16 *)&g_Ctsavetimes, tmpaddr1, g_Ctendaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);
                            g_ct_status_flag = 0;

                            Bor_CalPFval((U16 *)SREG, g_CtPatLen, g_Ctendaddr, (S16 *)&g_pf_absval);
                            g_pf_absval += g_pfootd.base;
                            //							g_pf_absval = tmppfmax+g_pfootd.base;
                            g_updata_pf_valflg = 1;
                            Write_Cmd(C_PFOOTACTION, g_pf_absval, 0); //将中压脚高度设置为追后一针的高度
                            Read_Status();
                        }
                        if (g_disk_memory != 0)
                        { //重新读回内存文件索引
                            f = ReadFileIndex(C_RDMEMPATLIST, MENU_CALLFILE);
                            if (f == 0)
                            {
                                pno = MENU_RWHELP;
                                hleppara = 15;
                                poldno[pnoindex] = MENU_CALLFILE;
                                pnoindex++;
                                break;
                            }
                            g_disk_memory = 0;
                        }
                        // pnoindex = 2;
                        // pno = MENU_CURSOR;
                        pnoindex--;
                        pno = poldno[pnoindex];

                        if (excode != 0)
                        {
                            OutputExcode(excode, pno);
                        }
                        g_maxX = g_patd.patmX;
                        g_minX = g_patd.patiX;
                        g_maxY = g_patd.patmY;
                        g_minY = g_patd.patiY;

                        //#if Debug
                        //printf("1 g_Ctstaddr = %d  g_Ctendaddr = %d  g_CtPatLen = %d \r\n",g_Ctstaddr,g_Ctendaddr,g_CtPatLen);
                        //#endif
                    }
#else
                    f = fun_callFile(tmpselectdisno, StPointFlag, EndPointFlag, patlen, MENU_CALLFILE);
#endif
                    break;
                case KEY_CALLFILE_FLASH:
                    f = ReadFileIndex(C_RDMEMPATLIST, MENU_CALLFILE);
                    if (f == 0)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 15;
                        poldno[pnoindex] = MENU_CALLFILE;
                        pnoindex++;
                        break;
                    }
                    else
                    {
                        // disupdata1 = 1;//修改
                        PatternList.bflashAllFlag = 1;
                        PatternList.bFlashPageFlag = 1;
                        refresh4 = 1;
                        g_disk_memory = 0;
                        BarcodeCompare();
                    }
                    break;

                case KEY_CALLFILE_USB:
                    //Write_Cmd(C_DISK_STATUS,0,0);	//获取主板U盘插入状态
                    //for(i=0;i<FORTIMS1;i++){
                    //	Read_D(D_Address[DISP]+D_CMDSTATUS,1,(U16 *)(&DREG[D_CMDSTATUS]));
                    //	if((DREG[D_CMDSTATUS] >= 100)||(DREG[D_CMDSTATUS] == 10)){
                    //		break;
                    //	}
                    //	DelayMs(WAITTIME2);
                    //}
                    //if(DREG[D_CMDSTATUS] == 102 || DREG[D_CMDSTATUS] == 101)
                    // 	g_MboardUSB = 1;
                    //else
                    //	g_MboardUSB = 0;

                    //if(g_MboardUSB == 0){   //使用打板器U盘
                    wdt();
                    if (ExtMemory_Status(USBTF) != 0)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 95;
                        poldno[pnoindex] = MENU_CALLFILE;
                        pnoindex++;
                        ReadMemorryList(MENU_CALLFILE);
                        break;
                    }
                    Select_ExtMemory(USBTF);
                    if (Explore_Disk("0:/", 1))
                    {
                        pno = MENU_RWHELP;
                        hleppara = 40;
                        poldno[pnoindex] = MENU_CALLFILE;
                        pnoindex++;
                        ReadMemorryList(MENU_CALLFILE);
                        break;
                    }
                    //}else if(g_MboardUSB == 1){   //使用主板U盘
                    //	f = ReadFileIndex(C_RDFLAPATLIST,MENU_CALLFILE);
                    //	if(f==0){
                    //		pno = MENU_RWHELP;hleppara = 15;poldno[1] = MENU_CALLFILE;pnoindex = 2;break;
                    //	}
                    //}
                    // disupdata1 = 1;//修改
                    PatternList.bflashAllFlag = 1;
                    PatternList.bFlashPageFlag = 1;
                    refresh4 = 1;
                    g_disk_memory = 1;

                    break;

                case KEY_CALLFILE_SD:
                    //if(ExtMemory_Status(SD)!=0){
                    //	pno = MENU_RWHELP;hleppara = 95;poldno[1] = MENU_CALLFILE;pnoindex = 2;
                    //	ReadMemorryList(MENU_CALLFILE);
                    //	break;
                    //}
                    //Select_ExtMemory(SD);
                    //if(Explore_Disk ("1:/", 1)){
                    //	pno = MENU_RWHELP;hleppara = 40;poldno[1] = MENU_CALLFILE;pnoindex = 2;
                    //	ReadMemorryList(MENU_CALLFILE);
                    //	break;
                    //}
                    //disupdata1 = 1;
                    //PatternList.bFlashPageFlag = 1;
                    //refresh4 = 1;
                    //g_disk_memory = 2;
                    //BmpFillRect(keyd[KEY_CALLFILE_BAR].xpis,keyd[KEY_CALLFILE_BAR].ypis,keyd[KEY_CALLFILE_BAR].xsize,keyd[KEY_CALLFILE_BAR].ysize);
                    break;
#if 0
                case KEY_CALLFILE_VIEWPIC:
                    errorf = 0;
                    while (errorf < 3 && (tmpselectdisno >= MINFILENO && tmpselectdisno <= MAXFILENO))
                    {
                        if ((g_disk_memory == 0) /*||((g_MboardUSB == 1)&&(g_disk_memory == 1)) */) //从记忆体、主板U盘读花样文件
                        {
                            if (g_disk_memory == 0)
                                i = C_READMEMORYPAT; // 从记忆体读花样文件
                            else
                                i = C_READFLASHPAT; // 从U盘读花样文件

                            if (Write_Cmd(i, tmpselectdisno, 0) == 0)
                            {
                                pno = MENU_RWHELP;
                                hleppara = 15;
                                poldno[1] = MENU_CALLFILE;
                                pnoindex = 2;
                                break;
                            }
                            else
                            {
                                if (Read_Status() == 0)
                                {
                                    pno = MENU_RWHELP;
                                    hleppara = 15;
                                    poldno[1] = MENU_CALLFILE;
                                    pnoindex = 2;
                                    break;
                                }
                                else if (DREG[D_CMDSTATUS] == 98)
                                {
                                    //if(g_disk_memory){
                                    //	pno = MENU_RWHELP;hleppara = 2;poldno[1] = MENU_CALLFILE;pnoindex = 2;break;
                                    //}
                                }
                                else if (DREG[D_CMDSTATUS] == 99)
                                {
                                    //if(g_disk_memory==0){
                                    pno = MENU_RWHELP;
                                    hleppara = 3;
                                    poldno[1] = MENU_CALLFILE;
                                    pnoindex = 2;
                                    break;
                                    //}else{
                                    //	pno = MENU_RWHELP;hleppara = 4;poldno[1] = MENU_CALLFILE;pnoindex = 2;break;
                                    //}
                                }
                                else if (DREG[D_CMDSTATUS] < 98)
                                {
                                    pno = MENU_RWHELP;
                                    hleppara = 16;
                                    poldno[1] = MENU_CALLFILE;
                                    pnoindex = 2;
                                    break;
                                }
                                else
                                {
                                    f = Read_D(D_Address[HEAD], D_Length[HEAD], (U16 *)(&F_IND_NO)); // 读当前花样文件信息
                                    if (f == 0)
                                    {
                                        pno = MENU_RWHELP;
                                        hleppara = 15;
                                        poldno[1] = MENU_CALLFILE;
                                        pnoindex = 2;
                                        break;
                                    }
                                    else
                                    {
                                        if (tmpselectdisno != F_IND_NO)
                                        {
                                            pno = MENU_RWHELP;
                                            hleppara = 16;
                                            poldno[1] = MENU_CALLFILE;
                                            pnoindex = 2;
                                            break;
                                        }
                                        else
                                        {
                                            i = (tmpselectdisno - MINFILENO) * FileIndexSize;
                                            i = (((U32)(IREG2[i + 1]) << 16) + IREG2[i]) / 2;
                                            f = Read_D(D_Address[PTDATA], i, (U16 *)(&SREG[0]));
                                            if (f == 0)
                                            {
                                                pno = MENU_RWHELP;
                                                hleppara = 15;
                                                poldno[1] = MENU_CALLFILE;
                                                pnoindex = 2;
                                                break;
                                            }
                                            else
                                            {
                                                if ((DataCheckSum((U16 *)(&SREG[0]), i, ((((IREG2[(tmpselectdisno - MINFILENO) * FileIndexSize + FileIndexSize - 1] & 0xff00) >> 8) != 0) ? 0 : 1))) == 0)
                                                { //数据校验失败
                                                    errorf++;
                                                }
                                                else
                                                {
                                                    for (; i < MAXSREG; i++)
                                                        SREG[i] = 0;
                                                    if (g_disppicflag)
                                                        refresh5 = 1;
                                                    g_init_flag = 1;
                                                    g_data_flash = 1; // 读取花样数据
                                                    g_selectdisno = F_IND_NO;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else //读取打板器存储器设备花样
                        {
                            F_IND_NO = tmpselectdisno;
                            /*if(g_disk_memory==1)*/ Select_ExtMemory(USBTF);
                            //else Select_ExtMemory(SD);

                            if (Read_PatFile(tmpselectdisno) == 0)
                            {
                                if (g_disppicflag)
                                    refresh5 = 1;
                                g_init_flag = 1;
                                g_data_flash = 1;

                                i = (F_FILELENH << 16) + F_FILELENL;
                                g_selectdisno = F_IND_NO;
                            }
                            else
                            {
                                errorf++;
                            }
                            break;
                        }
                    }
                    if (errorf == 3)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 64;
                        poldno[1] = MENU_CALLFILE;
                        pnoindex = 2; //数据出错
                        errorf = 0;
                        break; //修改增加
                    }
                    if (S_2HD) //根据次原点信息分析显示花样的数据
                        AnaPattern(1, F_FILETYPE, (((F_FILELENH) << 16) | F_FILELENL));
                    else
                        AnaPattern(0, F_FILETYPE, (((F_FILELENH) << 16) | F_FILELENL));

                    if ((CheckDrawData(MENU_CALLFILE, 0)) == 0)
                    { //图形超范围不能进入定位
                        break;
                    }
                    g_modcordflag = 0;
                    g_modcordx = 0;
                    g_modcordy = 0;
                    g_imgpara = MOIMAGE_VIEW; //1

                    g_jogfunction1 = 1;

                    g_BorSTflag = 0;
                    g_max_feedsum = g_patd.feed_sum;
                    g_min_feedsum = 0;
                    g_jog_point = 0;
                    g_IsLocal = 1;
                    g_ImgMove = 1;
                    g_errLocal = 0;
                    g_CodeEn = 1; //显示代码
                    g_ExCode = 0;
                    g_curExCode = 0;
                    g_curPinAng = 0;
                    g_curSetPara1 = 0;
                    g_curSetPara2 = 0;
                    g_pointPinAng = 0;
                    g_pointSetPara1 = 0;
                    g_pointSetPara2 = 0;
                    pno = MENU_MOIMAGE;
                    poldno[pnoindex] = MENU_CALLFILE;
                    pnoindex++;
                    break;
#endif
                case KEY_CALLFILE_PREV:
                    if (PatternList.pageNow > 1)
                    {
                        PatternList.pageNow--;
                        PatternList.bFlashPageFlag = 1;
                    }
                    break;
                case KEY_CALLFILE_NEXT:
                    if (PatternList.pageNow < PatternList.pageNum)
                    {
                        PatternList.pageNow++;
                        PatternList.bFlashPageFlag = 1;
                    }
                    break;

                case KEY_CALLFILE_DREAD:
                    if (g_GreatPatType == 1)
                    { //三菱
                        g_draw_p = tmpdraw_p;
                        g_line_p = tmpline_p;
                        g_pat_p = tmppat_p;
                        g_line_sum = tmpline_sum;
                        g_feedsum = tmpfeedsum;
                        g_draw_p = tmpdraw_p1;
                        g_line_p = tmpline_p1;
                        g_pat_p = tmppat_p1;
                        g_line_sum = tmpline_sum1;
                        g_feedsum = tmpfeedsum1;
                        g_init_flag = tmpinit_flag;
                    }
                    else if (g_GreatPatType == 2)
                    { //兄弟
                        g_Ctendaddr = tmpCreatenaddr;
                        g_Ctstaddr = tmpCreatstaddr;
                        g_patd.feed_sum = tmpfeedsum;
                        g_patd.orgX = tmporgX;
                        g_patd.orgY = tmporgY;
                    }
                    pno = MENU_DIRCALLFILE;
                    poldno[pnoindex] = MENU_CALLFILE;
                    pnoindex++;
                    break;

                case KEY_CALLFILE_START:
                    if (StPointFlag)
                        StPointFlag = 0;
                    else
                        StPointFlag = 1;

                    dis_updata4 = 1;
                    break;

                case KEY_CALLFILE_END:
                    if (EndPointFlag)
                        EndPointFlag = 0;
                    else
                        EndPointFlag = 1;

                    dis_updata4 = 1;
                    break;
                }
            }
            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            if (keyon == KEY_CALLFILE_SCRNSVR ||
                (keyon >= KEY_CALLFILE_SEL1 && keyon <= KEY_CALLFILE_SEL12)) //无按键特效
            {
            }
            //非常规按键
            else //常规按键
            {
                DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);
            }
            keyon = 0;
            beeponf = 0;
            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4); //显示回读取模式
            Draw24x24Str(TITLE_XPOS, SAFE_DIST4, MEM_TITLE_ADD + rect[0].index[0] * TitleLengthMax, SheetPage, rect[0].index[0], rect[0].colorT[0]);
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if ((Timerms > 1000))
        {
            Timerms = 0;
            if (g_disk_memory == 1) //使用U盘
            {
                //if(g_MboardUSB==1){		//使用主板U盘
                //	Write_Cmd(C_DISK_STATUS,0,0);
                //	for(i=0;i<FORTIMS1;i++){
                //		Read_D(D_Address[DISP]+D_CMDSTATUS,1,(U16 *)(&DREG[D_CMDSTATUS]));
                //		if((DREG[D_CMDSTATUS] >= 100)||(DREG[D_CMDSTATUS] == 10)){
                //			break;
                //		}
                //		DelayMs(WAITTIME2);
                //	}
                //	if((DREG[D_CMDSTATUS] != 102) && (DREG[D_CMDSTATUS] != 101)){
                //		USBFlag =0;
                //		if((ReadMemorryList(MENU_CALLFILE)) == 0){//如选中读优盘,在退出返回时要读回内存索引表
                //			return;
                //		}
                //		g_selectdisno = g_Fileno;
                //		Write_Cmd(C_READMEMORYPAT,g_Fileno,0);
                //		RestoreSHREG(0x03);
                //		pno = MENU_RWHELP;hleppara = 95;poldno[1] = MENU_CALLFILE;pnoindex = 2;//这里有点问题
                //	}else{
                //		USBFlag =1;
                //	}
                //}else{
                if (ExtMemory_Status(USBTF) != 0) //使用打板器U盘
                {
                    USBFlag = 0;
                    hleppara = 95;
                    pno = MENU_RWHELP;
                    poldno[pnoindex] = MENU_CALLFILE;
                    pnoindex++;
                    if ((ReadMemorryList(MENU_CALLFILE)) == 0)
                    { // 如选中读优盘,在退出返回时要读回内存索引表
                        return;
                    }
                    g_selectdisno = g_Fileno;
                    Write_Cmd(C_READMEMORYPAT, g_Fileno, 0);
                    RestoreSHREG(0x03);
                }
                else
                {
                    USBFlag = 1;
                }
                //}
                //查询一下SD卡插入情况
                //if(ExtMemory_Status(SD)==0){
                //	SDFlag =1;
                //}else{
                //	SDFlag =0;
                //}
            }
            else if (g_disk_memory == 2) // 使用打板器SD
            {
                //	if(ExtMemory_Status(SD)!=0){
                //		SDFlag = 0;
                //		pno = MENU_RWHELP;hleppara = 95;poldno[1] = MENU_CALLFILE;pnoindex = 2;
                //		if((ReadMemorryList(MENU_CALLFILE)) == 0){		// 如选中读优盘,在退出返回时要读回内存索引表
                //			return;
                //		}
                //		Write_Cmd(C_READMEMORYPAT,g_Fileno,0);
                //		g_selectdisno = g_Fileno;
                //		RestoreSHREG(0x03);
                //	}else{
                //		SDFlag = 1;
                //	}
                //
                //	//查询一下U盘插入情况
                //	Write_Cmd(C_DISK_STATUS,0,0);	//获取主板U盘插入状态
                //	for(i=0;i<FORTIMS1;i++){
                //		Read_D(D_Address[DISP]+D_CMDSTATUS,1,(U16 *)(&DREG[D_CMDSTATUS]));
                //		if((DREG[D_CMDSTATUS] >= 100)||(DREG[D_CMDSTATUS] == 10)){
                //			break;
                //		}
                //		DelayMs(WAITTIME2);
                //	}
                //	if(DREG[D_CMDSTATUS] == 102 || DREG[D_CMDSTATUS] == 101){
                //		USBFlag =1;
                //	}else{
                //		USBFlag =0;
                //	}
                //
                //	if(USBFlag || (ExtMemory_Status(USBTF)==0)) {
                //		USBFlag =1;
                //	}else{
                //		USBFlag =0;
                //	}
            }
            else //使用主板内存
            {
                //查询一下U盘插入情况
                //Write_Cmd(C_DISK_STATUS,0,0);	//获取主板U盘插入状态
                //for(i=0;i<FORTIMS1;i++){
                //	Read_D(D_Address[DISP]+D_CMDSTATUS,1,(U16 *)(&DREG[D_CMDSTATUS]));
                //	if((DREG[D_CMDSTATUS] >= 100)||(DREG[D_CMDSTATUS] == 10)){
                //		break;
                //	}
                //	DelayMs(WAITTIME2);
                //}
                //if(DREG[D_CMDSTATUS] == 102 || DREG[D_CMDSTATUS] == 101){
                //	USBFlag =1;
                //}else{
                //	USBFlag =0;
                //}

                if ((ExtMemory_Status(USBTF) == 0))
                {
                    USBFlag = 1;
                }
                else
                {
                    USBFlag = 0;
                }

                //查询一下SD卡插入情况
                //if(ExtMemory_Status(SD)==0){
                //	SDFlag =1;
                //}else{
                //	SDFlag =0;
                //}
            }
            if (SDFlag != SDFlag1)
            {
                SDFlag1 = SDFlag;
                refresh4 = 1;
            }
            if (USBFlag != USBFlag1)
            {
                USBFlag1 = USBFlag;
                refresh4 = 1;
            }
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[更新花样数据,并显示*begin]**********************************************************
        if (dis_updata3)
        {
            U16 chFileNoTemp = 0, cntTemp = 0;
            dis_updata3 = 0;
            for (cntTemp = 0; cntTemp < PatternList.disNumDiv; cntTemp++)
            {
                if (PatternList.dataAdd[cntTemp] == 0xffff)
                {
                    continue;
                }
                chFileNoTemp = PatternList.dataAdd[cntTemp] / FileIndexSize + MINFILENO;
                f = fun_getPatData(chFileNoTemp, g_disk_memory, MENU_CALLFILE);
                if (f)
                {
                    if (g_disppicflag)
                        refresh5 = 1;
                    g_init_flag = 1;
                    g_data_flash = 1;
                    // g_selectdisno = F_IND_NO;
                }
                else
                {
                    continue;
                }

                wdt();
                DelayMs(20);
                // /[绘制花样与相关信息*begin]******************************************************************************
                if (refresh5)
                {
                    refresh5 = 0;
                    if (cntTemp == PatternList.disNumDiv)
                    {
                        break;
                    }

                    if (S_2HD) //根据次原点信息分析显示花样的数据
                        AnaPattern(1, F_FILETYPE, (((F_FILELENH) << 16) | F_FILELENL));
                    else
                        AnaPattern(0, F_FILETYPE, (((F_FILELENH) << 16) | F_FILELENL));

                    // SetDrawXY(rect[cntTemp + RECT_CALLFILE_IMG1].xpis, rect[cntTemp + RECT_CALLFILE_IMG1].ypis,
                    //           rect[cntTemp + RECT_CALLFILE_IMG1].xpis + CONVAS_X2, rect[cntTemp + RECT_CALLFILE_IMG1].ypis + CONVAS_Y2, 1);
                    // Draw_Pattern(PAT_READ, Scale, orgListX[cntTemp], orgListY[cntTemp], F_FILETYPE, ((F_FILELENH << 16) | F_FILELENL), 0, 0, NULL); // 显示花样 - 三菱款
                    // SetDrawXY(0, 0, LCD_WIDTH, LCD_HEIGHT, 0);

                    pat_setDrawXY(patRule.h_patConvasIndex, rect[cntTemp + RECT_CALLFILE_IMG1].xpis, rect[cntTemp + RECT_CALLFILE_IMG1].ypis);
                    pat_drawPattern(PATRULES_READ, Scale, orgListX[cntTemp], orgListY[cntTemp], F_FILETYPE, F_FILELEN, 0, 0, NULL);
                }
                // /[绘制花样与相关信息*end]******************************************************************************
                wdt();
            }
        }
        // /[更新花样数据*end]**********************************************************

        // /[内存按键处理*begin]**********************************************************
        if (refresh4) // SD卡 内存按键选中处理
        {
            U8 chSelectMem = 0;
            refresh4 = 0;
            chSelectMem = KEY_CALLFILE_FLASH + g_disk_memory;

            for (i = KEY_CALLFILE_FLASH; i <= KEY_CALLFILE_SD; i++)
            {
                if (i == KEY_CALLFILE_USB)
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               i == chSelectMem ? keybmpind[i].border[1] : (USBFlag == 1 ? keybmpind[i].border[0] : keybmpind[i].border[2]),
                               i == chSelectMem ? keybmpind[i].icon[1] : (USBFlag == 1 ? keybmpind[i].icon[0] : keybmpind[i].icon[2]));
                else if (i == KEY_CALLFILE_SD)
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               i == chSelectMem ? keybmpind[i].border[1] : (SDFlag == 1 ? keybmpind[i].border[0] : keybmpind[i].border[2]),
                               i == chSelectMem ? keybmpind[i].icon[1] : (SDFlag == 1 ? keybmpind[i].icon[0] : keybmpind[i].icon[2]));
                else if (i == KEY_CALLFILE_FLASH)
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               i == chSelectMem ? keybmpind[i].border[1] : keybmpind[i].border[0],
                               i == chSelectMem ? keybmpind[i].icon[1] : keybmpind[i].icon[0]);
            }
        }
        // /[内存按键处理*end]**********************************************************

        // /[更新花样显示列表*begin]**********************************************************
        if (PatternList.bflashAllFlag) //索引信息更新
        {
            PatternList.bflashAllFlag = 0;
            PatternList.bFlashPageFlag = 1;
            if (g_disk_memory == 0)
            {
                tmpselectdisno = g_Fileno;
            }
            else
            {
                tmpselectdisno = MAXFILENO;
            }
            PatternList.selectNoNow = 0;
            PatternList.patternNum = 0;
            for (i = 0; i < MAXIREG2; i += FileIndexSize) //遍历花样存储空间，获取 最大合花样数量、当前花样序号
            {
                if ((((IREG2[i + 1] << 16) | IREG2[i]) > 0) &&
                    (((IREG2[i + 1] << 16) | IREG2[i]) <= 2 * MAXSREG))
                {
                    PatternList.patternNum++;
                    if ((i / FileIndexSize + MINFILENO) <= tmpselectdisno)
                        PatternList.selectNoNow++;
                }
            }

            //确定 当前选中项、当前选中页、页码总数
            PatternList.noInPageNow = (PatternList.selectNoNow - 1) % PatternList.disNumDiv;
            PatternList.noInPageLast = PatternList.noInPageNow;
            PatternList.pageNow = (PatternList.selectNoNow - 1) / PatternList.disNumDiv + 1;
            PatternList.pageLast = PatternList.pageNow;
            PatternList.pageNum = (PatternList.patternNum - 1) / PatternList.disNumDiv + 1;

            if (PatternList.pageNum == 0) //
                PatternList.pageNum = 1;

            if (PatternList.pageNow == 0)
                PatternList.pageNow = 1;
            else if (PatternList.pageNow > PatternList.pageNum)
                PatternList.pageNow = PatternList.pageNum;

            if (PatternList.noInPageNow >= PatternList.disNumDiv)
                PatternList.noInPageNow = 0;
        }

        if (PatternList.bFlashSelectFlag) //索引选中项更新
        {
            PatternList.bFlashSelectFlag = 0;

            if (PatternList.dataAdd[PatternList.noInPageNow] == 0xFFFF) //选中空
            {
                PatternList.noInPageNow = PatternList.noInPageLast;
                return;
            }
            else
            {
                PatternList.noInPageLast = PatternList.noInPageNow;
            }

            tmpselectdisno = PatternList.dataAdd[PatternList.noInPageNow] / FileIndexSize + MINFILENO; //转化为花样序号disno

            if (tmpselectdisno != 0xffff &&
                tmpselectdisno != g_selectdisno)
            {
                PatternList.selectNoNow = PatternList.noInPageNow + MINFILENO + (PatternList.pageNow - 1) * PatternList.disNumDiv;
                PatternList.selectNoLast = PatternList.selectNoNow;
                PatternList.pageLast = PatternList.pageNow;

                // g_selectdisno = tmpselectdisno;//只是勾选，没有确认
                // g_oldselectdisno = g_selectdisno;
            }

            for (i = 0; i < PatternList.disNumDiv; i++)
            {
                PatternList.selectList[i] = 0;
            }
            if (PatternList.pageNow == PatternList.pageLast)
            {
                PatternList.selectList[PatternList.noInPageNow] = 1;
            }
            patlen = (((U32)(IREG2[PatternList.dataAdd[PatternList.noInPageNow] + 1]) << 16) + IREG2[PatternList.dataAdd[PatternList.noInPageNow]]) / 2;

            refresh2 = 1;
        }

        if (PatternList.bFlashPageFlag) //索引换页更新
        {

            U32 numA = 0; //当前页的花样序号基数
            // U32 numB = 0; //当前页的花样序号偏移数
            U32 addA = 0; //当前页的花样序号基地址
            U32 addB = 0; //当前页的花样序号偏移地址
            U32 patternLen = 0;
            U8 patternType = 0;
            U16 disColor = 0;
            PatternList.bFlashPageFlag = 0;
            refresh2 = 1;
            dis_updata3 = 1;

            //显示页码
            DrawFillRect(rect[RECT_CALLFILE_PAGE].xpis, rect[RECT_CALLFILE_PAGE].ypis,
                         rect[RECT_CALLFILE_PAGE].xsize, rect[RECT_CALLFILE_PAGE].ysize, rect[RECT_CALLFILE_PAGE].colorB[0]);
            DrawFU32(rect[RECT_CALLFILE_PAGE].xpis + SAFE_DIST2, rect[RECT_CALLFILE_PAGE].ypis + SAFE_DIST4,
                     PatternList.pageNow, 3, rect[RECT_CALLFILE_PAGE].colorT[0]);
            DrawF16Str(rect[RECT_CALLFILE_PAGE].xpis + SAFE_DIST2 + 9 * 3, rect[RECT_CALLFILE_PAGE].ypis + SAFE_DIST4,
                       "/", rect[RECT_CALLFILE_PAGE].colorT[0]);
            DrawFU32(rect[RECT_CALLFILE_PAGE].xpis + SAFE_DIST2 + 9 * 4, rect[RECT_CALLFILE_PAGE].ypis + SAFE_DIST4,
                     PatternList.pageNum, 3, rect[RECT_CALLFILE_PAGE].colorT[0]);

            if (PatternList.patternNum == 0)
                PatternList.noInPageNow = 0xff;
            else if (PatternList.noInPageNow >= PatternList.disNumDiv)
                PatternList.noInPageNow = 0;

            numA = (PatternList.pageNow - 1) * PatternList.disNumDiv;
            if (numA > PatternList.patternNum)
                numA = PatternList.patternNum;
            // numB = PatternList.patternNum % PatternList.disNumDiv;
            // if ((PatternList.noInPageNow >= numB) && (PatternList.pageNow == PatternList.pageNum) && (PatternList.patternNum))
            // 	PatternList.noInPageNow = 0;

            if (numA) //计算当前页的基地址
            {
                for (j = 0, addA = 0; addA < MAXIREG2; addA += FileIndexSize)
                {
                    if ((((IREG2[addA + 1] << 16) | IREG2[addA]) > 0) &&
                        (((IREG2[addA + 1] << 16) | IREG2[addA]) <= 2 * MAXSREG))
                    {
                        j++;
                        if (j > numA)
                            break;
                    }
                }
            }
            addB = addA;
            if (numA < PatternList.patternNum) //计算当前页的各个文件的偏移地址
            {
                for (j = 0; addB < MAXIREG2; addB += FileIndexSize)
                {
                    if ((((IREG2[addB + 1] << 16) | IREG2[addB]) > 0) &&
                        (((IREG2[addB + 1] << 16) | IREG2[addB]) <= 2 * MAXSREG))
                    {
                        PatternList.dataAdd[j] = addB;
                        j++;
                        if (((numA + j) >= PatternList.patternNum) || (j >= PatternList.disNumDiv))
                            break;
                    }
                }
                for (; j < PatternList.disNumDiv; j++) //当前页的剩余文件地址写空
                    PatternList.dataAdd[j] = 0xffff;
            }
            else
            {
                for (j = 0; j < PatternList.disNumDiv; j++) //当前页的剩余文件地址写空
                    PatternList.dataAdd[j] = 0xffff;
            }

            for (i = 0; i < PatternList.disNumDiv; i++)
            {
                PatternList.selectList[i] = 0;
            }
            if (PatternList.pageNow == PatternList.pageLast)
            {
                PatternList.selectList[PatternList.noInPageNow] = 1;
                tmpselectdisno = PatternList.dataAdd[PatternList.noInPageNow] / FileIndexSize + MINFILENO; //转化为花样序号disno
                patlen = (((U32)(IREG2[PatternList.dataAdd[PatternList.noInPageNow] + 1]) << 16) + IREG2[PatternList.dataAdd[PatternList.noInPageNow]]) / 2;
            }

            //绘制按钮信息
            for (i = 0; i < PatternList.disNumDiv; i++)
            {

                DrawFillRect(rect[i + RECT_CALLFILE_IMG1].xpis, rect[i + RECT_CALLFILE_IMG1].ypis,
                             rect[i + RECT_CALLFILE_IMG1].xsize, rect[i + RECT_CALLFILE_IMG1].ysize,
                             rect[i + RECT_CALLFILE_IMG1].colorB[0]);

                BmpFillRect(rect[i + RECT_CALLFILE_SEL1].xpis, rect[i + RECT_CALLFILE_SEL1].ypis,
                            rect[i + RECT_CALLFILE_SEL1].xsize + SAFE_DIST6, rect[i + RECT_CALLFILE_SEL1].ysize);

                patternLen = ((IREG2[(PatternList.dataAdd[i]) + 1] << 16) | IREG2[(PatternList.dataAdd[i])]);
                patternType = ((IREG2[(PatternList.dataAdd[i]) + FileIndexSize - 1] & 0xff00) >> 8) & 0xff;
                disColor = ((PatternList.dataAdd[i] < MAXIREG2) && ((patternLen > 0) && (patternLen < 2 * MAXSREG)))
                               ? ((patternType != 0) ? MitFontColor : BorFontColor)
                               : keybmpind[i + RECT_CALLFILE_SEL1].textColor[0];
                DrawFFileno_16x8(rect[i + RECT_CALLFILE_SEL1].xpis + TYPE_SIZE26 + SAFE_DIST3, rect[i + RECT_CALLFILE_SEL1].ypis + SAFE_DIST1,
                                 (PatternList.dataAdd[i] >= MAXIREG2) ? 0 : PatternList.dataAdd[i] / FileIndexSize + MINFILENO, disColor);

                DrawF16Str(rect[i + RECT_CALLFILE_SEL1].xpis + TYPE_SIZE26 + SAFE_DIST3 + 9 * 3,
                           rect[i + RECT_CALLFILE_SEL1].ypis + SAFE_DIST1,
                           "@", rect[i + RECT_CALLFILE_SEL1].colorT[0]);

                if (PatternList.dataAdd[i] >= MAXIREG2)
                {
                    DrawFFilename(rect[i + RECT_CALLFILE_SEL1].xpis + TYPE_SIZE26 + SAFE_DIST3 + 9 * 4,
                                  rect[i + RECT_CALLFILE_SEL1].ypis + SAFE_DIST4,
                                  "NO__DATA",
                                  strlen("NO__DATA"), NO_DATAColor, 6, 0, NULL);
                    PatternList.selectEnable[i] = 0;
                }
                else
                {
                    DrawFFilename(rect[i + RECT_CALLFILE_SEL1].xpis + TYPE_SIZE26 + SAFE_DIST3 + 9 * 4,
                                  rect[i + RECT_CALLFILE_SEL1].ypis + SAFE_DIST4,
                                  (char *)(&IREG2[PatternList.dataAdd[i] + FileIndexNamepox]),
                                  64, disColor, 6, 0, NULL);
                    PatternList.selectEnable[i] = 1;
                }
            }
            wdt();
        }
        // /[更新花样显示列表*end]**********************************************************

        // /[文件选中BMP处理*begin]**********************************************************
        if (refresh2) // 文件编号选中处理
        {
            refresh2 = 0;
            for (i = 0; i < PatternList.disNumDiv; i++)
            {
                BmpFillRect(disBmp[i + 1].xpis, disBmp[i + 1].ypis,
                            disBmp[i + 1].xsize, disBmp[i + 1].ysize);
                DrawFPBMPBTN1(disBmp[i + 1].xpis, disBmp[i + 1].ypis,
                              disBmp[i + 1].xsize, disBmp[i + 1].ysize,
                              PatternList.selectList[i] ? disBmp[i + 1].icon[1] : disBmp[i + 1].icon[0]);
            }
        }
        // /[文件选中BMP处理*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1)
            ErrorMsg(MENU_CALLFILE);
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*begin]**********************************************************
        if (beeponf == 0)
        {
            ErrorMsg(MENU_CALLFILE);
            if (Timer_ms >= 30000) //30720
            {
                Timer_ms = 0;
            }
        }
        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*end]**********************************************************

        // /[绘制链接按钮*begin]**********************************************************
        if (dis_updata4)
        { //连接处空送
            dis_updata4 = 0;
            for (i = KEY_CALLFILE_START; i <= KEY_CALLFILE_END; i++)
            {
                if (i == KEY_CALLFILE_START)
                    // DrawButton2(keyd[i], Color_White1, (StPointFlag == 1) ? keybmpind[i] + 1 : keybmpind[i], 1);
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               (StPointFlag == 1) ? keybmpind[i].border[1] : keybmpind[i].border[0],
                               (StPointFlag == 1) ? keybmpind[i].icon[1] : keybmpind[i].icon[0]);
                else
                    // DrawButton2(keyd[i], Color_White1, (EndPointFlag == 1) ? keybmpind[i] + 1 : keybmpind[i], 1);
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               (EndPointFlag == 1) ? keybmpind[i].border[1] : keybmpind[i].border[0],
                               (EndPointFlag == 1) ? keybmpind[i].icon[1] : keybmpind[i].icon[0]);
            }
        }
        // /[绘制链接按钮*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if ((g_backSREG_f == 1) || (g_backHREG_f == 1))
        {
            BackupSHREG((g_backHREG_f << 1) | g_backSREG_f);
        }

        if (pno != MENU_CALLFILE)
        {
            if (g_GreatPatType == 1)
            { //三菱
                g_init_flag = tmpinit_flag;
            }
            plastno = MENU_CALLFILE;
            break;
        }

        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

/*********************************************/

#define KEY_DIRCALLFILE_SCRNSVR 1 //1 屏保
#define KEY_DIRCALLFILE_BACK 2    //2 返回
#define KEY_DIRCALLFILE_OK 3      //3 确认
#define KEY_DIRCALLFILE_PREV 4    //4 上一页
#define KEY_DIRCALLFILE_NEXT 5    //5 下一页
#define KEY_DIRCALLFILE_SEL1 6    //6 选框1
#define KEY_DIRCALLFILE_SEL2 7    //7 选框2
#define KEY_DIRCALLFILE_SEL3 8    //8 选框3
#define KEY_DIRCALLFILE_SEL4 9    //9 选框4
#define KEY_DIRCALLFILE_SEL5 10   //10 选框5
#define KEY_DIRCALLFILE_SEL6 11   //11 选框6
#define KEY_DIRCALLFILE_SEL7 12   //12 选框7
#define KEY_DIRCALLFILE_SEL8 13   //13 选框8
#define KEY_DIRCALLFILE_SEL9 14   //14 选框9
#define KEY_DIRCALLFILE_CLEAN 15  //15 清除一位
#define KEY_DIRCALLFILE_0 16      //16 0
#define KEY_DIRCALLFILE_1 17      //17 1
#define KEY_DIRCALLFILE_2 18      //18 2
#define KEY_DIRCALLFILE_3 19      //19 3
#define KEY_DIRCALLFILE_4 20      //20 4
#define KEY_DIRCALLFILE_5 21      //21 5
#define KEY_DIRCALLFILE_6 22      //22 6
#define KEY_DIRCALLFILE_7 23      //23 7
#define KEY_DIRCALLFILE_8 24      //24 8
#define KEY_DIRCALLFILE_9 25      //25 9

#define KEY_DIRCALLFILE_START 26 //23 回起始点
#define KEY_DIRCALLFILE_END 27   //24 回终止点

#define KEY_DIRCALLFILE_MAX 28

#define RECT_DIRCALLFILE_SEL1 1     //1 选框1
#define RECT_DIRCALLFILE_SEL2 2     //2 选框2
#define RECT_DIRCALLFILE_SEL3 3     //3 选框3
#define RECT_DIRCALLFILE_SEL4 4     //4 选框4
#define RECT_DIRCALLFILE_SEL5 5     //5 选框5
#define RECT_DIRCALLFILE_SEL6 6     //6 选框6
#define RECT_DIRCALLFILE_SEL7 7     //7 选框7
#define RECT_DIRCALLFILE_SEL8 8     //8 选框8
#define RECT_DIRCALLFILE_SEL9 9     //9 选框9
#define RECT_DIRCALLFILE_PAGE 10    //10 换页提示
#define RECT_DIRCALLFILE_NUM_TIT 11 //11 按钮标题
#define RECT_DIRCALLFILE_NUM_STR 12 //12 按钮内容
#define RECT_DIRCALLFILE_IMG1 13    //13 选框1
#define RECT_DIRCALLFILE_IMG2 14    //14 选框2
#define RECT_DIRCALLFILE_IMG3 15    //15 选框3
#define RECT_DIRCALLFILE_IMG4 16    //16 选框4
#define RECT_DIRCALLFILE_IMG5 17    //17 选框5
#define RECT_DIRCALLFILE_IMG6 18    //18 选框6
#define RECT_DIRCALLFILE_IMG7 19    //19 选框7
#define RECT_DIRCALLFILE_IMG8 20    //20 选框8
#define RECT_DIRCALLFILE_IMG9 21    //21 选框9

#define RECT_DIRCALLFILE_MAX 22

#define BMP_DIRCALLFILE_SEL1 1 //1 选框1
#define BMP_DIRCALLFILE_SEL2 2 //2 选框2
#define BMP_DIRCALLFILE_SEL3 3 //3 选框3
#define BMP_DIRCALLFILE_SEL4 4 //4 选框4
#define BMP_DIRCALLFILE_SEL5 5 //5 选框5
#define BMP_DIRCALLFILE_SEL6 6 //6 选框6
#define BMP_DIRCALLFILE_SEL7 7 //7 选框7
#define BMP_DIRCALLFILE_SEL8 8 //8 选框8
#define BMP_DIRCALLFILE_SEL9 9 //9 选框9

#define BMP_DIRCALLFILE_MAX 10
//------------------------------------------
// Function   : void Menu_DIRCALLFILE(void)
// Description: 直接读取花样画面
//------------------------------------------
void Menu_DirCallFile(void)
{

    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
    /****按键相关参数end****/

    /****花样序号，花样名称，花样列表相关参数begin****/
    //	U16 static tmpFno;																 //当前花样信息HREG[0]文件位置(即序号),花样序号缓存
    //	U16 tmpselectdisno;			  //选中的花样序号缓存
    //	U16 temp_feed = 0xffff;															 //用于绘制针点的 当前所处针数缓存
    //	U16 temp_feed0 = 0xffff;														 //用于绘制针点的 上一个时刻所处的针数缓存
    //	U16 tmpS_2HOME = 0, oldtmpS_2HOME = 0;											 //系统状态缓存-回到原点
    U16 tmp_s_2hd = (U16)(S_2HD); //次原点位置缓存
                                  //	U8 pattern_flash = 0, data_flash = 1, jog_flash = 1;							 //pattern_flash花样图案绘制更新标志位 ，data_flash花样数据更新标志位  ，jog_flash跳针数据更新标志位
                                  //	U8 bflag = 0;																	 //0：绘制运行过得线；1：重绘超过部分的针点与线 2：重绘退回的线；3：绘制运行过的针点与线；
    // U8 tmpGroupNO = g_GroupNO, lastGroupNO = g_GroupNO;								 //当前组合模式序号，上一个组合模式序号
    tydPatternList PatternList = {1, 0, 0, 9, 0, 0, 1, 1, 1, 0, 0, 0, 0, {0}, {0}}; //花样列表参数
    /****花样序号，花样名称，花样列表相关参数end****/

    /****花样显示相关参数begin****/
    //	S16 ORG_X = 0, ORG_Y = 0;				//用于显示花样的画布中心点（LCD实际坐标） 原ORG_X = 325, ORG_Y = 262
    // S16 xo = 0, yo = 0;							 //花样数据源的中心点花样数据坐标缓存
    //	S16 xorg = 0, yorg = 0;					//花样图像的中心点坐标 转化到 屏幕的中心点坐标
    S32 /*tscale = 1 , tscale1 = 1, */ Scale = 0; //tscale：图像显示需要调整的缩放比，tscale1：最终的总缩放比，Scale：固定的缩放比
    // S16 fpx, fpy;								 //指定针点的花样数据坐标
    //	S8 tmuly = 1;							//三菱款与兄弟款的Y轴数据比，相反关系
    //	S32 vposx0 = 0, vposy0 = 0;				//上一个的指定花样点的坐标 转化到 屏幕的坐标
    //	S32 vposx, vposy;						//指定花样点的坐标 转化到 屏幕的坐标
    // S16 xtmp, ytmp;								 //倍率计算缓存

    const S16 orgListX[] = {CONVAS_ORG_PX2_1, CONVAS_ORG_PX2_2, CONVAS_ORG_PX2_3, CONVAS_ORG_PX2_5,
                            CONVAS_ORG_PX2_6, CONVAS_ORG_PX2_7, CONVAS_ORG_PX2_9, CONVAS_ORG_PX2_10,
                            CONVAS_ORG_PX2_11};
    const S16 orgListY[] = {CONVAS_ORG_PY2_1, CONVAS_ORG_PY2_2, CONVAS_ORG_PY2_3, CONVAS_ORG_PY2_5,
                            CONVAS_ORG_PY2_6, CONVAS_ORG_PY2_7, CONVAS_ORG_PY2_9, CONVAS_ORG_PY2_10,
                            CONVAS_ORG_PY2_11};
    /****花样显示相关参数end****/

    /****标志位相关参数begin****/
    U32 i, j, patlen = 0; //,ii,jj,ofesst,s
    U8 f = 0;
    U16 dlen = 0;
    U32 Staddr = 0, Endaddr = 0;
    U32 DrawLen;
    ISEWADD sewInfo = {0};
    ISEWCMD sewIcmd = {0};
    S16 Xposmax = 0, Xposmin = 0, Yposmax = 0, Yposmin = 0;
    U32 tmpaddr1 = 0;
    U8 Addtrimflag = 0; //添加剪线标志
    U8 exStflag = 0;
    U16 tmpBorcmd;
    S8 tmpBorpooft, Borpfdis;
    U8 tmp_pfoot = (U8)S_PFOOT;
    U16 tmpdraw_p = 0, tmpline_p = 0, tmpline_sum = 0, tmpdraw_p1 = 0, tmpline_p1 = 0, tmpline_sum1 = 0, tmpfeedsum = 0, tmpfeedsum1 = 0;
    U32 tmppat_p = 0, tmppat_p1 = 0;
    U16 stdraw_p = 0, stline_p = 0;
    U32 stpat_p = 0;
    U16 enddraw_p = 0, endline_p = 0;
    U32 endpat_p = 0;
    S16 x1 = 0, y1 = 0;
    U8 ch, overf = 0;
    U16 dat1;
    U16 delnums = 0, delnums1 = 0;
    U32 tmpCreatstaddr = 0, tmpCreatenaddr = 0;
    S16 tmporgX = 0, tmporgY = 0;
    U16 newhomelines = 0; //调入花样次原点线条数据
    U8 newhomeflag = 0;   //调用花样次原点
    U8 tmpinit_flag = 0;
    U16 addfeeds = 0;
    U16 drawpins = 0; //只有绘图数据的针数(中压脚)
    S16 tmppf_absval = 0;
    S8 tmppfmax = 0, tmppfmin = 0;
    U8 excode = 0;
    U8 tmp_DoTrim = 0;
    S16 tmppx, tmppy, tmpdx, tmpdy;
    U8 tmpspeed;
    U16 tfeedsum = 0;

    U8 StPointFlag = 0, EndPointFlag = 0;

    U16 patno = 0; //显示花样筛选数字输入
    U8 disall = 1; //显示所有花样标志

    U8 refresh2 = 0, refresh5 = 1;
    U8 dis_updata1 = 0, dis_updata3 = 0, dis_updata4 = 1; //disupdata1:索引更新标志 disupdata2：当前文件所在索引位置更新标志  disupdata3：花样数据更新标志
    /****标志位相关参数end***/

    const U8 keynum = {KEY_DIRCALLFILE_MAX};
    const KEYPAD keyd[] = {
        {0, 0, 0, 0},

        {0, 0, 128, 32},                                                   //1 屏保
        {TYPE_X1, TYPE_Y4, KEY_X1, KEY_Y1},                                //2 返回
        {TYPE_X11, TYPE_Y3, KEY_X1, KEY_Y1},                               //3 确认
        {331, TYPE_Y4, KEY_X1, KEY_Y1},                                    //4 上一页
        {331 + (KEY_X1 + SAFE_DIST5) * 2, TYPE_Y4, KEY_X1, KEY_Y1},        //5 下一页
        {CONVAS_PX2_1, CONVAS_PY2_1, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},   //6 选框1
        {CONVAS_PX2_2, CONVAS_PY2_2, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},   //7 选框2
        {CONVAS_PX2_3, CONVAS_PY2_3, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},   //8 选框3
        {CONVAS_PX2_5, CONVAS_PY2_5, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},   //9 选框4
        {CONVAS_PX2_6, CONVAS_PY2_6, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},   //10 选框5
        {CONVAS_PX2_7, CONVAS_PY2_7, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},   //11 选框6
        {CONVAS_PX2_9, CONVAS_PY2_9, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5},   //12 选框7
        {CONVAS_PX2_10, CONVAS_PY2_10, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5}, //13 选框8
        {CONVAS_PX2_11, CONVAS_PY2_11, CONVAS_X2, CONVAS_Y2 + TYPE_SIZE5}, //14 选框9

        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},       //15 清除一位
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},                             //16 0
        {TYPE_X15, TYPE_Y13, KEY_X2, KEY_Y2},                                                         //17 1
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13, KEY_X2, KEY_Y2},                                   //18 2
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13, KEY_X2, KEY_Y2},                             //19 3
        {TYPE_X15, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},                                   //20 4
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},             //21 5
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},       //22 6
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},                             //23 7
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},       //24 8
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2}, //25 9

        {TYPE_X9, TYPE_Y4, KEY_X1, KEY_Y1},  //26 回起始点
        {TYPE_X10, TYPE_Y4, KEY_X1, KEY_Y1}, //27 回终止点

    };

    const tydDisSrcIndex keybmpind[] = {
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},
        {{KEY_Silver}, {0}, {0}, {TLFNADD_CALLFILE + 1, 0, 0, 0}, {0}},             //1 屏保
        {{KEY_Silver}, {0}, {72}, {TLFNADD_CALLFILE + 2, 0, 0, 0}, {0}},            //2 返回
        {{KEY_Silver}, {0}, {71}, {TLFNADD_CALLFILE + 3, 0, 0, 0}, {0}},            //3 确认
        {{KEY_Silver}, {0}, {223, 224}, {TLFNADD_CALLFILE + 10, 0, 0, 0}, {0}},     //8 上一页
        {{KEY_Silver}, {0}, {225, 226}, {TLFNADD_CALLFILE + 11, 0, 0, 0}, {0}},     //9 下一页
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 12, 0, 0, 0}, {0}}, //14 选框1
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 13, 0, 0, 0}, {0}}, //15 选框2
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 14, 0, 0, 0}, {0}}, //16 选框3
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 15, 0, 0, 0}, {0}}, //17 选框4
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 16, 0, 0, 0}, {0}}, //18 选框5
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 17, 0, 0, 0}, {0}}, //19 选框6
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 18, 0, 0, 0}, {0}}, //20 选框7
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 19, 0, 0, 0}, {0}}, //21 选框8
        {{Color_White}, {0}, {Color_Black}, {TLFNADD_CALLFILE + 20, 0, 0, 0}, {0}}, //22 选框9

        {{KEY_Silver}, {0}, {113}, {TLFNADD_CALLFILE + 28, 0, 0, 0}, {0}}, //8 输入清除
        {{KEY_Silver}, {0}, {91}, {0, 0, 0, 0}, {0}},                      //11 0
        {{KEY_Silver}, {0}, {92}, {0, 0, 0, 0}, {0}},                      //12 1
        {{KEY_Silver}, {0}, {93}, {0, 0, 0, 0}, {0}},                      //13 2
        {{KEY_Silver}, {0}, {94}, {0, 0, 0, 0}, {0}},                      //14 3
        {{KEY_Silver}, {0}, {95}, {0, 0, 0, 0}, {0}},                      //15 4
        {{KEY_Silver}, {0}, {96}, {0, 0, 0, 0}, {0}},                      //16 5
        {{KEY_Silver}, {0}, {97}, {0, 0, 0, 0}, {0}},                      //17 6
        {{KEY_Silver}, {0}, {98}, {0, 0, 0, 0}, {0}},                      //18 7
        {{KEY_Silver}, {0}, {99}, {0, 0, 0, 0}, {0}},                      //19 8
        {{KEY_Silver}, {0}, {100}, {0, 0, 0, 0}, {0}},                     //20 9

        {{KEY_Silver, KEY_Silver}, {0}, {491, 492}, {TLFNADD_CALLFILE + 24, TLFNADD_CALLFILE + 4, 0, 0}, {0}}, //26 回起始点
        {{KEY_Silver, KEY_Silver}, {0}, {493, 494}, {TLFNADD_CALLFILE + 25, TLFNADD_CALLFILE + 5, 0, 0}, {0}}, //27 回终止点

    };

    const RECTPAD rect[RECT_DIRCALLFILE_MAX] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {TLFNADD_CALLFILE + 0}},

        {CONVAS_PX2_1, CONVAS_PY2_1 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                      //1 选框1
        {CONVAS_PX2_2, CONVAS_PY2_2 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                      //2 选框2
        {CONVAS_PX2_3, CONVAS_PY2_3 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                      //3 选框3
        {CONVAS_PX2_5, CONVAS_PY2_5 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                      //4 选框4
        {CONVAS_PX2_6, CONVAS_PY2_6 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                      //5 选框5
        {CONVAS_PX2_7, CONVAS_PY2_7 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                      //6 选框6
        {CONVAS_PX2_9, CONVAS_PY2_9 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                      //7 选框7
        {CONVAS_PX2_10, CONVAS_PY2_10 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                    //8 选框8
        {CONVAS_PX2_11, CONVAS_PY2_11 + CONVAS_Y2, CONVAS_X2, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                    //9 选框9
        {331 + KEY_X1 + SAFE_DIST5, TYPE_Y4 + (KEY_Y1 - TYPE_SIZE4) / 2, KEY_X1, TYPE_SIZE4, {Color_White}, {Color_Black}, {0}}, //10 换页提示
        {TYPE_X15, TYPE_Y3, TYPE_SIZE9, TYPE_SIZE5, {Color_KeyBlue}, {Color_White}, {TLFNADD_CALLFILE + 27}},                    //11 序号标题
        {TYPE_X15 + TYPE_SIZE9 + SAFE_DIST5, TYPE_Y3, TYPE_SIZE14, TYPE_SIZE5, {Color_DeepSkyBlue}, {Color_Black}, {0}},         //12 序号内容
        {CONVAS_PX2_1, CONVAS_PY2_1, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                   //13 选框1
        {CONVAS_PX2_2, CONVAS_PY2_2, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                   //14 选框2
        {CONVAS_PX2_3, CONVAS_PY2_3, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                   //15 选框3
        {CONVAS_PX2_5, CONVAS_PY2_5, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                   //16 选框4
        {CONVAS_PX2_6, CONVAS_PY2_6, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                   //17 选框5
        {CONVAS_PX2_7, CONVAS_PY2_7, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                   //18 选框6
        {CONVAS_PX2_9, CONVAS_PY2_9, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                   //19 选框7
        {CONVAS_PX2_10, CONVAS_PY2_10, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                 //20 选框8
        {CONVAS_PX2_11, CONVAS_PY2_11, CONVAS_X2, CONVAS_Y2, {Color_Black}, {Color_Black}, {0}},                                 //21 选框9
    };

    const BMPPAD disBmp[BMP_DIRCALLFILE_MAX] = {
        //icon
        {0, 0, 0, 0, {0}},

        {CONVAS_PX2_1, CONVAS_PY2_1 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //1 选框1
        {CONVAS_PX2_2, CONVAS_PY2_2 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //2 选框2
        {CONVAS_PX2_3, CONVAS_PY2_3 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //3 选框3
        {CONVAS_PX2_5, CONVAS_PY2_5 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //4 选框4
        {CONVAS_PX2_6, CONVAS_PY2_6 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //5 选框5
        {CONVAS_PX2_7, CONVAS_PY2_7 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //6 选框6
        {CONVAS_PX2_9, CONVAS_PY2_9 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}},   //7 选框7
        {CONVAS_PX2_10, CONVAS_PY2_10 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}}, //8 选框8
        {CONVAS_PX2_11, CONVAS_PY2_11 + CONVAS_Y2 + SAFE_DIST1, TYPE_SIZE26, TYPE_SIZE26, {836, 837, 838}}, //9 选框9

    };
    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_CURSOR); //设置当前文字显示雷人在P1页面，对应41.bin
    InitScreen();
    initViewStatus();
    updateViewStatus();
    pat_resetPatRule();
    pat_setPatRule(PATRULES_READ);

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    DrawLen = g_CtPatLen / 2;
    if (g_GreatPatType == 1)
    { //三菱
        tmpdraw_p = g_draw_p;
        tmpline_p = g_line_p;
        tmppat_p = g_pat_p;
        tmpline_sum = g_line_sum;
        tmpfeedsum = g_feedsum;
        tmpdraw_p1 = g_draw_p;
        tmpline_p1 = g_line_p;
        tmppat_p1 = g_pat_p;
        tmpline_sum1 = g_line_sum;
        tmpfeedsum1 = g_feedsum;
        tmpinit_flag = g_init_flag;
        g_init_flag = 1;
    }
    else if (g_GreatPatType == 2)
    { //兄弟
        tmpCreatenaddr = g_Ctendaddr;
        tmpCreatstaddr = g_Ctstaddr;
        tmpfeedsum = g_patd.feed_sum;
        tfeedsum = g_patd.feed_sum;
        tmporgX = g_patd.orgX;
        tmporgY = g_patd.orgY;
    }
    g_disppicflag = 1;
    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + rect[0].index[0] * TitleLengthMax, SheetPage, rect[0].index[0], rect[0].colorT[0]); //读取模式
    //画出方框
    for (i = 1; i < RECT_DIRCALLFILE_MAX; i++)
    {
        if (i <= RECT_DIRCALLFILE_SEL9)
        {
            BmpFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize);
        }
        else
        {
            DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
            if (i == RECT_DIRCALLFILE_NUM_STR)
            {
                DrawDottedRect(rect[RECT_DIRCALLFILE_NUM_STR].xpis, rect[RECT_DIRCALLFILE_NUM_STR].ypis,
                               rect[RECT_DIRCALLFILE_NUM_STR].xsize, rect[RECT_DIRCALLFILE_NUM_STR].ysize,
                               rect[RECT_DIRCALLFILE_NUM_STR].colorT[0]);
            }
            else if (i == RECT_DIRCALLFILE_NUM_TIT)
            {
                Draw24x24Str(rect[i].xpis + SAFE_DIST4, rect[i].ypis + SAFE_DIST4,
                             MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
                             SheetPage, rect[i].index[0], rect[i].colorT[0]); //读取模式
            }
        }
    }
    //画出按键显示
    for (i = 2; i < KEY_DIRCALLFILE_MAX; i++)
    {
        //无效按键

        //不需要显示的按键
        if (i == KEY_DIRCALLFILE_OK) //非常规按钮
        {
        }
        else if (i >= KEY_DIRCALLFILE_SEL1 && i <= KEY_DIRCALLFILE_SEL9) //非常规按钮
        {
            // DrawButtonDisPat(keyd[i], keybmpind[i].border[0], keybmpind[i].icon[0]);
        }
        else //常规按钮
        {
            DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
        }
    }
    //画出BMP显示
    for (i = 1; i < BMP_DIRCALLFILE_MAX; i++)
    {
        DrawFPBMPBTN1(disBmp[i].xpis, disBmp[i].ypis, disBmp[i].xsize, disBmp[i].ysize, disBmp[i].icon[0]);
    }
    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************

    ViewPage(usepageno); //设置显示缓存

    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    //	tmpselectdisno = g_oldselectdisno;
    Timer_ms = 30720; //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        keydata = get_keydata((KEYPAD *)keyd, keynum, 0);                   //获取键值
        if (keyon >= KEY_DIRCALLFILE_SEL1 && keyon <= KEY_DIRCALLFILE_SEL9) //非常规按键
        {
            f = keydata - KEY_DIRCALLFILE_SEL1;
            if (PatternList.selectEnable[f] == 0)
                keydata = 0;
        }
        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            //带有连续按键功能的按键
            if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {

            if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时)
            {
                keyon = keydata;
                if (keyon == KEY_DIRCALLFILE_SCRNSVR || keyon == KEY_DIRCALLFILE_OK ||
                    (keyon >= KEY_DIRCALLFILE_SEL1 && keyon <= KEY_DIRCALLFILE_SEL9)) //无按键特效
                {
                }
                //非常规按键
                else
                {
                    DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);
                }
                Times = 0;
                delay = KEYDT; //按键防抖次数
            }
            else if (keyon != keydata) //已有按键按下，不处理新按键信息
            {
                keydata = 0;
            }

            if (Times > delay) //按键防抖
            {
                if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                {
                    beeponf = 1;

                    if (g_keyBellT) //按键时蜂鸣器发声时间
                        Beep_On(g_keyBellT);

                    switch (keyon) //按键按下标题提示语显示
                    {
                    case KEY_DIRCALLFILE_0:
                    case KEY_DIRCALLFILE_1:
                    case KEY_DIRCALLFILE_2:
                    case KEY_DIRCALLFILE_3:
                    case KEY_DIRCALLFILE_4:
                    case KEY_DIRCALLFILE_5:
                    case KEY_DIRCALLFILE_6:
                    case KEY_DIRCALLFILE_7:
                    case KEY_DIRCALLFILE_8:
                    case KEY_DIRCALLFILE_9:
                        BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
                        DrawMFU32(TITLE_XPOS_C2, SAFE_DIST4, keyon - KEY_DIRCALLFILE_0, 1, rect[0].colorT[0]);
                        break;
                    default:
                        DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                        break;
                    }

                    delay = KEYFT;
                }
                else if (beeponf == 1) //第二次进入
                {
                    beeponf = 2;
                    delay = KEYNT;
                }
                else if (beeponf < 20)
                {
                    beeponf++;
                }
                //带有长按连续功能按键的功能
                Times = 0; //当前
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            if ((keyoff >= KEY_DIRCALLFILE_0) && (keyoff <= KEY_DIRCALLFILE_9))
            {
                patno = (patno % 100) * 10 + keyoff - KEY_DIRCALLFILE_0;
                disall = 0;
                dis_updata1 = 1;
            }
            else if (keyoff >= KEY_DIRCALLFILE_SEL1 && keyoff <= KEY_DIRCALLFILE_SEL9)
            {

                if (PatternList.dataAdd[keyoff - KEY_DIRCALLFILE_SEL1] != 0xffff)
                {
                    U16 tmpselectdisno = 0;
                    tmpselectdisno = PatternList.dataAdd[keyoff - KEY_DIRCALLFILE_SEL1] / FileIndexSize + MINFILENO;
                    patlen = (((U32)(IREG2[PatternList.dataAdd[keyoff - KEY_DIRCALLFILE_SEL1] + 1]) << 16) + IREG2[PatternList.dataAdd[keyoff - KEY_DIRCALLFILE_SEL1]]) / 2;
                    f = fun_getPatData(tmpselectdisno, g_disk_memory, MENU_DIRCALLFILE);
                    if (f)
                    {
                        AnaPattern(0, F_FILETYPE, (((F_FILELENH) << 16) | F_FILELENL));
                    }
                    else
                    {
                        break;
                    }
                    wdt();
                    if (g_readcovnflag == 0)
                    { //打板进来调用
                        if (g_GreatPatType == 1)
                        { //生成为三菱

                            //							//查询原花样最后一针是否为空送或剪线，以判断在连接花样数据时是否添加剪线指令
                            //							if(((BLKSREG[tmpdraw_p-4]==0x0088)&&(BLKSREG[tmpdraw_p-3]==0x7800))||((BLKSREG[tmpdraw_p-4]==0x0201)&&(BLKSREG[tmpdraw_p-3]==0x0000))){	//结束针为空送或剪线
                            //								Addtrimflag = 0;
                            //							}else{
                            //								Addtrimflag = 1;
                            //							}
                            Addtrimflag = 0;
                            for (i = 52000; i < tmppat_p; i += 2)
                            {
                                if (((BLKSREG[i] & 0xff) == 0x61) || ((BLKSREG[i] & 0xff) == 0x41) || ((BLKSREG[i] & 0xff) == 0x21) || ((BLKSREG[i] & 0xff) == 0x01))
                                { //缝纫 需要剪线
                                    Addtrimflag = 1;
                                }
                                else if (((BLKSREG[i] & 0xff) == 0x03) || ((BLKSREG[i] & 0xff) == 0x1b) || ((BLKSREG[i] & 0xff) == 0x07))
                                { //空送或跳缝 不需要剪线
                                    Addtrimflag = 0;
                                }
                            }

                            if (F_FILETYPE == PAT_SEW)
                            { //兄弟 转为三菱类型
                                if (Bor_To_Mit(patlen * 2) == 0)
                                { //转换失败  数据超范围
                                    for (i = 0; i < MAXSREG; i++)
                                    { //还原当前花样数据
                                        SREG[i] = BLKSREG[i];
                                        NEWSREG[i] = BLKSREG[i];
                                    }
                                    for (i = 0; i < MAXHREG; i++)
                                    { //还原当前花样文件信息
                                        HREG[i] = BLKHREG[i];
                                    }
                                    wdt();
                                    g_draw_p = tmpdraw_p;
                                    g_line_p = tmpline_p;
                                    g_pat_p = tmppat_p;
                                    g_line_sum = tmpline_sum;
                                    g_feedsum = tmpfeedsum;
                                    hleppara = 120;
                                    pno = MENU_RWHELP;
                                    poldno[pnoindex] = MENU_DIRCALLFILE;
                                    pnoindex++;
                                    break;
                                }

                                AnaPattern(0, PAT_MIT, 0);
                                memset((U8 *)NEWSREG, 0, sizeof(NEWSREG));
                                for (i = 0; i < MAXSREG; i++)
                                {
                                    NEWSREG[i] = BLKSREG[i];
                                }
                            }

                            wdt();
                            if (g_disk_memory && (F_FILETYPE != 2))
                            {
                                for (i = 0; i < MAXSREG; i++)
                                {
                                    NEWSREG[i] = BLKSREG[i];
                                }
                            }

                            for (i = 0; i < MAXHREG; i++)
                            { //还原当前花样文件信息
                                HREG[i] = BLKHREG[i];
                            }

                            stdraw_p = g_patd.draw_add;
                            stline_p = g_patd.line_add;
                            stpat_p = g_patd.pat_add;

                            enddraw_p = g_draw_p;
                            endline_p = g_line_p;
                            endpat_p = g_pat_p;
                            delnums = 0;
                            //计算起点数据地址
                            if (StPointFlag)
                            { //保留原点到起针点的移送
                                for (i = g_patd.draw_add; i < g_draw_p; i += 4)
                                { //调用图型有次原点的话,不要次原点
                                    if ((SREG[i] == 0x0601) && (SREG[i + 1] == 0x0))
                                    { //次原点
                                        newhomeflag = 1;
                                        break;
                                    }
                                    newhomelines++;
                                }
                            }
                            else
                            { //清除原点到起针点的移送

                                //绘图数据
                                for (i = g_patd.draw_add; i < g_draw_p; i += 4)
                                {
                                    if ((SREG[i] != 0x0088) || (SREG[i + 1] != 0x7800))
                                    {
                                        break;
                                    }
                                }
                                if ((SREG[i] == 0x0601) && (SREG[i + 1] == 0x0))
                                { //次原点
                                    stdraw_p = i + 4;
                                }
                                else
                                {
                                    stdraw_p = i;
                                }
                                delnums = (stdraw_p - g_patd.draw_add) / 4;

                                for (i = g_patd.line_add; i < g_line_p; i++)
                                { //线条数据
                                    if (SREG[i] == delnums)
                                    {
                                        stline_p = i;
                                        break;
                                    }
                                }

                                stpat_p = (stline_p - g_patd.line_add) * 2 + g_patd.pat_add; //针数据
                            }

                            wdt();

                            for (i = 0; i < (enddraw_p - stdraw_p); i += 4)
                            { //绘图数据 查找插入图像第一针数据是空送还是缝纫.
                                //#if Debug
                                //printf("SREG[%d] = %04x \r\n",stdraw_p+i,SREG[stdraw_p+i]);
                                //#endif
                                if ((SREG[stdraw_p + i] == 0x0088) && (SREG[stdraw_p + i + 1] == 0x7800))
                                {
                                    break;
                                }
                                else
                                {
                                    if (NoNeedTri((SREG[stdraw_p + i] & 0xff)))
                                    { //缝纫
                                        if (Addtrimflag)
                                        { //不需要剪线连接
                                            Addtrimflag = 0;
                                        }
                                        break;
                                    }
                                }
                            }

                            wdt();
                            //计算结束点数据地址
                            if (EndPointFlag)
                            { //保留结束点空送
                                for (i = g_patd.draw_add; i < g_draw_p; i += 4)
                                { //绘图数据
                                    if (((SREG[i] == 0x1e01) && (SREG[i + 1] == 0x0)) || ((SREG[i] == 0x1f01) && (SREG[i + 1] == 0x0)))
                                    {
                                        break;
                                    }

                                    if (NoLineAndPin(SREG[i]))
                                    {
                                        drawpins++;
                                    }
                                }
                                enddraw_p = i;
                                if (SREG[enddraw_p - 4] == 0x0201)
                                { //剪线  删除
                                    enddraw_p -= 4;
                                }
                                delnums1 = (enddraw_p - 4 * drawpins - g_patd.draw_add) / 4;

                                for (i = g_patd.line_add; i < g_line_p; i++)
                                { //线条数据
                                    if (SREG[i] == delnums1)
                                    {
                                        endline_p = i;
                                        break;
                                    }
                                }
                                endpat_p = (endline_p - g_patd.line_add) * 2 + g_patd.pat_add; //针数据

                                //#if Debug
                                //	printf("delnums1 = %d  enddraw_p = %d  endline_p = %d  endpat_p = %d\r\n",delnums1,enddraw_p,endline_p,endpat_p);
                                //#endif
                            }
                            else
                            { //清除结束点空送
                                for (i = g_patd.draw_add; i < g_draw_p; i += 4)
                                { //绘图数据
                                    if (((SREG[i] == 0x1e01) && (SREG[i + 1] == 0x0)) || ((SREG[i] == 0x1f01) && (SREG[i + 1] == 0x0)))
                                    {
                                        break;
                                    }
                                    if (((SREG[i] == 0x0088) && (SREG[i + 1] == 0x7800)) || (SREG[i] == 0x0201))
                                    { //空送或剪线不记录
                                    }
                                    else
                                    {
                                        enddraw_p = i + 4;
                                    }

                                    if (NoLineAndPin(SREG[i]))
                                    {
                                        drawpins++;
                                    }
                                }
                                //#if Debug
                                //printf("enddraw_p--  = %d \r\n",enddraw_p);
                                //#endif
                                if (SREG[enddraw_p - 4] == 0x0201)
                                { //剪线  删除
                                    enddraw_p -= 4;
                                }
                                delnums1 = (enddraw_p - 4 * drawpins - g_patd.draw_add) / 4;
                                for (i = g_patd.line_add; i < g_line_p; i++)
                                { //线条数据
                                    if (SREG[i] == delnums1)
                                    {
                                        endline_p = i;
                                        break;
                                    }
                                }
                                endpat_p = (endline_p - g_patd.line_add) * 2 + g_patd.pat_add; //针数据

                                //#if Debug
                                //	printf("delnums1 = %d  enddraw_p = %d  endline_p = %d  endpat_p = %d\r\n",delnums1,enddraw_p,endline_p,endpat_p);
                                //#endif
                            }

                            //#if Debug
                            //	printf("Addtrimflag= %d  tmpline_sum = %d\r\n",Addtrimflag,tmpline_sum);
                            //#endif

                            wdt();
                            if (Addtrimflag)
                            { //添加一针剪线
                                NEWSREG[tmpdraw_p1++] = 0x0201;
                                NEWSREG[tmpdraw_p1++] = 0x0;
                                NEWSREG[tmpdraw_p1++] = 0x0;
                                NEWSREG[tmpdraw_p1++] = 0x0;

                                NEWSREG[tmpline_p1++] = tmpline_sum /* + Addtrimflag*/;

                                NEWSREG[tmppat_p1++] = 0x0002;
                                NEWSREG[tmppat_p1++] = 0x0;

                                addfeeds++;
                                tmpline_sum1++;
                            }
                            //#if Debug
                            //	printf("----------绘图数据--------------	stdraw_p = %d\r\n",stdraw_p);
                            //	for(i=36;i<tmpdraw_p1;i+=4){
                            //		printf("bNEWSREG[%d] = %04x  NEWSREG[%d] = %04x  NEWSREG[%d] = %04x  NEWSREG[%d] = %04x\r\n",i,NEWSREG[i],i+1,NEWSREG[i+1],i+2,NEWSREG[i+2],i+3,NEWSREG[i+3]);
                            //	}
                            //#endif
                            wdt();
                            for (i = 0; i < (enddraw_p - stdraw_p); i += 4)
                            { //绘图数据
                                if ((SREG[stdraw_p + i] == 0x0601) && (SREG[stdraw_p + i + 1] == 0x0))
                                { //次原点 不要
                                    continue;
                                }
                                NEWSREG[tmpdraw_p1++] = SREG[stdraw_p + i];
                                NEWSREG[tmpdraw_p1++] = SREG[stdraw_p + i + 1];
                                NEWSREG[tmpdraw_p1++] = SREG[stdraw_p + i + 2];
                                NEWSREG[tmpdraw_p1++] = SREG[stdraw_p + i + 3];
                                //#if Debug
                                //printf("NEWSREG[%d] = %04x   NEWSREG[%d] = %04x  NEWSREG[%d] = %04x	  NEWSREG[%d] = %04x\r\n",tmpdraw_p1-4,NEWSREG[tmpdraw_p1-4],tmpdraw_p1-3,NEWSREG[tmpdraw_p1-3],tmpdraw_p1-2,NEWSREG[tmpdraw_p1-2],tmpdraw_p1-1,NEWSREG[tmpdraw_p1-1]);
                                //#endif
                            }
                            //#if Debug
                            //	printf("----------线条数据--------------\r\n");
                            //	for(i=32000 ;i<tmpline_p1;i++){
                            //		printf("bNEWSREG[%d] = %04x \r\n",i,NEWSREG[i]);
                            //	}
                            //#endif
                            wdt();
                            for (i = 0; i < (endline_p - stline_p); i++)
                            { //线条数据
                                if ((newhomeflag == 1) && (SREG[stline_p + i] == newhomelines))
                                { //次原点 不要
                                    delnums++;
                                    continue;
                                }
                                NEWSREG[tmpline_p1++] = SREG[stline_p + i] - delnums + tmpline_sum + Addtrimflag;
                                if (i == 0)
                                {
                                    tmpline_sum1++;
                                }
                                else
                                {
                                    if (SREG[stline_p + i] != SREG[stline_p + i - 1])
                                    {
                                        tmpline_sum1++;
                                    }
                                }

                                //#if Debug
                                //	printf("NEWSREG[%d] = %04x   SREG[%d] = %04x \r\n",tmpline_p1-1,NEWSREG[tmpline_p1-1],stline_p+i,SREG[stline_p+i]);
                                //#endif
                            }

                            //#if Debug
                            //	printf("----------针数据--------------stpat_p = %d\r\n",stpat_p);
                            //	for(i=52000 ;i<tmppat_p1;i+=2){
                            //		printf("bNEWSREG[%d] = %04x NEWSREG[%d] = %04x\r\n",i,NEWSREG[i],i+1,NEWSREG[i+1]);
                            //	}
                            //#endif
                            wdt();
                            for (i = 0; i < (endpat_p - stpat_p); i += 2)
                            { //针数据
                                if (SREG[stpat_p + i] == 0x0006)
                                { //次原点 不要
                                    addfeeds--;
                                    continue;
                                }
                                NEWSREG[tmppat_p1++] = SREG[stpat_p + i];
                                NEWSREG[tmppat_p1++] = SREG[stpat_p + i + 1];
                                //#if Debug
                                //	printf("NEWSREG[%d] = %04x   NEWSREG[%d] = %04x  \r\n",tmppat_p1-2,NEWSREG[tmppat_p1-2],tmppat_p1-1,NEWSREG[tmppat_p1-1]);
                                //#endif
                            }
                            addfeeds += (endpat_p - stpat_p) / 2;
                            wdt();
                            memset((U8 *)SREG, 0, sizeof(SREG));
                            for (i = 0; i < MAXSREG; i++)
                            { //生成花样数据
                                SREG[i] = NEWSREG[i];
                            }

                            tmpfeedsum1 += addfeeds;
                            g_draw_p = tmpdraw_p1;
                            g_line_p = tmpline_p1;
                            g_pat_p = tmppat_p1;
                            g_line_sum = tmpline_sum1;

                            g_feedsum = tmpfeedsum1;
                            g_feedc = tmpfeedsum1;
                            g_patd.feed_sum = g_feedsum;

                            //#if Debug
                            //printf("tmppat_p1 = %d   g_patd.feed_sum = %d\r\n",tmppat_p1,g_patd.feed_sum);
                            //#endif
                            overf = 0;
                            tmppf_absval = g_pfootd.base;
                            tmp_DoTrim = g_DoTrim;
                            g_DoTrim = 0;
                            g_tExCode = 0;
                            for (i = 52000; i < tmppat_p1; i += 2)
                            {
                                dat1 = SREG[i] & 0x00ff;
                                if ((dat1 == 0x61) || (dat1 == 0x41) || (dat1 == 0x21) || (dat1 == 0x1))
                                {
                                    g_DoTrim = 1;
                                }
                                else if ((dat1 == 0x1b) || (dat1 == 0x3) || (dat1 == 0x2))
                                {
                                    g_DoTrim = 0;
                                }

                                if ((dat1 == 0x05) || (dat1 == 0x0b) || (dat1 == 0x0c) || (dat1 == 0x0d) || (dat1 == 0x1d))
                                {
                                    if (dat1 == 0x05)
                                        g_tExCode ^= 0x01;
                                    else if (dat1 == 0x0b)
                                        g_tExCode ^= 0x02;
                                    else if (dat1 == 0x0c)
                                        g_tExCode ^= 0x04;
                                    else if (dat1 == 0x0d)
                                        g_tExCode ^= 0x08;
                                    else
                                    {
                                        if (SREG[i] == 0x001d)
                                            g_tExCode ^= 0x10;
                                        else if (SREG[i] == 0x011d)
                                            g_tExCode ^= 0x20;
                                        else if (SREG[i] == 0x021d)
                                            g_tExCode ^= 0x40;
                                        else if (SREG[i] == 0x031d)
                                            g_tExCode ^= 0x80;
                                    }
                                }
                                if ((dat1 == 0x61) || (dat1 == 0x41) || (dat1 == 0x21) || (dat1 == 0x1) || (dat1 == 0x1b) || (dat1 == 0x3))
                                {

                                    dat1 = SREG[i + 1];
                                    ch = (U8)(dat1);
                                    if (ch >= 0x80)
                                    {
                                        ch -= 0x80;
                                        x1 -= (S16)(ch);
                                    }
                                    else
                                    {
                                        x1 += ch;
                                    }
                                    ch = (U8)((dat1 >> 8));
                                    if (ch >= 0x80)
                                    {
                                        ch -= 0x80;
                                        y1 -= (S16)(ch);
                                    }
                                    else
                                    {
                                        y1 += ch;
                                    }

                                    if ((SREG[i] & 0xff00) != 0)
                                    {
                                        tmppf_absval += (S8)(SREG[i] >> 8);
                                        if (tmppf_absval > PF_ABS_MAX || tmppf_absval < PF_ABS_MIN)
                                        { //中压脚行程超范围
                                            overf = 2;
                                            break;
                                        }
                                    }

                                    if ((x1 < g_Mac.max_xl) || (x1 > g_Mac.max_xr) || (y1 > g_Mac.max_yu) || (y1 < g_Mac.max_yd))
                                    { //图形超范围
                                        overf = 1;
                                        break;
                                    }
                                }
                            }

                            //#if Debug
                            //	printf("g_Mac.max_xl = %d  g_Mac.max_xr = %d g_Mac.max_yu = %d  g_Mac.max_yd = %d  tmppf_absval = %d\r\n",g_Mac.max_xl,g_Mac.max_xr,g_Mac.max_yu,g_Mac.max_yd,tmppf_absval);
                            //#endif
                            wdt();
                            if (overf)
                            { //图形超范围
                                for (i = 0; i < MAXSREG; i++)
                                { //还原当前花样数据
                                    SREG[i] = BLKSREG[i];
                                    NEWSREG[i] = BLKSREG[i];
                                }
                                g_DoTrim = tmp_DoTrim;
                                g_draw_p = tmpdraw_p;
                                g_line_p = tmpline_p;
                                g_pat_p = tmppat_p;

                                g_line_sum = tmpline_sum;
                                g_feedsum = tmpfeedsum;
                                g_feedc = g_feedsum;
                                g_patd.feed_sum = g_feedsum;

                                if (overf == 1)
                                { //图像超范围
                                    hleppara = 119;
                                }
                                else
                                { //中压脚超范围
                                    hleppara = 143;
                                }

                                pno = MENU_RWHELP;
                                poldno[pnoindex] = MENU_DIRCALLFILE;
                                pnoindex++;
                                break;
                            }
                            g_oxpos = x1;
                            g_oypos = y1;

                            if (tmp_pfoot != 0)
                            {                                       //压脚在下面
                                Send_Pfoot(1, MENU_DIRCALLFILE, 1); //压脚升
                            }
                            Comm_Move(g_oxpos, g_oypos, 120, MENU_DIRCALLFILE, 0, 0);

                            //#if Debug
                            //printf("tmpfeedsum1 = %d \r\n",tmpfeedsum1);
                            //#endif
                            g_pf_absval = tmppf_absval;
                            g_updata_pf_valflg = 1;

                            Write_Cmd(C_PFOOTACTION, g_pf_absval, 0); //将中压脚高度设置为追后一针的高度
                            Read_Status();

                            g_modifyflag = 1;
                            excode = g_ExCode ^ g_tExCode;

                            g_pointPinAng = mit_getExCodeData(52000, 52000 + g_feedc * 2, 0);
                            g_pointSetPara1 = mit_getExCodeData(52000, 52000 + g_feedc * 2, 1);
                            g_pointSetPara2 = mit_getExCodeData(52000, 52000 + g_feedc * 2, 2);

                            sendExCodeCmd();

                            if (g_DoTrim == 0)
                                g_feed_sew = 0;
                            g_init_flag = tmpinit_flag;
                            AnaPattern(0, PAT_MIT, 0);
                        }
                        else if (g_GreatPatType == 2)
                        { //生成花样 兄弟

                            //查询原花样最后一针是否为空送或剪线，以判断在连接花样数据时是否添加剪线指令
                            for (i = 0; i < DrawLen; i++)
                            {
                                if ((BLKSREG[i] == 0x0ccd) && (BLKSREG[i + 3] == 0x0400))
                                {
                                    sewInfo.lenaddr = i + 1;
                                    sewInfo.pataddr = i + 6;
                                    sewInfo.ptsize = ((((BLKSREG[sewInfo.lenaddr] & 0xff) << 8) | ((BLKSREG[sewInfo.lenaddr] >> 8) & 0xff)) << 16) | (((BLKSREG[sewInfo.lenaddr + 1] & 0xff) << 8) | ((BLKSREG[sewInfo.lenaddr + 1] >> 8) & 0xff));
                                    break;
                                }
                            }
                            for (i = 0; i < sewInfo.ptsize / 2;)
                            { //查找前面是否是空送或剪线、跳缝指令，不是则添加剪线
                                f = Bor_DrawCmd((U16 *)&BLKSREG[sewInfo.pataddr + i], &sewIcmd);
                                if (f)
                                {
                                    if (((sewIcmd.cmd & 0xf000) == 0x2000) || (sewIcmd.cmd == 0xfd00) || (sewIcmd.cmd == 0xf400))
                                    {
                                        Addtrimflag = 0;
                                    }
                                    else if ((sewIcmd.cmd & 0xf000) == 0x6000)
                                    {
                                        Addtrimflag = 1;
                                    }
                                    i += sewIcmd.off;
                                }
                                else
                                {
                                    i++;
                                }
                            }
                            if (g_patd.feed_sum == 0)
                            {
                                Addtrimflag = 0;
                            }

                            //#if Debug
                            //printf("DrawPatCmd = %04x  len = %d pataddr = %d F_FILETYPE = %d\r\n",DrawPatCmd,len,pataddr,F_FILETYPE);
                            //#endif
                            wdt();
                            if (F_FILETYPE == PAT_MIT)
                            { //三菱 转为兄弟类型
                                Mit_To_Bor(&patlen);
                                patlen /= 2;
                                memset((U8 *)NEWSREG, 0, sizeof(NEWSREG));
                                for (i = 0; i < MAXSREG; i++)
                                {
                                    NEWSREG[i] = BLKSREG[i];
                                }
                            }
                            wdt();
                            if (g_disk_memory && (F_FILETYPE != 1))
                            {
                                for (i = 0; i < MAXSREG; i++)
                                {
                                    NEWSREG[i] = BLKSREG[i];
                                }
                            }

                            for (i = 0; i < MAXHREG; i++)
                            { //还原当前花样文件信息
                                HREG[i] = BLKHREG[i];
                            }
                            wdt();
                            //计算需要连接的花样数据
                            Bor_AnaInfo((U16 *)SREG, patlen * 2, &sewInfo);

                            g_patd.orgX = ((SREG[sewInfo.orgaddr] & 0xff) << 8) | ((SREG[sewInfo.orgaddr] >> 8 & 0xff));
                            g_patd.orgY = ((SREG[sewInfo.orgaddr + 1] & 0xff) << 8) | ((SREG[sewInfo.orgaddr + 1] >> 8 & 0xff));

                            //#if Debug
                            //printf("len = %d pataddr = %d  patlen = %d\r\n",len,pataddr,patlen);
                            //#endif

                            exStflag = 0;
                            Staddr = sewInfo.pataddr;
                            Endaddr = Staddr + sewInfo.ptsize / 2;

                            wdt();
                            //计算起点数据地址
                            if (StPointFlag)
                            { //保留原点到起针点的移送

                                Staddr = sewInfo.pataddr;
                                if ((g_patd.orgX != 0) || (g_patd.orgY != 0))
                                {
                                    exStflag = 1;
                                }
                                else
                                {
                                    if ((SREG[Staddr] & 0xf0) != 0x20)
                                        Addtrimflag = 0; //不是空送，不需添加剪线
                                }
                            }
                            else
                            { //清除原点到起针点的移送
                                if ((g_patd.orgX != 0) || (g_patd.orgY != 0))
                                {
                                    Staddr = sewInfo.pataddr;
                                    if ((SREG[Staddr] & 0xf0) != 0x20)
                                        Addtrimflag = 0; //不是空送，不需添加剪线
                                }
                                else
                                {
                                    for (i = 0; i < sewInfo.ptsize / 2;)
                                    {
                                        f = Bor_DrawCmd((U16 *)&SREG[sewInfo.pataddr + i], &sewIcmd);
                                        if (f)
                                        {
                                            if (((sewIcmd.cmd & 0xf000) != 0x2000) && (sewIcmd.cmd != 0xfd00) && (sewIcmd.cmd != 0xf400))
                                            {
                                                break;
                                            }
                                            i += sewIcmd.off;
                                            Staddr = sewInfo.pataddr + i;
                                        }
                                        else
                                        {
                                            i++;
                                        }
                                    }
                                    Addtrimflag = 0;
                                }
                            }
                            wdt();
                            //计算结束点数据地址
                            if (EndPointFlag)
                            { //保留结束点空送
                                for (i = 0; i < sewInfo.ptsize / 2;)
                                {
                                    f = Bor_DrawCmd((U16 *)&SREG[sewInfo.pataddr + i], &sewIcmd);
                                    if (f)
                                    {
                                        if (sewIcmd.cmd != 0xff00)
                                        {
                                            Endaddr = sewInfo.pataddr + i + sewIcmd.off;
                                        }
                                        else
                                            break;
                                        i += sewIcmd.off;
                                    }
                                    else
                                    {
                                        i++;
                                    }
                                }
                            }
                            else
                            { //清除结束点空送
                                for (i = 0; i < sewInfo.ptsize / 2;)
                                {
                                    f = Bor_DrawCmd((U16 *)&SREG[sewInfo.pataddr + i], &sewIcmd);
                                    if (f)
                                    {
                                        if (((sewIcmd.cmd & 0xf000) != 0x2000) && (sewIcmd.cmd != 0xfd00) && (sewIcmd.cmd != 0xff00))
                                        {
                                            Endaddr = sewInfo.pataddr + i + sewIcmd.off;
                                        }
                                        i += sewIcmd.off;
                                    }
                                    else
                                    {
                                        i++;
                                    }
                                }
                            }

                            dlen = Endaddr - Staddr + (exStflag == 1 ? 4 : 0) + Addtrimflag;
                            g_Ctstaddr = g_Ctendaddr;
                            tmpaddr1 = g_Ctstaddr;
                            for (i = 0; i < (DrawLen - g_Ctstaddr); i++)
                            { //数据后移8或9个字节长度
                                NEWSREG[DrawLen - 1 - i + dlen] = NEWSREG[DrawLen - 1 - i];
                                //#if Debug
                                //printf("BLKSREG[%d] = %04x   \r\n",DrawLen-1-i+dlen,NEWSREG[DrawLen-1-i+dlen]) ;
                                //#endif
                            }

                            if (Addtrimflag)
                            { //添加剪线指令
                                NEWSREG[g_Ctstaddr] = 0x00fd;
                                g_Ctstaddr += Addtrimflag;
                            }

                            if (exStflag)
                            {
                                if (g_patd.orgX >= 0)
                                { //X+
                                    if ((g_patd.orgY) >= 0)
                                    { //Y+
                                        NEWSREG[g_Ctstaddr] = (((abs(g_patd.orgX) >> 8) & 0xff) << 8) | 0x22;
                                        NEWSREG[g_Ctstaddr + 1] = ((abs(g_patd.orgX) & 0xff) << 8) | 0x00;
                                        NEWSREG[g_Ctstaddr + 2] = (((abs(g_patd.orgY) >> 8) & 0xff) << 8) | 0x0A;
                                        NEWSREG[g_Ctstaddr + 3] = ((abs(g_patd.orgY) & 0xff) << 8) | 0x08;
                                    }
                                    else
                                    { //Y-
                                        NEWSREG[g_Ctstaddr] = (((abs(g_patd.orgX) >> 8) & 0xff) << 8) | 0x22;
                                        NEWSREG[g_Ctstaddr + 1] = ((abs(g_patd.orgX) & 0xff) << 8) | 0x00;
                                        NEWSREG[g_Ctstaddr + 2] = (((abs(g_patd.orgY) >> 8) & 0xff) << 8) | 0x0E;
                                        NEWSREG[g_Ctstaddr + 3] = ((abs(g_patd.orgY) & 0xff) << 8) | 0x0C;
                                    }
                                }
                                else
                                { //X-
                                    if (g_patd.orgY >= 0)
                                    { //Y+
                                        NEWSREG[g_Ctstaddr] = (((abs(g_patd.orgX) >> 8) & 0xff) << 8) | 0x26;
                                        NEWSREG[g_Ctstaddr + 1] = ((abs(g_patd.orgX) & 0xff) << 8) | 0x04;
                                        NEWSREG[g_Ctstaddr + 2] = (((abs(g_patd.orgY) >> 8) & 0xff) << 8) | 0x0A;
                                        NEWSREG[g_Ctstaddr + 3] = ((abs(g_patd.orgY) & 0xff) << 8) | 0x08;
                                    }
                                    else
                                    { //Y-
                                        NEWSREG[g_Ctstaddr] = (((abs(g_patd.orgX) >> 8) & 0xff) << 8) | 0x26;
                                        NEWSREG[g_Ctstaddr + 1] = ((abs(g_patd.orgX) & 0xff) << 8) | 0x04;
                                        NEWSREG[g_Ctstaddr + 2] = (((abs(g_patd.orgY) >> 8) & 0xff) << 8) | 0x0E;
                                        NEWSREG[g_Ctstaddr + 3] = ((abs(g_patd.orgY) & 0xff) << 8) | 0x0C;
                                    }
                                }
                                g_Ctstaddr += 4;
                            }
                            for (i = 0; i < (Endaddr - Staddr); i++)
                            {
                                NEWSREG[g_Ctstaddr + i] = SREG[Staddr + i];
                                //#if Debug
                                //printf("NEWSREG[%d] = %04x   \r\n",g_Ctstaddr+i,NEWSREG[g_Ctstaddr+i]) ;
                                //#endif
                            }

                            memset((U8 *)SREG, 0, sizeof(SREG));
                            for (i = 0; i < MAXSREG; i++)
                            { //生成花样数据
                                SREG[i] = NEWSREG[i];
                            }

                            DrawLen += dlen;
                            Bor_AnaInfo((U16 *)SREG, DrawLen * 2, &sewInfo);

                            sewInfo.ptsize += 2 * dlen;
                            SREG[sewInfo.lenaddr] = (((sewInfo.ptsize >> 16) & 0xff) << 8) | ((sewInfo.ptsize >> 24) & 0xff);
                            SREG[sewInfo.lenaddr + 1] = (((sewInfo.ptsize >> 0) & 0xff) << 8) | ((sewInfo.ptsize >> 8) & 0xff);

                            g_patd.orgX = ((SREG[sewInfo.orgaddr] & 0xff) << 8) | ((SREG[sewInfo.orgaddr] >> 8 & 0xff));
                            g_patd.orgY = ((SREG[sewInfo.orgaddr + 1] & 0xff) << 8) | ((SREG[sewInfo.orgaddr + 1] >> 8 & 0xff));

                            overf = 0;

                            Bor_CalPFlimt((U16 *)&SREG, DrawLen * 2, &tmppfmax, &tmppfmin); //计算中压脚极限
                            //#if Debug
                            //printf("tmppfmax = %d  tmppfmin = %d \r\n",tmppfmax,tmppfmin);
                            //#endif
                            if ((tmppfmax + g_pfootd.base > PF_ABS_MAX) || (tmppfmax + g_pfootd.base < PF_ABS_MIN) || (tmppfmin + g_pfootd.base > PF_ABS_MAX) || (tmppfmin + g_pfootd.base < PF_ABS_MIN))
                            {
                                overf = 2;
                            }
                            //计算修改后花样范围
                            Bor_CalPatLim((U16 *)SREG, DrawLen * 2, &Xposmax, &Xposmin, &Yposmax, &Yposmin, &g_patd.feed_sum);

                            g_ctAddpins = g_patd.feed_sum - tfeedsum;
                            SREG[sewInfo.limaddr] = (((Xposmax)&0xff) << 8) | ((((Xposmax) >> 8) & 0xff));
                            SREG[sewInfo.limaddr + 1] = (((Xposmin)&0xff) << 8) | ((((Xposmin) >> 8) & 0xff));
                            SREG[sewInfo.limaddr + 2] = (((Yposmax)&0xff) << 8) | ((((Yposmax) >> 8) & 0xff));
                            SREG[sewInfo.limaddr + 3] = (((Yposmin)&0xff) << 8) | ((((Yposmin) >> 8) & 0xff));

                            if (DrawLen > MAXSREG)
                            {
                                overf = 3;
                            }
                            if ((Xposmax > 2 * g_Mac.max_xr) || (Xposmin < 2 * g_Mac.max_xl) || (Yposmax > 2 * g_Mac.max_yu) || (Yposmin < 2 * g_Mac.max_yd) || (DrawLen > MAXSREG))
                            {
                                overf = 1;
                            }

                            if (overf)
                            {
                                for (i = 0; i < MAXSREG; i++)
                                { //还原当前花样数据
                                    SREG[i] = BLKSREG[i];
                                    NEWSREG[i] = BLKSREG[i];
                                    //#if Debug
                                    //if(i<g_CtPatLen/2)
                                    //printf("ss SREG[%d] = %04x \r\n",i,SREG[i]);
                                    //#endif
                                }

                                g_Ctendaddr = tmpCreatenaddr;
                                g_Ctstaddr = tmpCreatstaddr;
                                g_patd.feed_sum = tmpfeedsum;
                                g_patd.orgX = tmporgX;
                                g_patd.orgY = tmporgY;

                                if (overf == 3)
                                    hleppara = 120;
                                else if (overf == 2)
                                    hleppara = 143;
                                else
                                    hleppara = 119;
                                pno = MENU_RWHELP;
                                poldno[pnoindex] = MENU_DIRCALLFILE;
                                pnoindex++;
                                break;
                            }
                            if (g_ct_insert_flag == 2)
                            {
                                g_modifyflag = 1;
                                g_Ctendaddr += dlen;
                                g_CtPatLen = 2 * DrawLen;
                                g_feedsum = g_patd.feed_sum;

                                //空送回原来位置
                                //Bor_feedInfo(g_patd.feed_sum,g_CtPatLen,&tmpBorcmd,(S16*)&g_oxpos,(S16*)&g_oypos,(S16*)&g_dxpos,(S16*)&g_dypos,(U8*)&g_oldspeed,&tmpBorpooft,&Borpfdis);  //查找当前原花样结束点坐标
                                Bor_feedInfo(g_feedc + g_ctAddpins + 1, g_CtPatLen, &tmpBorcmd, &tmppx, (S16 *)&tmppy, (S16 *)&tmpdx, (S16 *)&tmpdy, &tmpspeed, &tmpBorpooft, &Borpfdis);
                                //printf("g_oxpos = %d  g_oypos = %d  tmppx = %d  tmppy = %d g_patd.feed_sum =  %d  tfeedsum = %d\r\n",g_oxpos,g_oypos,tmppx,tmppy,g_patd.feed_sum,tfeedsum);
                                if (g_oxpos != tmppx || g_oypos != tmppy)
                                {
                                    g_Ctstaddr = g_Ctendaddr;
                                    f = Bor_CreatData((U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, 0, 0, (g_oxpos - tmppx), (g_oypos - tmppy), 0, (U32 *)&g_CtPatLen, 1, 0);
                                    Bor_CalPatLim((U16 *)SREG, g_CtPatLen, &Xposmax, &Xposmin, &Yposmax, &Yposmin, &g_patd.feed_sum);
                                    //g_ctAddpins += (g_Ctendaddr-g_Ctstaddr)/4 + ((g_Ctendaddr-g_Ctstaddr)%4?1:0);
                                    //printf("- g_patd.feed_sum =  %d  tfeedsum = %d\r\n",g_patd.feed_sum,tfeedsum);
                                }
                                HREG[5] = (g_CtPatLen >> 16) & 0xffff;
                                HREG[4] = g_CtPatLen & 0xffff;
                                //printf("g_patd.patmX = %d  g_patd.patiX = %d  g_patd.patmY = %d  g_patd.patiY = %d \r\n",g_patd.patmX,g_patd.patiX,g_patd.patmY,g_patd.patiY);

                                g_patd.patmX = Xposmax;
                                g_patd.patiX = Xposmin;
                                g_patd.patmY = Yposmax;
                                g_patd.patiY = Yposmin;
                                g_Ctsavetimes = 0;
                                g_blkInset = 0;
                                g_Ctstaddr = sew_getPinAddr((U16 *)SREG, g_CtPatLen, g_feedc, 1);
                                //printf("--g_patd.patmX = %d  g_patd.patiX = %d  g_patd.patmY = %d  g_patd.patiY = %d \r\n",g_patd.patmX,g_patd.patiX,g_patd.patmY,g_patd.patiY);
                                Bor_CreatBack((U16 *)&g_Ctsavetimes, g_Ctstaddr, g_Ctstaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);

                                g_ct_status_flag = 0x7cfdf;
                                g_ct_status_flag |= bit19;
                                g_feedsum = g_patd.feed_sum;

                                g_array4[0][0] = 0;
                                g_point_num = 1;
                                g_ct_insert_flag = 3;
                            }
                            else
                            {
                                Bor_feedInfo(g_patd.feed_sum, g_CtPatLen, &tmpBorcmd, (S16 *)&g_oxpos, (S16 *)&g_oypos, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &tmpBorpooft, &Borpfdis); //查找当前原花样结束点坐标
                                                                                                                                                                                                       //								g_isBAT = 0;	//清除跳缝标志
                                excode = g_ExCode ^ g_tExCode;
                                sendExCodeCmd();

                                if (tmp_pfoot != 0)
                                {                                       //压脚在下面
                                    Send_Pfoot(1, MENU_DIRCALLFILE, 1); //压脚升
                                }
                                Comm_Move(g_oxpos + g_dxpos, g_oypos + g_dypos, 120, MENU_DIRCALLFILE, 1, 0);

                                g_patd.patmX = Xposmax;
                                g_patd.patiX = Xposmin;
                                g_patd.patmY = Yposmax;
                                g_patd.patiY = Yposmin;

                                g_oxpos += g_dxpos;
                                g_oypos += g_dypos;
                                g_disxpos = g_oxpos;
                                g_disypos = g_oypos;
                                g_dxpos = 0;
                                g_dypos = 0;
                                g_feedsum = g_patd.feed_sum;
                                g_feedc = g_patd.feed_sum;

                                g_modifyflag = 1;
                                g_Ctendaddr += dlen;
                                g_CtPatLen = 2 * DrawLen;
                                HREG[5] = (g_CtPatLen >> 16) & 0xffff;
                                HREG[4] = g_CtPatLen & 0xffff;

                                Bor_CreatBack((U16 *)&g_Ctsavetimes, tmpaddr1, g_Ctendaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);
                                g_ct_status_flag = 0;

                                Bor_CalPFval((U16 *)SREG, g_CtPatLen, g_Ctendaddr, (S16 *)&g_pf_absval);
                                g_pf_absval += g_pfootd.base;
                                //							g_pf_absval = tmppfmax+g_pfootd.base;
                                g_updata_pf_valflg = 1;
                                Write_Cmd(C_PFOOTACTION, g_pf_absval, 0); //将中压脚高度设置为追后一针的高度
                                Read_Status();
                            }
                        }
                        if (g_disk_memory != 0)
                        { //重新读回内存文件索引
                            f = ReadFileIndex(C_RDMEMPATLIST, MENU_DIRCALLFILE);
                            if (f == 0)
                            {
                                pno = MENU_RWHELP;
                                hleppara = 15;
                                poldno[pnoindex] = MENU_DIRCALLFILE;
                                pnoindex++;
                                break;
                            }
                            g_disk_memory = 0;
                        }
                        pnoindex -= 2;
                        pno = poldno[pnoindex];

                        if (excode != 0)
                        {
                            OutputExcode(excode, pno);
                        }
                        g_maxX = g_patd.patmX;
                        g_minX = g_patd.patiX;
                        g_maxY = g_patd.patmY;
                        g_minY = g_patd.patiY;
                    }
                    else
                    {
                        //#if Debug
                        //printf("--------show time g_GreatPatType = %d F_FILETYPE = %d DrawLen = %d\r\n",g_GreatPatType,F_FILETYPE,DrawLen);
                        //#endif
                        if (g_GreatPatType == 1)
                        { //生成mit格式
                        }
                        else if (g_GreatPatType == 2)
                        { //生成sew格式
                            //查询原花样最后一针是否为空送或剪线，以判断在连接花样数据时是否添加剪线指令
                            for (i = 0; i < DrawLen; i++)
                            {
                                if ((BLKSREG[i] == 0x0ccd) && (BLKSREG[i + 3] == 0x0400))
                                {
                                    sewInfo.lenaddr = i + 1;
                                    sewInfo.pataddr = i + 6;
                                    sewInfo.ptsize = ((((BLKSREG[sewInfo.lenaddr] & 0xff) << 8) | ((BLKSREG[sewInfo.lenaddr] >> 8) & 0xff)) << 16) | (((BLKSREG[sewInfo.lenaddr + 1] & 0xff) << 8) | ((BLKSREG[sewInfo.lenaddr + 1] >> 8) & 0xff));
                                    break;
                                }
                            }
                            Addtrimflag = 0;
                            for (i = 0; i < sewInfo.ptsize / 2;)
                            { //查找前面是否是空送或剪线、跳缝指令，不是则添加剪线
                                f = Bor_DrawCmd((U16 *)&BLKSREG[sewInfo.pataddr + i], &sewIcmd);
                                if (f)
                                {
                                    if (((sewIcmd.cmd & 0xf000) == 0x2000) || (sewIcmd.cmd == 0xfd00) || (sewIcmd.cmd == 0xf400))
                                    {
                                        Addtrimflag = 0;
                                    }
                                    else if ((sewIcmd.cmd & 0xf000) == 0x6000)
                                    {
                                        Addtrimflag = 1;
                                    }
                                    i += sewIcmd.off;
                                }
                                else
                                {
                                    i++;
                                }
                            }
                            if (g_patd.feed_sum == 0)
                            {
                                Addtrimflag = 0;
                            }

                            if (F_FILETYPE == PAT_MIT)
                            { //三菱 转为兄弟类型
                                Mit_To_Bor(&patlen);
                                patlen /= 2;
                                memset((U8 *)NEWSREG, 0, sizeof(NEWSREG));
                                for (i = 0; i < MAXSREG; i++)
                                {
                                    NEWSREG[i] = BLKSREG[i];
                                }
                            }
                            patlen = Bor_copyImgs((U16 *)SREG, (U16 *)NEWSREG, patlen * 2);
                            //printf("patlen = %d \r\n",patlen);
                            if (patlen == 0)
                            { //失败
                                for (i = 0; i < MAXSREG; i++)
                                { //还原当前花样数据
                                    SREG[i] = BLKSREG[i];
                                    NEWSREG[i] = BLKSREG[i];
                                    //#if Debug
                                    //if(i<g_CtPatLen/2)
                                    //printf("ss SREG[%d] = %04x   overf = %d \r\n",i,SREG[i],overf);
                                    //#endif
                                }

                                g_Ctendaddr = tmpCreatenaddr;
                                g_Ctstaddr = tmpCreatstaddr;
                                g_patd.feed_sum = tmpfeedsum;
                                g_patd.orgX = tmporgX;
                                g_patd.orgY = tmporgY;

                                hleppara = 119;
                                pno = MENU_RWHELP;
                                poldno[pnoindex++] = MENU_DIRCALLFILE;
                                break;
                            }
                            if (Addtrimflag)
                            {
                                for (i = 0; i < patlen / 2;)
                                { //生成数据第一针是否需要剪线
                                    f = Bor_DrawCmd((U16 *)&NEWSREG[i], &sewIcmd);
                                    if (f)
                                    {
                                        if (((sewIcmd.cmd & 0xf000) == 0x2000))
                                        {
                                            Addtrimflag = 1;
                                            break;
                                        }
                                        else if (((sewIcmd.cmd & 0xf000) == 0x6000) || (sewIcmd.cmd == 0xfd00) || (sewIcmd.cmd == 0xf400))
                                        {
                                            Addtrimflag = 0;
                                            break;
                                        }
                                        i += sewIcmd.off;
                                    }
                                    else
                                    {
                                        i++;
                                    }
                                }
                            }

                            memset((U8 *)SREG, 0, sizeof(SREG));
                            for (i = 0; i < patlen / 2; i++)
                            {
                                SREG[i] = NEWSREG[i];
                                //									#if Debug
                                //									printf("SREG[%d] = %04x \r\n",i,SREG[i]);
                                //									#endif
                            }
                            memset((U8 *)NEWSREG, 0, sizeof(NEWSREG));
                            wdt();

                            for (i = 0; i < MAXSREG; i++)
                            {
                                NEWSREG[i] = BLKSREG[i];
                            }
                            for (i = 0; i < MAXHREG; i++)
                            { //还原当前花样文件信息
                                HREG[i] = BLKHREG[i];
                            }
                            wdt();

                            g_Ctstaddr = g_Ctendaddr;
                            tmpaddr1 = g_Ctstaddr;
                            dlen = patlen + 2 * Addtrimflag;
                            //#if Debug
                            //printf("0 g_Ctstaddr = %d  g_Ctendaddr = %d  g_CtPatLen = %d \r\n",g_Ctstaddr,g_Ctendaddr,g_CtPatLen);
                            //#endif
                            for (i = 0; i < (DrawLen - g_Ctstaddr); i++)
                            {
                                NEWSREG[DrawLen - 1 - i + dlen / 2] = NEWSREG[DrawLen - 1 - i];
                            }
                            if (Addtrimflag)
                            {
                                NEWSREG[g_Ctstaddr] = 0x00fd; //添加剪线
                            }
                            for (i = 0; i < patlen / 2; i++)
                            {
                                NEWSREG[g_Ctstaddr + i + Addtrimflag] = SREG[i];
                            }
                            memset((U8 *)SREG, 0, sizeof(SREG));
                            //生成花样数据
                            for (i = 0; i < MAXSREG; i++)
                            {
                                SREG[i] = NEWSREG[i];
                            }
                            DrawLen += dlen / 2;
                            Bor_AnaInfo((U16 *)SREG, DrawLen * 2, &sewInfo);

                            sewInfo.ptsize += dlen;
                            SREG[sewInfo.lenaddr] = (((sewInfo.ptsize >> 16) & 0xff) << 8) | ((sewInfo.ptsize >> 24) & 0xff);
                            SREG[sewInfo.lenaddr + 1] = (((sewInfo.ptsize >> 0) & 0xff) << 8) | ((sewInfo.ptsize >> 8) & 0xff);

                            g_patd.orgX = ((SREG[sewInfo.orgaddr] & 0xff) << 8) | ((SREG[sewInfo.orgaddr] >> 8 & 0xff));
                            g_patd.orgY = ((SREG[sewInfo.orgaddr + 1] & 0xff) << 8) | ((SREG[sewInfo.orgaddr + 1] >> 8 & 0xff));

                            overf = 0;
                            Bor_CalPFlimt((U16 *)&SREG, DrawLen * 2, &tmppfmax, &tmppfmin); //计算中压脚极限

                            if ((tmppfmax + g_pfootd.base > PF_ABS_MAX) || (tmppfmax + g_pfootd.base < PF_ABS_MIN) || (tmppfmin + g_pfootd.base > PF_ABS_MAX) || (tmppfmin + g_pfootd.base < PF_ABS_MIN))
                            {
                                overf = 2;
                            }
                            //#if Debug
                            //printf("tmppfmax = %d  tmppfmin = %d  overf = %d \r\n",tmppfmax,tmppfmin,overf);
                            //#endif
                            //计算修改后花样范围
                            Bor_CalPatLim((U16 *)SREG, DrawLen * 2, &Xposmax, &Xposmin, &Yposmax, &Yposmin, &g_patd.feed_sum);

                            SREG[sewInfo.limaddr] = (((Xposmax)&0xff) << 8) | ((((Xposmax) >> 8) & 0xff));
                            SREG[sewInfo.limaddr + 1] = (((Xposmin)&0xff) << 8) | ((((Xposmin) >> 8) & 0xff));
                            SREG[sewInfo.limaddr + 2] = (((Yposmax)&0xff) << 8) | ((((Yposmax) >> 8) & 0xff));
                            SREG[sewInfo.limaddr + 3] = (((Yposmin)&0xff) << 8) | ((((Yposmin) >> 8) & 0xff));

                            //#if Debug
                            //printf("Xposmax = %d  Xposmin = %d  Yposmax = %d Yposmin = %d DrawLen = %d\r\n",Xposmax,Xposmin,Yposmax,Yposmin,DrawLen);
                            //printf("g_Mac.max_xr = %d  g_Mac.max_xl = %d  g_Mac.max_yu = %d g_Mac.max_yd = %d \r\n",g_Mac.max_xr,g_Mac.max_xl,g_Mac.max_yu,g_Mac.max_yd);
                            //#endif
                            if (DrawLen > MAXSREG)
                            {
                                overf = 3;
                            }
                            if ((Xposmax > 2 * g_Mac.max_xr) || (Xposmin < 2 * g_Mac.max_xl) || (Yposmax > 2 * g_Mac.max_yu) || (Yposmin < 2 * g_Mac.max_yd) || (DrawLen > MAXSREG))
                            {
                                overf = 1;
                            }

                            if (overf)
                            {
                                for (i = 0; i < MAXSREG; i++)
                                { //还原当前花样数据
                                    SREG[i] = BLKSREG[i];
                                    NEWSREG[i] = BLKSREG[i];
                                    //#if Debug
                                    //if(i<g_CtPatLen/2)
                                    //printf("ss SREG[%d] = %04x   overf = %d \r\n",i,SREG[i],overf);
                                    //#endif
                                }

                                g_Ctendaddr = tmpCreatenaddr;
                                g_Ctstaddr = tmpCreatstaddr;
                                g_patd.feed_sum = tmpfeedsum;
                                g_patd.orgX = tmporgX;
                                g_patd.orgY = tmporgY;

                                if (overf == 3)
                                    hleppara = 120;
                                else if (overf == 2)
                                    hleppara = 143;
                                else
                                    hleppara = 119;
                                pno = MENU_RWHELP;
                                poldno[pnoindex] = MENU_DIRCALLFILE;
                                pnoindex++;
                                break;
                            }

                            Bor_feedInfo(g_patd.feed_sum, g_CtPatLen, &tmpBorcmd, (S16 *)&g_oxpos, (S16 *)&g_oypos, (S16 *)&g_dxpos, (S16 *)&g_dypos, (U8 *)&g_oldspeed, &tmpBorpooft, &Borpfdis); //查找当前原花样结束点坐标
                                                                                                                                                                                                   //								g_isBAT = 0;	//清除跳缝标志
                            excode = g_ExCode ^ g_tExCode;

                            if (tmp_pfoot != 0)
                            {                                       //压脚在下面
                                Send_Pfoot(1, MENU_DIRCALLFILE, 1); //压脚升
                            }
                            Comm_Move(g_oxpos + g_dxpos, g_oypos + g_dypos, 120, MENU_DIRCALLFILE, 1, 0);

                            g_patd.patmX = Xposmax;
                            g_patd.patiX = Xposmin;
                            g_patd.patmY = Yposmax;
                            g_patd.patiY = Yposmin;

                            g_oxpos += g_dxpos;
                            g_oypos += g_dypos;
                            g_disxpos = g_oxpos;
                            g_disypos = g_oypos;
                            g_dxpos = 0;
                            g_dypos = 0;
                            g_feedsum = g_patd.feed_sum;
                            g_feedc = g_patd.feed_sum;

                            g_modifyflag = 1;
                            g_Ctendaddr += dlen / 2;
                            g_CtPatLen = 2 * DrawLen;
                            HREG[5] = (g_CtPatLen >> 16) & 0xffff;
                            HREG[4] = g_CtPatLen & 0xffff;

                            Bor_CreatBack((U16 *)&g_Ctsavetimes, tmpaddr1, g_Ctendaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);
                            g_ct_status_flag = 0;

                            Bor_CalPFval((U16 *)SREG, g_CtPatLen, g_Ctendaddr, (S16 *)&g_pf_absval);
                            g_pf_absval += g_pfootd.base;
                            //							g_pf_absval = tmppfmax+g_pfootd.base;
                            g_updata_pf_valflg = 1;
                            Write_Cmd(C_PFOOTACTION, g_pf_absval, 0); //将中压脚高度设置为追后一针的高度
                            Read_Status();
                        }
                        if (g_disk_memory != 0)
                        { //重新读回内存文件索引
                            f = ReadFileIndex(C_RDMEMPATLIST, MENU_DIRCALLFILE);
                            if (f == 0)
                            {
                                pno = MENU_RWHELP;
                                hleppara = 15;
                                poldno[pnoindex] = MENU_DIRCALLFILE;
                                pnoindex++;
                                break;
                            }
                            g_disk_memory = 0;
                        }
                        // pnoindex = 2;
                        // pno = MENU_CURSOR;
                        pnoindex -= 2;
                        pno = poldno[pnoindex];

                        if (excode != 0)
                        {
                            OutputExcode(excode, pno);
                        }
                        g_maxX = g_patd.patmX;
                        g_minX = g_patd.patiX;
                        g_maxY = g_patd.patmY;
                        g_minY = g_patd.patiY;

                        //#if Debug
                        //printf("1 g_Ctstaddr = %d  g_Ctendaddr = %d  g_CtPatLen = %d \r\n",g_Ctstaddr,g_Ctendaddr,g_CtPatLen);
                        //#endif
                    }
                }
            }
            else
            {
                switch (keyoff)
                {
                case KEY_DIRCALLFILE_SCRNSVR:
                    pno = MENU_SCRNSVR;
                    break;
                case KEY_DIRCALLFILE_BACK:
                    pnoindex--;
                    pno = poldno[pnoindex];
                    break;

                case KEY_DIRCALLFILE_CLEAN:
                    if (patno)
                    {
                        patno /= 10;
                        dis_updata1 = 1;
                    }
                    else if (disall == 0)
                    {
                        disall = 1;
                        dis_updata1 = 1;
                        // PatternList.bflashAllFlag = 1;
                        // DrawFillRect(194, 152, 58, 32, Color_Blue);
                    }
                    break;

                case KEY_DIRCALLFILE_PREV:
                    if (PatternList.pageNow > 1)
                    {
                        PatternList.pageNow--;
                        PatternList.bFlashPageFlag = 1;
                    }
                    break;
                case KEY_DIRCALLFILE_NEXT:
                    if (PatternList.pageNow < PatternList.pageNum)
                    {
                        PatternList.pageNow++;
                        PatternList.bFlashPageFlag = 1;
                    }
                    break;

                case KEY_DIRCALLFILE_START:
                    if (StPointFlag)
                        StPointFlag = 0;
                    else
                        StPointFlag = 1;

                    dis_updata4 = 1;
                    break;

                case KEY_DIRCALLFILE_END:
                    if (EndPointFlag)
                        EndPointFlag = 0;
                    else
                        EndPointFlag = 1;

                    dis_updata4 = 1;
                    break;
                }
            }
            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            if (keyon == KEY_DIRCALLFILE_SCRNSVR || keyon == KEY_DIRCALLFILE_OK ||
                (keyon >= KEY_DIRCALLFILE_SEL1 && keyon <= KEY_DIRCALLFILE_SEL9)) //无按键特效
            {
            }
            //非常规按键
            else //常规按键
            {
                DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);
            }
            keyon = 0;
            beeponf = 0;
            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4); //显示回读取模式
            Draw24x24Str(TITLE_XPOS, SAFE_DIST4, MEM_TITLE_ADD + rect[0].index[0] * TitleLengthMax, SheetPage, rect[0].index[0], rect[0].colorT[0]);
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if ((Timerms > 1000))
        {
            Timerms = 0;
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[更新花样数据*begin]**********************************************************
        if (dis_updata3)
        {
            U16 chFileNoTemp = 0, cntTemp = 0;
            dis_updata3 = 0;

            for (cntTemp = 0; cntTemp < PatternList.disNumDiv; cntTemp++)
            {

                if (PatternList.dataAdd[cntTemp] == 0xffff)
                {
                    continue;
                }
                chFileNoTemp = PatternList.dataAdd[cntTemp] / FileIndexSize + MINFILENO;
                f = fun_getPatData(chFileNoTemp, g_disk_memory, MENU_DIRCALLFILE);
                if (f)
                {
                    if (g_disppicflag)
                        refresh5 = 1;
                    g_init_flag = 1;
                    g_data_flash = 1;
                    // g_selectdisno = F_IND_NO;
                }
                else
                {
                    continue;
                }

                wdt();
                DelayMs(20);
                // /[绘制花样与相关信息*begin]******************************************************************************
                if (refresh5)
                {
                    refresh5 = 0;
                    if (cntTemp == PatternList.disNumDiv)
                    {
                        break;
                    }

                    if (S_2HD) //根据次原点信息分析显示花样的数据
                        AnaPattern(1, F_FILETYPE, (((F_FILELENH) << 16) | F_FILELENL));
                    else
                        AnaPattern(0, F_FILETYPE, (((F_FILELENH) << 16) | F_FILELENL));

                    // SetDrawXY(rect[cntTemp + RECT_DIRCALLFILE_IMG1].xpis, rect[cntTemp + RECT_DIRCALLFILE_IMG1].ypis,
                    //           rect[cntTemp + RECT_DIRCALLFILE_IMG1].xpis + CONVAS_X2, rect[cntTemp + RECT_DIRCALLFILE_IMG1].ypis + CONVAS_Y2, 1);
                    // Draw_Pattern(PAT_READ, Scale, orgListX[cntTemp], orgListY[cntTemp], F_FILETYPE, ((F_FILELENH << 16) | F_FILELENL), 0, 0, NULL); // 显示花样 - 三菱款
                    // SetDrawXY(0, 0, LCD_WIDTH, LCD_HEIGHT, 0);
                    pat_setDrawXY(patRule.h_patConvasIndex, rect[cntTemp + RECT_DIRCALLFILE_IMG1].xpis, rect[cntTemp + RECT_DIRCALLFILE_IMG1].ypis);
                    pat_drawPattern(PATRULES_READ, Scale, orgListX[cntTemp], orgListY[cntTemp], F_FILETYPE, F_FILELEN, 0, 0, NULL);
                }
                // /[绘制花样与相关信息*end]******************************************************************************
                wdt();
            }
        }
        // /[更新花样数据*end]**********************************************************

        // /[更新花样显示列表*begin]**********************************************************
        if (PatternList.bflashAllFlag) //索引信息更新
        {
            PatternList.bflashAllFlag = 0;
            PatternList.bFlashPageFlag = 1;

            PatternList.selectNoNow = 0;
            PatternList.patternNum = 0;
            for (i = 0; i < MAXIREG2; i += FileIndexSize) //遍历花样存储空间，获取 最大合花样数量、当前花样序号
            {
                // if ((((IREG2[i + 1] << 16) | IREG2[i]) > 0) &&
                // 	(((IREG2[i + 1] << 16) | IREG2[i]) <= 2 * MAXSREG))
                // {
                // 	PatternList.patternNum++;
                // 	if ((i / FileIndexSize + MINFILENO) <= g_selectdisno)
                // 		PatternList.selectNoNow++;

                if ((((IREG2[i + 1] << 16) | IREG2[i]) > 0) &&
                    (((IREG2[i + 1] << 16) | IREG2[i]) <= 2 * MAXSREG))
                {
                    U16 tmpPatNo = 0;
                    tmpPatNo = i / FileIndexSize + MINFILENO;
                    if (disall) //显示全部
                    {
                        PatternList.patternNum++;
                    }
                    else
                    {
                        if (isViewNo(tmpPatNo, patno))
                        {
                            PatternList.patternNum++;
                        }
                    }
                }
            }

            //确定 当前选中项、当前选中页、页码总数
            PatternList.noInPageNow = (PatternList.selectNoNow - 1) % PatternList.disNumDiv;
            PatternList.noInPageLast = PatternList.noInPageNow;
            PatternList.pageNow = (PatternList.selectNoNow - 1) / PatternList.disNumDiv + 1;
            PatternList.pageLast = PatternList.pageNow;
            PatternList.pageNum = (PatternList.patternNum - 1) / PatternList.disNumDiv + 1;

            if (PatternList.pageNum == 0)
                PatternList.pageNum = 1;

            if (PatternList.pageNow == 0)
                PatternList.pageNow = 1;
            else if (PatternList.pageNow > PatternList.pageNum)
                PatternList.pageNow = PatternList.pageNum;

            if (PatternList.noInPageNow >= PatternList.disNumDiv)
                PatternList.noInPageNow = 0;
        }

        if (PatternList.bFlashPageFlag) //索引换页更新
        {

            U32 numA = 0; //当前页的花样序号基数
            // U32 numB = 0; //当前页的花样序号偏移数
            U32 addA = 0; //当前页的花样序号基地址
            U32 addB = 0; //当前页的花样序号偏移地址
            U32 patternLen = 0;
            U8 patternType = 0;
            U16 disColor = 0;

            PatternList.bFlashPageFlag = 0;
            refresh2 = 1;
            dis_updata3 = 1;

            for (i = 0; i < PatternList.disNumDiv; i++)
            {
                PatternList.selectList[i] = 0;
            }
            // if (PatternList.pageNow == PatternList.pageLast)
            // {
            // 	PatternList.selectList[PatternList.noInPageNow] = 1;
            // }

            // clrfiles = 0;
            // vienos = 0;
            // for (i = 0; i < PatternList.disNumDiv; i++)
            // {
            // 	// DrawFillRect(keyd[KEY_DIRCALLFILE_SEL0 + i].xpis + 19, keyd[KEY_DIRCALLFILE_SEL0 + i].ypis + 12, 58, 32, mCOLOR ? Color_Silver : Color_White1);
            // 	tvpno[i] = 0;
            // }
            // for (i = 0; i < MAXIREG2; i += FileIndexSize)
            // {
            // 	if ((((IREG2[i + 1] << 16) | IREG2[i]) > 0) &&
            // 		(((IREG2[i + 1] << 16) | IREG2[i]) <= 2 * MAXSREG))
            // 	{
            // 		U16 tmpPatNo = 0;
            // 		tmpPatNo = i / FileIndexSize + MINFILENO;
            // 		if (disall) //显示全部
            // 		{
            // 			clrfiles++;
            // 			if (clrfiles > ((selectpage - 1) * PatternList.disNumDiv))
            // 			{
            // 				// DrawLFU32(keyd[KEY_DIRCALLFILE_SEL0 + vienos].xpis + 19, keyd[KEY_DIRCALLFILE_SEL0 + vienos].ypis + 12, tmpPatNo, 3, Color_Black);
            // 				tvpno[vienos] = tmpPatNo;
            // 				vienos++;
            // 				if (vienos == PatternList.disNumDiv)
            // 					break;
            // 			}
            // 		}
            // 		else
            // 		{
            // 			if (isViewNo(tmpPatNo, patno))
            // 			{
            // 				clrfiles++;
            // 				if (clrfiles > ((selectpage - 1) * PatternList.disNumDiv))
            // 				{
            // 					// DrawLFU32(keyd[KEY_DIRCALLFILE_SEL0 + vienos].xpis + 19, keyd[KEY_DIRCALLFILE_SEL0 + vienos].ypis + 12, tmpPatNo, 3, Color_Black);
            // 					tvpno[vienos] = tmpPatNo;
            // 					vienos++;
            // 					if (vienos == PatternList.disNumDiv)
            // 						break;
            // 				}
            // 			}
            // 		}
            // 	}
            // }

            //显示页码
            DrawFillRect(rect[RECT_DIRCALLFILE_PAGE].xpis, rect[RECT_DIRCALLFILE_PAGE].ypis,
                         rect[RECT_DIRCALLFILE_PAGE].xsize, rect[RECT_DIRCALLFILE_PAGE].ysize, rect[RECT_DIRCALLFILE_PAGE].colorB[0]);
            DrawFU32(rect[RECT_DIRCALLFILE_PAGE].xpis + SAFE_DIST2, rect[RECT_DIRCALLFILE_PAGE].ypis + SAFE_DIST4,
                     PatternList.pageNow, 3, rect[RECT_DIRCALLFILE_PAGE].colorT[0]);
            DrawF16Str(rect[RECT_DIRCALLFILE_PAGE].xpis + SAFE_DIST2 + 9 * 3, rect[RECT_DIRCALLFILE_PAGE].ypis + SAFE_DIST4,
                       "/", rect[RECT_DIRCALLFILE_PAGE].colorT[0]);
            DrawFU32(rect[RECT_DIRCALLFILE_PAGE].xpis + SAFE_DIST2 + 9 * 4, rect[RECT_DIRCALLFILE_PAGE].ypis + SAFE_DIST4,
                     PatternList.pageNum, 3, rect[RECT_DIRCALLFILE_PAGE].colorT[0]);

            if (PatternList.patternNum == 0)
                PatternList.noInPageNow = 0xff;
            else if (PatternList.noInPageNow >= PatternList.disNumDiv)
                PatternList.noInPageNow = 0;

            numA = (PatternList.pageNow - 1) * PatternList.disNumDiv;
            if (numA > PatternList.patternNum)
                numA = PatternList.patternNum;
            // numB = PatternList.patternNum % PatternList.disNumDiv;
            // if ((PatternList.noInPageNow >= numB) && (PatternList.pageNow == PatternList.pageNum) && (PatternList.patternNum))
            // 	PatternList.noInPageNow = 0;

            if (numA) //计算当前页的基地址
            {
                for (j = 0, addA = 0; addA < MAXIREG2; addA += FileIndexSize)
                {
                    if ((((IREG2[addA + 1] << 16) | IREG2[addA]) > 0) &&
                        (((IREG2[addA + 1] << 16) | IREG2[addA]) <= 2 * MAXSREG))
                    {
                        U16 tmpPatNo = 0;
                        tmpPatNo = addA / FileIndexSize + MINFILENO;
                        if (disall) //显示全部
                        {
                            j++;
                            if (j > numA)
                                break;
                        }
                        else
                        {
                            if (isViewNo(tmpPatNo, patno))
                            {
                                j++;
                                if (j > numA)
                                    break;
                            }
                        }
                    }
                }
            }
            addB = addA;
            if (numA < PatternList.patternNum) //计算当前页的各个文件的偏移地址
            {
                for (j = 0; addB < MAXIREG2; addB += FileIndexSize)
                {
                    if ((((IREG2[addB + 1] << 16) | IREG2[addB]) > 0) &&
                        (((IREG2[addB + 1] << 16) | IREG2[addB]) <= 2 * MAXSREG))
                    {

                        U16 tmpPatNo = 0;
                        tmpPatNo = addB / FileIndexSize + MINFILENO;
                        if (disall) //显示全部
                        {
                            PatternList.dataAdd[j] = addB;
                            j++;
                            if (((numA + j) >= PatternList.patternNum) || (j >= PatternList.disNumDiv))
                                break;
                        }
                        else
                        {
                            if (isViewNo(tmpPatNo, patno))
                            {
                                PatternList.dataAdd[j] = addB;
                                j++;
                                if (((numA + j) >= PatternList.patternNum) || (j >= PatternList.disNumDiv))
                                    break;
                            }
                        }
                    }
                }
                for (; j < PatternList.disNumDiv; j++) //当前页的剩余文件地址写空
                    PatternList.dataAdd[j] = 0xffff;
            }
            else
            {
                for (j = 0; j < PatternList.disNumDiv; j++) //当前页的剩余文件地址写空
                    PatternList.dataAdd[j] = 0xffff;
            }
            //绘制按钮信息
            for (i = 0; i < PatternList.disNumDiv; i++)
            {
                // DrawFillRect(keyd[i + KEY_DIRCALLFILE_SEL1].xpis + SAFE_DIST2, keyd[i + KEY_DIRCALLFILE_SEL1].ypis + SAFE_DIST2,
                // 			 keyd[i + KEY_DIRCALLFILE_SEL1].xsize - SAFE_DIST2 * 2, keyd[i + KEY_DIRCALLFILE_SEL1].ysize - SAFE_DIST2 * 2,
                // 			 keybmpind[i + KEY_DIRCALLFILE_SEL1].icon[0]);
                DrawFillRect(rect[i + RECT_DIRCALLFILE_IMG1].xpis, rect[i + RECT_DIRCALLFILE_IMG1].ypis,
                             rect[i + RECT_DIRCALLFILE_IMG1].xsize, rect[i + RECT_DIRCALLFILE_IMG1].ysize,
                             rect[i + RECT_DIRCALLFILE_IMG1].colorB[0]);

                BmpFillRect(rect[i + RECT_DIRCALLFILE_SEL1].xpis, rect[i + RECT_DIRCALLFILE_SEL1].ypis,
                            rect[i + RECT_DIRCALLFILE_SEL1].xsize + SAFE_DIST6, rect[i + RECT_DIRCALLFILE_SEL1].ysize);

                patternLen = ((IREG2[(PatternList.dataAdd[i]) + 1] << 16) | IREG2[(PatternList.dataAdd[i])]);
                patternType = ((IREG2[(PatternList.dataAdd[i]) + FileIndexSize - 1] & 0xff00) >> 8) & 0xff;
                disColor = ((PatternList.dataAdd[i] < MAXIREG2) && ((patternLen > 0) && (patternLen < 2 * MAXSREG)))
                               ? ((patternType != 0) ? MitFontColor : BorFontColor)
                               : keybmpind[i + RECT_DIRCALLFILE_SEL1].textColor[0];
                DrawFFileno_16x8(rect[i + RECT_DIRCALLFILE_SEL1].xpis + TYPE_SIZE26 + SAFE_DIST3, rect[i + RECT_DIRCALLFILE_SEL1].ypis + SAFE_DIST1,
                                 (PatternList.dataAdd[i] >= MAXIREG2) ? 0 : PatternList.dataAdd[i] / FileIndexSize + MINFILENO, disColor);

                DrawF16Str(rect[i + RECT_DIRCALLFILE_SEL1].xpis + TYPE_SIZE26 + SAFE_DIST3 + 9 * 3,
                           rect[i + RECT_DIRCALLFILE_SEL1].ypis + SAFE_DIST1,
                           "@", rect[i + RECT_DIRCALLFILE_SEL1].colorT[0]);

                if (PatternList.dataAdd[i] >= MAXIREG2)
                {
                    DrawFFilename(rect[i + RECT_DIRCALLFILE_SEL1].xpis + TYPE_SIZE26 + SAFE_DIST3 + 9 * 4,
                                  rect[i + RECT_DIRCALLFILE_SEL1].ypis + SAFE_DIST4,
                                  "NO__DATA", strlen("NO__DATA"), NO_DATAColor, 6, 0, NULL);
                    PatternList.selectEnable[i] = 0;
                }
                else
                {
                    DrawFFilename(rect[i + RECT_DIRCALLFILE_SEL1].xpis + TYPE_SIZE26 + SAFE_DIST3 + 9 * 4,
                                  rect[i + RECT_DIRCALLFILE_SEL1].ypis + SAFE_DIST4,
                                  (char *)(&IREG2[PatternList.dataAdd[i] + FileIndexNamepox]),
                                  64, disColor, 6, 0, NULL);
                    PatternList.selectEnable[i] = 1;
                }
            }
            wdt();
        }
        // /[更新花样显示列表*end]**********************************************************

        // /[文件选中BMP处理*begin]**********************************************************
        if (refresh2) // 文件编号选中处理
        {
            refresh2 = 0;
            for (i = 0; i < PatternList.disNumDiv; i++)
            {
                BmpFillRect(disBmp[i + 1].xpis, disBmp[i + 1].ypis,
                            disBmp[i + 1].xsize, disBmp[i + 1].ysize);
                DrawFPBMPBTN1(disBmp[i + 1].xpis, disBmp[i + 1].ypis,
                              disBmp[i + 1].xsize, disBmp[i + 1].ysize,
                              PatternList.selectList[i] ? disBmp[i + 1].icon[1] : disBmp[i + 1].icon[0]);
            }
        }
        // /[文件选中BMP处理*end]**********************************************************

        // /[数字更新*begin]**********************************************************
        if (dis_updata1)
        {
            dis_updata1 = 0;
            PatternList.bflashAllFlag = 1;
            DrawFillRect(rect[RECT_DIRCALLFILE_NUM_STR].xpis, rect[RECT_DIRCALLFILE_NUM_STR].ypis,
                         rect[RECT_DIRCALLFILE_NUM_STR].xsize, rect[RECT_DIRCALLFILE_NUM_STR].ysize,
                         rect[RECT_DIRCALLFILE_NUM_STR].colorB[0]);
            DrawDottedRect(rect[RECT_DIRCALLFILE_NUM_STR].xpis, rect[RECT_DIRCALLFILE_NUM_STR].ypis,
                           rect[RECT_DIRCALLFILE_NUM_STR].xsize, rect[RECT_DIRCALLFILE_NUM_STR].ysize,
                           rect[RECT_DIRCALLFILE_NUM_STR].colorT[0]);
            if (disall == 0)
            {
                DrawMFU32Z(rect[RECT_DIRCALLFILE_NUM_STR].xpis + (rect[RECT_DIRCALLFILE_NUM_STR].xsize - 12 * 3) / 2,
                           rect[RECT_DIRCALLFILE_NUM_STR].ypis + SAFE_DIST4, patno, 3, rect[RECT_DIRCALLFILE_NUM_STR].colorT[0]);
            }
        }
        // /[数字更新*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        // if (key_on_flag1)
        // 	ErrorMsg(MENU_READ);
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*begin]**********************************************************
        // if (beeponf == 0)
        // {
        // 	ErrorMsg(MENU_READ);
        // 	if (Timer_ms >= 30000) //30720
        // 	{
        // 		Timer_ms = 0;
        // 	}
        // }
        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*end]**********************************************************

        // /[绘制链接按钮*begin]**********************************************************
        if (dis_updata4)
        { //连接处空送
            dis_updata4 = 0;
            for (i = KEY_DIRCALLFILE_START; i <= KEY_DIRCALLFILE_END; i++)
            {
                if (i == KEY_DIRCALLFILE_START)
                    // DrawButton2(keyd[i], Color_White1, (StPointFlag == 1) ? keybmpind[i] + 1 : keybmpind[i], 1);
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               (StPointFlag == 1) ? keybmpind[i].border[1] : keybmpind[i].border[0],
                               (StPointFlag == 1) ? keybmpind[i].icon[1] : keybmpind[i].icon[0]);
                else
                    // DrawButton2(keyd[i], Color_White1, (EndPointFlag == 1) ? keybmpind[i] + 1 : keybmpind[i], 1);
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               (EndPointFlag == 1) ? keybmpind[i].border[1] : keybmpind[i].border[0],
                               (EndPointFlag == 1) ? keybmpind[i].icon[1] : keybmpind[i].icon[0]);
            }
        }
        // /[绘制链接按钮*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if ((g_backSREG_f == 1) || (g_backHREG_f == 1))
        {
            BackupSHREG((g_backHREG_f << 1) | g_backSREG_f);
        }

        if (pno != MENU_DIRCALLFILE)
        {
            if (g_GreatPatType == 1)
            { //三菱
                g_init_flag = tmpinit_flag;
            }
            plastno = MENU_DIRCALLFILE;
            break;
        }

        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

//******************************************************

#define temp_input_method g_publicbuf[0]
#define temp_para_offset g_publicbuf[1]
#define temp_direction g_publicbuf[2]
#define temp_distance g_publicbuf[3]
#define temp_times g_publicbuf[4]
#define temp_zig_zag g_publicbuf[5]
#define temp_zig_width g_publicbuf[6]
#define temp_zig_pitch g_publicbuf[7]
#define temp_zig_direction g_publicbuf[8]
#define temp_bt_mode g_publicbuf[9]
#define temp_repeat g_publicbuf[10]
#define temp_r_stitch g_publicbuf[11]
#define temp_srt_bt g_publicbuf[12]
#define temp_s_stitch g_publicbuf[13]
#define temp_ent_bt g_publicbuf[14]
#define temp_e_stitch g_publicbuf[15]

#define KEY_METHOD_SCRNSVR 1  //1 屏保
#define KEY_METHOD_BACK 2     //2 返回
#define KEY_METHOD_ENTER 3    //3 确认
#define KEY_METHOD_PITCH 4    //4 针距
#define KEY_METHOD_MULTIPLE 5 //5 多重缝
#define KEY_METHOD_ZIGZAG 6   //6 Z字缝
#define KEY_METHOD_TACKING 7  //7 倒缝

#define KEY_METHOD_POINT 8    //8 两点
#define KEY_METHOD_LINE 9     //9 直线
#define KEY_METHOD_POLYGON 10 //10 折线
#define KEY_METHOD_CIRCLE 11  //11 圆
#define KEY_METHOD_ARC 12     //12 圆弧
#define KEY_METHOD_CURVE 13   //13 曲线

#define KEY_METHOD_NTMULT 14   //14 关闭多重缝
#define KEY_METHOD_FDSYMULT 15 //15 折线相接空松
#define KEY_METHOD_FDREMULT 16 //16 方形相接空松
#define KEY_METHOD_OFFSMULT 17 //17 离边缝
#define KEY_METHOD_SWSYMULT 18 //18 折线相接缝纫
#define KEY_METHOD_SWREMULT 19 //19 方形相接缝纫

#define KEY_METHOD_NOTZIG 20 //20 关闭Z字缝
#define KEY_METHOD_ZIG 21    //21 开启Z字缝

#define KEY_METHOD_NOTTACK 22 //22 关闭倒缝
#define KEY_METHOD_TACK 23    //23 开启倒缝
#define KEY_METHOD_OVERLAP 24 //24 重叠缝

#define KEY_METHOD_MAX 25

#define RECT_METHOD_PITCH 1    //1 针距
#define RECT_METHOD_MULTIPLE 2 //2 多重缝
#define RECT_METHOD_ZIGZAG 3   //3 Z字缝
#define RECT_METHOD_TACKING 4  //4 倒缝

#define RECT_METHOD_MAX 5

void Menu_CtMethod(void)
{

    U32 i;
    U8 f;
    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
    /****按键相关参数end****/

    /****标志位相关参数begin****/
    U8 dis_updata1 = 1;
    U8 dis_updata2 = 1;
    U8 dis_updata3 = 1;
    U8 dis_updata4 = 1;
    /****标志位相关参数end***/

    const U8 keynum = {KEY_METHOD_MAX};

    const KEYPAD keyd[] = {
        {0, 0, 0, 0},

        {0, 0, 128, 32},                     //1 屏保
        {TYPE_X1, TYPE_Y4, KEY_X1, KEY_Y1},  //2 返回
        {TYPE_X11, TYPE_Y4, KEY_X1, KEY_Y1}, //3 确认

        {194, TYPE_Y31, KEY_X6, KEY_Y6}, //4 针距
        {194, 186, KEY_X6, KEY_Y6},      //5 多重缝
        {194, 291, KEY_X6, KEY_Y6},      //6 Z字缝
        {194, 396, KEY_X6, KEY_Y6},      //7 倒缝

        {194 + KEY_X6 + SAFE_DIST8, TYPE_Y31, KEY_X6, KEY_Y6},     //8 两点
        {194 + KEY_X6 * 2 + SAFE_DIST8, TYPE_Y31, KEY_X6, KEY_Y6}, //9 直线
        {194 + KEY_X6 * 3 + SAFE_DIST8, TYPE_Y31, KEY_X6, KEY_Y6}, //10 折线
        {194 + KEY_X6 * 4 + SAFE_DIST8, TYPE_Y31, KEY_X6, KEY_Y6}, //11 圆
        {194 + KEY_X6 * 5 + SAFE_DIST8, TYPE_Y31, KEY_X6, KEY_Y6}, //12 圆弧
        {194 + KEY_X6 * 6 + SAFE_DIST8, TYPE_Y31, KEY_X6, KEY_Y6}, //13 曲线

        {194 + KEY_X6 + SAFE_DIST8, 186, KEY_X6, KEY_Y6},     //14 关闭多重缝
        {194 + KEY_X6 * 2 + SAFE_DIST8, 186, KEY_X6, KEY_Y6}, //15 折线相接空松
        {194 + KEY_X6 * 3 + SAFE_DIST8, 186, KEY_X6, KEY_Y6}, //16 方形相接空松
        {194 + KEY_X6 * 4 + SAFE_DIST8, 186, KEY_X6, KEY_Y6}, //17 离边缝
        {194 + KEY_X6 * 5 + SAFE_DIST8, 186, KEY_X6, KEY_Y6}, //18 折线相接缝纫
        {194 + KEY_X6 * 6 + SAFE_DIST8, 186, KEY_X6, KEY_Y6}, //19 方形相接缝纫

        {194 + KEY_X6 + SAFE_DIST8, 291, KEY_X6, KEY_Y6},     //20 关闭Z字缝
        {194 + KEY_X6 * 2 + SAFE_DIST8, 291, KEY_X6, KEY_Y6}, //21 开启Z字缝

        {194 + KEY_X6 + SAFE_DIST8, 396, KEY_X6, KEY_Y6},     //22 关闭倒缝
        {194 + KEY_X6 * 2 + SAFE_DIST8, 396, KEY_X6, KEY_Y6}, //23 开启倒缝
        {194 + KEY_X6 * 3 + SAFE_DIST8, 396, KEY_X6, KEY_Y6}, //24 重叠缝
    };

    const tydDisSrcIndex keybmpind[] = {
        //title_counter
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},                //1 屏保
        {{KEY_Silver, KEY_Gray}, {0}, {72, 88}, {2, 0, 0, 0}, {0}}, //2 返回
        {{KEY_Silver, KEY_Gray}, {0}, {71, 87}, {3, 0, 0, 0}, {0}}, //3 确认

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {386, 0, 386}, {4, 0, 0, 0}, {0}}, //4 针距
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {418, 0, 0}, {5, 0, 0, 0}, {0}},   //5 多重缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {441, 0, 0}, {6, 0, 0, 0}, {0}},   //6 Z字缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {456, 0, 0}, {7, 0, 0, 0}, {0}},   //7 倒缝

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {388, 390, 389}, {8, 0, 0, 0}, {0}},  //8 两点
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {391, 393, 392}, {9, 0, 0, 0}, {0}},  //9 直线
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {394, 396, 395}, {10, 0, 0, 0}, {0}}, //10 折线
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {403, 405, 404}, {11, 0, 0, 0}, {0}}, //11 圆
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {400, 402, 401}, {12, 0, 0, 0}, {0}}, //12 圆弧
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {397, 399, 398}, {13, 0, 0, 0}, {0}}, //13 曲线

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {419, 421, 420}, {14, 0, 0, 0}, {0}}, //14 关闭多重缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {422, 424, 423}, {15, 0, 0, 0}, {0}}, //15 折线相接空松
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {425, 427, 426}, {16, 0, 0, 0}, {0}}, //16 方形相接空松
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {428, 430, 429}, {17, 0, 0, 0}, {0}}, //17 离边缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {431, 433, 432}, {18, 0, 0, 0}, {0}}, //18 折线相接缝纫
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {434, 436, 435}, {19, 0, 0, 0}, {0}}, //19 方形相接缝纫

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {442, 444, 443}, {20, 0, 0, 0}, {0}}, //20 关闭Z字缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {445, 447, 446}, {21, 0, 0, 0}, {0}}, //21 开启Z字缝

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {457, 459, 458}, {22, 0, 0, 0}, {0}}, //22 关闭倒缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {460, 462, 461}, {23, 0, 0, 0}, {0}}, //23 开启倒缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {463, 465, 464}, {24, 0, 0, 0}, {0}}, //24 重叠缝

    };

    const RECTPAD rect[] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {0}},
        {186, TYPE_Y3, 428, TYPE_SIZE28, {Color_Black}, {Color_Black, Color_White}, {25}},                                  //1 针距
        {186, TYPE_Y3 + SAFE_DIST6 + TYPE_SIZE28, 428, TYPE_SIZE28, {Color_Black}, {Color_Black, Color_White}, {26}},       //2 多重缝
        {186, TYPE_Y3 + (SAFE_DIST6 + TYPE_SIZE28) * 2, 204, TYPE_SIZE28, {Color_Black}, {Color_Black, Color_White}, {27}}, //3 Z字缝
        {186, TYPE_Y3 + (SAFE_DIST6 + TYPE_SIZE28) * 3, 260, TYPE_SIZE28, {Color_Black}, {Color_Black, Color_White}, {28}}, //4 倒缝

    };

    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_METHOD); //设置当前文字显示雷人在P1页面，对应41.bin
    InitScreen();
    initViewStatus();
    updateViewStatus();

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    if (plastno == MENU_CURSOR)
    {
        temp_input_method = g_input_method;
        temp_para_offset = g_para_offset;
        temp_direction = g_direction;
        temp_distance = g_distance;
        temp_times = g_times;
        temp_zig_zag = g_zig_zag;
        temp_zig_width = g_zig_width;
        temp_zig_pitch = g_zig_pitch;
        temp_zig_direction = g_zig_direction;
        temp_bt_mode = g_bt_mode;
        temp_repeat = g_repeat;
        temp_r_stitch = g_r_stitch;
        temp_srt_bt = g_srt_bt;
        temp_s_stitch = g_s_stitch;
        temp_ent_bt = g_ent_bt;
        temp_e_stitch = g_e_stitch;
    }
    if (g_input_method > 6)
        g_input_method = 1;
    if (g_para_offset > 5)
        g_para_offset = 0;
    if (g_zig_zag > 1)
        g_zig_zag = 0;
    if (g_bt_mode > 2)
        g_bt_mode = 0;
    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                 SheetPage, rect[0].index[0], rect[0].colorT[0]); //花样设计

    //画出方框显示
    for (i = 1; i < RECT_METHOD_MAX; i++)
    {
        DrawRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
        Draw24x24Str(rect[i].xpis + SAFE_DIST4, rect[i].ypis + SAFE_DIST3,
                     MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
                     SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
    }
    //画出按键显示
    for (i = 2; i < KEY_METHOD_MAX; i++)
    {
        //无效按键
        //绘制颜色文字按键
        DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
    }
    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************
    ViewPage(usepageno); //设置显示缓存
    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    Timer_ms = 30720; //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        keydata = get_keydata((KEYPAD *)keyd, keynum, 0); //获取键值

        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理
        //无效按键

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {
            if (keydata == KEY_METHOD_OVERLAP && ((g_input_method == 1) || (g_input_method == 2) || (g_input_method == 5))) //特定情况下不生效按键
            {
                keydata = 0;
            }
            else
            {
                if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时
                {
                    keyon = keydata;
                    if (keyon == KEY_METHOD_SCRNSVR) //无按键特效
                    {
                    }
                    //非常规按键-//绘制颜色文字按键
                    else
                    {
                        DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);
                    }
                    Times = 0;
                    delay = KEYDT; //按键防抖次数
                }
                else if (keyon != keydata) //已有按键按下，不处理新按键信息
                {
                    keydata = 0;
                }

                if (Times > delay) //按键防抖
                {
                    if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                    {
                        beeponf = 1;

                        if (g_keyBellT) //按键时蜂鸣器发声时间
                            Beep_On(g_keyBellT);

                        switch (keyon) //按键按下标题提示语显示
                        {
                        default:
                            DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                            break;
                        }
                        delay = KEYFT;
                    }
                    else if (beeponf == 1) //第二次进入
                    {
                        beeponf = 2;
                        //带有长按连续功能按键的功能

                        delay = KEYNT;
                    }
                    else if (beeponf < 20)
                    {
                        beeponf++;
                    }

                    Times = 0; //当前
                }
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            if ((keyoff >= KEY_METHOD_POINT) && (keyoff <= KEY_METHOD_CURVE))
            {
                g_input_method = keyoff - KEY_METHOD_POINT + 1;
                if ((g_input_method == 1) || (g_input_method == 2) || (g_input_method == 5))
                { //直线,点,曲线没有重叠缝
                    if (g_bt_mode > 1)
                        g_bt_mode = 0;
                }
                dis_updata4 = 1;
                dis_updata1 = 1;
            }
            else if ((keyoff >= KEY_METHOD_NTMULT) && (keyoff <= KEY_METHOD_SWREMULT))
            {
                g_para_offset = keyoff - KEY_METHOD_NTMULT;
                dis_updata2 = 1;
            }
            else if ((keyoff >= KEY_METHOD_NOTZIG) && (keyoff <= KEY_METHOD_ZIG))
            {
                g_zig_zag = keyoff - KEY_METHOD_NOTZIG;
                dis_updata3 = 1;
            }
            else if ((keyoff >= KEY_METHOD_NOTTACK) && (keyoff <= KEY_METHOD_OVERLAP))
            {
                if (((keyoff - KEY_METHOD_NOTTACK) < 2) ||
                    ((g_input_method != 1) && (g_input_method != 2) && (g_input_method != 5)))
                    g_bt_mode = keyoff - KEY_METHOD_NOTTACK;
                dis_updata4 = 1;
            }
            else
            {
                switch (keyoff)
                {
                case KEY_METHOD_SCRNSVR:
                    pno = MENU_SCRNSVR;
                    break;
                case KEY_METHOD_BACK:
                    pno = MENU_CURSOR;
                    pnoindex = 2;
                    g_input_method = temp_input_method;
                    g_para_offset = temp_para_offset;
                    g_direction = temp_direction;
                    g_distance = temp_distance;
                    g_times = temp_times;
                    g_zig_zag = temp_zig_zag;
                    g_zig_width = temp_zig_width;
                    g_zig_pitch = temp_zig_pitch;
                    g_zig_direction = temp_zig_direction;
                    g_bt_mode = temp_bt_mode;
                    g_repeat = temp_repeat;
                    g_r_stitch = temp_r_stitch;
                    g_srt_bt = temp_srt_bt;
                    g_s_stitch = temp_s_stitch;
                    g_ent_bt = temp_ent_bt;
                    g_e_stitch = temp_e_stitch;
                    break;

                case KEY_METHOD_ENTER:
                    pno = MENU_CURSOR;
                    pnoindex = 2;
                    break;
                case KEY_METHOD_PITCH:
                    pno = MENU_PITCH;
                    poldno[3] = MENU_METHOD;
                    pnoindex = 4;
                    break;
                case KEY_METHOD_MULTIPLE:
                    pno = MENU_MULTI;
                    poldno[3] = MENU_METHOD;
                    pnoindex = 4;
                    break;
                case KEY_METHOD_ZIGZAG:
                    pno = MENU_ZIGZAG;
                    poldno[3] = MENU_METHOD;
                    pnoindex = 4;
                    break;
                case KEY_METHOD_TACKING:
                    pno = MENU_TACKING;
                    poldno[3] = MENU_METHOD;
                    pnoindex = 4;
                    break;
                }
            }
            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            if (keyon == KEY_METHOD_SCRNSVR) //不需要显示的按键
            {
            }

            //非常规按键-//绘制颜色文字按键
            else //常规按键
            {
                DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);
            }

            keyon = 0;
            beeponf = 0;
            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
            Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                         SheetPage, rect[0].index[0], rect[0].colorT[0]); //显示回花样设计
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if (Timerms > 1000)
        {
            Timerms = 0;
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1)
        {
            ErrorMsg(MENU_METHOD);
        }
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*begin]**********************************************************
        if (beeponf == 0)
        {
            ErrorMsg(MENU_METHOD);
        }
        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*end]**********************************************************

        // /[缝制方法按钮更新*begin]**********************************************************
        if (dis_updata1)
        {
            dis_updata1 = 0;

            f = KEY_METHOD_POINT + g_input_method - 1;
            for (i = KEY_METHOD_POINT; i <= KEY_METHOD_CURVE; i++)
            {
                DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                           (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                           (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
            }
        }
        // /[缝制方法按钮更新*end]**********************************************************

        // /[多重缝设置按钮更新*begin]**********************************************************
        if (dis_updata2)
        {
            dis_updata2 = 0;

            f = KEY_METHOD_NTMULT + g_para_offset;
            for (i = KEY_METHOD_NTMULT; i <= KEY_METHOD_SWREMULT; i++)
            {
                DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                           (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                           (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
            }
        }
        // /[多重缝设置按钮更新*end]**********************************************************

        // /[Z字缝设置按钮更新*begin]**********************************************************
        if (dis_updata3)
        {
            dis_updata3 = 0;

            f = KEY_METHOD_NOTZIG + g_zig_zag;
            for (i = KEY_METHOD_NOTZIG; i <= KEY_METHOD_ZIG; i++)
            {
                DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                           (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                           (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
            }
        }
        // /[Z字缝设置按钮更新*end]**********************************************************

        // /[重叠缝设置按钮更新*begin]**********************************************************
        if (dis_updata4)
        {
            dis_updata4 = 0;

            f = KEY_METHOD_NOTTACK + g_bt_mode;
            for (i = KEY_METHOD_NOTTACK; i <= KEY_METHOD_OVERLAP; i++)
            {

                if (i == KEY_METHOD_OVERLAP && ((g_input_method == 1) || (g_input_method == 2) || (g_input_method == 5)))
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[1], keybmpind[i].icon[1]);
                }
                else
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                               (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                }
            }
        }
        // /[重叠缝设置按钮更新*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if (pno != MENU_METHOD)
        {
            plastno = MENU_METHOD;
            break;
        }
        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

/*******************************************************/
#define KEY_PITCH_SCRNSVR 1 //1 屏保
#define KEY_PITCH_BACK 2    //2 返回
#define KEY_PITCH_ENTER 3   //3 确认
#define KEY_PITCH_CLEAN 4   //4 清除一位
#define KEY_PITCH_UP 5      //5 +1
#define KEY_PITCH_DOWN 6    //6 -1
#define KEY_PITCH_0 7       //7 0
#define KEY_PITCH_1 8       //8 1
#define KEY_PITCH_2 9       //9 2
#define KEY_PITCH_3 10      //10 3
#define KEY_PITCH_4 11      //11 4
#define KEY_PITCH_5 12      //12 5
#define KEY_PITCH_6 13      //13 6
#define KEY_PITCH_7 14      //14 7
#define KEY_PITCH_8 15      //15 8
#define KEY_PITCH_9 16      //16 9

#define KEY_PITCH_MAX 17

#define RECT_PITCH_PIN_TIT 1 //1 针距-标题
#define RECT_PITCH_PIN_STR 2 //2 针距-内容

#define RECT_PITCH_MAX 3

void Menu_Ctpitch(void)
{

    U32 i;

    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
    /****按键相关参数end****/

    /****标志位相关参数begin****/
    U8 dis_updata = 1;
    static U16 temp_pitch;
    /****标志位相关参数end***/

    const U8 keynum = {KEY_PITCH_MAX};

    const KEYPAD keyd[] = {
        {0, 0, 0, 0},

        {0, 0, 128, 32},                     //1 屏保
        {TYPE_X1, TYPE_Y4, KEY_X1, KEY_Y1},  //2 返回
        {TYPE_X11, TYPE_Y4, KEY_X1, KEY_Y1}, //3 确认

        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 4, KEY_X2, KEY_Y2},                             //4 清除1位
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},       //5 +1
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2}, //6 -1
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},                             //7 0
        {TYPE_X15, TYPE_Y13, KEY_X2, KEY_Y2},                                                         //8 1
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13, KEY_X2, KEY_Y2},                                   //9 2
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13, KEY_X2, KEY_Y2},                             //10 3
        {TYPE_X15, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},                                   //11 4
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},             //12 5
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},       //13 6
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},                             //14 7
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},       //15 8
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2}, //16 9

    };

    const tydDisSrcIndex keybmpind[] = {
        //title_counter
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},                //1 屏保
        {{KEY_Silver, KEY_Gray}, {0}, {72, 88}, {2, 0, 0, 0}, {0}}, //2 返回
        {{KEY_Silver, KEY_Gray}, {0}, {71, 87}, {3, 0, 0, 0}, {0}}, //3 确认

        {{KEY_Silver}, {0}, {113}, {4, 0, 0, 0}, {0}}, //4 清除1位
        {{KEY_Silver}, {0}, {199}, {5, 0, 0, 0}, {0}}, //5 +1
        {{KEY_Silver}, {0}, {201}, {6, 0, 0, 0}, {0}}, //6 -1
        {{KEY_Silver}, {0}, {91}, {0, 0, 0, 0}, {0}},  //7 0
        {{KEY_Silver}, {0}, {92}, {0, 0, 0, 0}, {0}},  //8 1
        {{KEY_Silver}, {0}, {93}, {0, 0, 0, 0}, {0}},  //9 2
        {{KEY_Silver}, {0}, {94}, {0, 0, 0, 0}, {0}},  //10 3
        {{KEY_Silver}, {0}, {95}, {0, 0, 0, 0}, {0}},  //11 4
        {{KEY_Silver}, {0}, {96}, {0, 0, 0, 0}, {0}},  //12 5
        {{KEY_Silver}, {0}, {97}, {0, 0, 0, 0}, {0}},  //13 6
        {{KEY_Silver}, {0}, {98}, {0, 0, 0, 0}, {0}},  //14 7
        {{KEY_Silver}, {0}, {99}, {0, 0, 0, 0}, {0}},  //15 8
        {{KEY_Silver}, {0}, {100}, {0, 0, 0, 0}, {0}}, //16 9

    };

    const RECTPAD rect[] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {0}},

        {TYPE_X15, TYPE_Y3, TYPE_SIZE9, TYPE_SIZE5, {Color_KeyBlue}, {Color_White}, {7}},                                //1 针距-标题
        {TYPE_X15 + TYPE_SIZE9 + SAFE_DIST5, TYPE_Y3, TYPE_SIZE14, TYPE_SIZE5, {Color_DeepSkyBlue}, {Color_Black}, {0}}, //2 针距-内容
    };

    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage((MENU_PITCH)); //设置当前文字显示雷人在P1页面，对应41.bin
    InitScreen();
    initViewStatus();
    updateViewStatus();

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    if (plastno != MENU_SCRNSVR)
        temp_pitch = g_pitch;
    if (temp_pitch > 127 || temp_pitch == 0)
        temp_pitch = 30;
    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                 SheetPage, rect[0].index[0], rect[0].colorT[0]); //花样设计

    //画出方框显示
    for (i = 1; i < RECT_PITCH_MAX; i++)
    {

        if (i == RECT_PITCH_PIN_TIT)
        {
            DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
            Draw24x24Str(rect[i].xpis + (rect[i].xsize - 24 * 2) / 2, rect[i].ypis + (rect[i].ysize - 24) / 2,
                         MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
                         SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
        }
        else
        {
            DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
            DrawDottedRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorT[0]);
        }
    }
    //画出按键显示
    for (i = 2; i < KEY_PITCH_MAX; i++)
    {
        //无效按键
        //绘制颜色文字按键
        DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
    }
    DrawF16Str(rect[RECT_PITCH_PIN_STR].xpis,
               rect[RECT_PITCH_PIN_STR].ypis + rect[RECT_PITCH_PIN_STR].ysize + SAFE_DIST4,
               "(0.1-12.7)mm", rect[RECT_PITCH_PIN_STR].colorT[0]);
    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************
    ViewPage(usepageno); //设置显示缓存

    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    Timer_ms = 30720; //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        keydata = get_keydata((KEYPAD *)keyd, keynum, 0); //获取键值

        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理
        //无效按键

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            if ((keyon == KEY_PITCH_UP) || (keyon == KEY_PITCH_DOWN))
            {
            }
            else if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {
            //特定情况下不生效按键

            if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时
            {
                keyon = keydata;
                if (keyon == KEY_PITCH_SCRNSVR) //无按键特效
                {
                }
                //非常规按键-//绘制颜色文字按键
                else
                {
                    DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);
                }
                Times = 0;
                delay = KEYDT; //按键防抖次数
            }
            else if (keyon != keydata) //已有按键按下，不处理新按键信息
            {
                keydata = 0;
            }

            if (Times > delay) //按键防抖
            {
                if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                {
                    beeponf = 1;

                    if (g_keyBellT) //按键时蜂鸣器发声时间
                        Beep_On(g_keyBellT);

                    switch (keyon) //按键按下标题提示语显示
                    {

                    case KEY_PITCH_0:
                    case KEY_PITCH_1:
                    case KEY_PITCH_2:
                    case KEY_PITCH_3:
                    case KEY_PITCH_4:
                    case KEY_PITCH_5:
                    case KEY_PITCH_6:
                    case KEY_PITCH_7:
                    case KEY_PITCH_8:
                    case KEY_PITCH_9:
                        BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
                        DrawMFU32(TITLE_XPOS_C2, SAFE_DIST4, keyon - KEY_PITCH_0, 1, rect[0].colorT[0]);
                        break;
                    default:
                        DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                        break;
                    }
                    delay = KEYFT;
                }
                else if (beeponf == 1) //第二次进入
                {
                    beeponf = 2;
                    //带有长按连续功能按键的功能

                    delay = KEYNT;
                }
                else if (beeponf < 20)
                {
                    beeponf++;
                }

                if ((keyon == KEY_PITCH_UP) || (keyon == KEY_PITCH_DOWN)) //带有长按连续功能按键的功能
                {
                    keyoff = keyon;
                    key_on_flag1 = 1;
                }
                Times = 0; //当前
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            if ((keyoff >= KEY_PITCH_0) && (keyoff <= KEY_PITCH_9))
            {
                temp_pitch = (temp_pitch % 100) * 10 + keyoff - KEY_PITCH_0;
                if (temp_pitch > LOOSEN_MAX)
                    temp_pitch = temp_pitch % 100;
                if (temp_pitch > LOOSEN_MAX)
                    temp_pitch = LOOSEN_MAX;
                dis_updata = 1;
            }
            else
            {
                switch (keyoff)
                {
                case KEY_PITCH_SCRNSVR:
                    pno = MENU_SCRNSVR;
                    break;
                case KEY_PITCH_BACK:
                    pnoindex--;
                    pno = poldno[pnoindex];
                    break;
                case KEY_PITCH_ENTER:
                    g_pitch = temp_pitch;
                    pnoindex--;
                    pno = poldno[pnoindex];
                    break;
                case KEY_PITCH_CLEAN:
                    temp_pitch = 0;
                    dis_updata = 1;
                    break;
                case KEY_PITCH_UP:
                    if (temp_pitch < 127)
                        temp_pitch++;
                    dis_updata = 1;
                    break;
                case KEY_PITCH_DOWN:
                    if (temp_pitch > 1)
                        temp_pitch--;
                    dis_updata = 1;
                    break;
                }
            }
            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            if (keyon == KEY_PITCH_SCRNSVR) //不需要显示的按键
            {
            }
            //非常规按键-//绘制颜色文字按键
            else //常规按键
            {
                DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);
            }

            keyon = 0;
            beeponf = 0;
            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
            Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                         SheetPage, rect[0].index[0], rect[0].colorT[0]); //显示回花样设计
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if (Timerms > 1000)
        {
            Timerms = 0;
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1)
        {
            ErrorMsg(MENU_PITCH);
        }
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*begin]**********************************************************
        if (beeponf == 0)
        {
            ErrorMsg(MENU_PITCH);
        }
        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*end]**********************************************************

        // /[针距数据刷新*begin]**********************************************************
        if (dis_updata)
        {
            dis_updata = 0;
            DrawFillRect(rect[RECT_PITCH_PIN_STR].xpis + SAFE_DIST2, rect[RECT_PITCH_PIN_STR].ypis + SAFE_DIST2,
                         rect[RECT_PITCH_PIN_STR].xsize - 2 * SAFE_DIST2, rect[RECT_PITCH_PIN_STR].ysize - 2 * SAFE_DIST2,
                         rect[RECT_PITCH_PIN_STR].colorB[0]);
            DrawMFS32P(rect[RECT_PITCH_PIN_STR].xpis + (rect[RECT_PITCH_PIN_STR].xsize - 4 * 12) / 2,
                       rect[RECT_PITCH_PIN_STR].ypis + (rect[RECT_PITCH_PIN_STR].ysize - 24) / 2,
                       temp_pitch, 4, 1, rect[RECT_PITCH_PIN_STR].colorT[0]);
        }
        // /[针距数据刷新*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if (pno != MENU_PITCH)
        {
            plastno = MENU_PITCH;
            break;
        }
        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

/*****************************************************/
#define tmp_para_offset g_publicbuf[16]
#define tmp_direction g_publicbuf[17]
#define tmp_distance g_publicbuf[18]
#define tmp_times g_publicbuf[19]

#define KEY_MULTI_SCRNSVR 1 //1 屏保
#define KEY_MULTI_BACK 2    //2 返回
#define KEY_MULTI_ENTER 3   //3 确认

#define KEY_MULTI_NTMULT 4   //4 无多重缝
#define KEY_MULTI_FDSYMULT 5 //5 折线相接空松
#define KEY_MULTI_FDREMULT 6 //6 方形相接空松
#define KEY_MULTI_OFFSMULT 7 //7 离边缝
#define KEY_MULTI_SWSYMULT 8 //8 折线相接缝纫
#define KEY_MULTI_SWREMULT 9 //9 方形相接缝纫

#define KEY_MULTI_DIRL 10    //10 左边生成
#define KEY_MULTI_DIRR 11    //11 右边生成
#define KEY_MULTI_SELDIST 12 //12 生成间距
#define KEY_MULTI_SELTIME 13 //13 生成次数

#define KEY_MULTI_CLEAN 14 //14 清除1位
#define KEY_MULTI_UP 15    //15 +1
#define KEY_MULTI_DOWN 16  //16 -1
#define KEY_MULTI_0 17     //17 0
#define KEY_MULTI_1 18     //18 1
#define KEY_MULTI_2 19     //19 2
#define KEY_MULTI_3 20     //20 3
#define KEY_MULTI_4 21     //21 4
#define KEY_MULTI_5 22     //22 5
#define KEY_MULTI_6 23     //23 6
#define KEY_MULTI_7 24     //24 7
#define KEY_MULTI_8 25     //25 8
#define KEY_MULTI_9 26     //26 9

#define KEY_MULTI_MAX 27

#define RECT_MULTI_TYPE 1     //1 离边类型
#define RECT_MULTI_DIR 2      //2 离边方向
#define RECT_MULTI_DIST_TIT 3 //3 离边距离-标题
#define RECT_MULTI_NUM_TIT 4  //4 离边方向-标题
#define RECT_MULTI_DIST_STR 5 //5 离边距离-内容
#define RECT_MULTI_NUM_STR 6  //6 离边方向-内容

#define RECT_MULTI_MAX 5

void Menu_Ctmultiple(void)
{
    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
                                            /****按键相关参数end****/

    /****标志位相关参数begin****/
    U8 dis_updata1 = 1; //更新离边方法按键
    U8 dis_updata2 = 1; //更新方向按钮
    U8 dis_updata3 = 1; //更新距离与次数按键
    U8 dis_updata4 = 0; //更新距离数据
    U8 dis_updata5 = 0; //更新次数数据
    U8 dis_updata6 = 1; //更新数字输入按键
    U32 i;
    U8 f;
    U8 editflag = 0;
    U16 tpara_offset = 0;
    /****标志位相关参数end***/

    const U8 keynum = {KEY_MULTI_MAX};

    const KEYPAD keyd[] = {
        {0, 0, 0, 0},

        {0, 0, 128, 32},                     //1 屏保
        {TYPE_X1, TYPE_Y4, KEY_X1, KEY_Y1},  //2 返回
        {TYPE_X11, TYPE_Y4, KEY_X1, KEY_Y1}, //3 确认

        {TYPE_X14 + SAFE_DIST1, TYPE_Y31, KEY_X6, KEY_Y6},              //4 无多重缝
        {TYPE_X14 + SAFE_DIST1 + KEY_X6, TYPE_Y31, KEY_X6, KEY_Y6},     //5 折线相接空松
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 2, TYPE_Y31, KEY_X6, KEY_Y6}, //6 方形相接空松
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 3, TYPE_Y31, KEY_X6, KEY_Y6}, //7 离边缝
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 4, TYPE_Y31, KEY_X6, KEY_Y6}, //8 折线相接缝纫
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 5, TYPE_Y31, KEY_X6, KEY_Y6}, //9 方形相接缝纫

        {TYPE_X14 + SAFE_DIST1 + KEY_X6, TYPE_Y32, KEY_X6, KEY_Y6},     //10 左边生成
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 4, TYPE_Y32, KEY_X6, KEY_Y6}, //11 右边生成

        {TYPE_X14 + TYPE_SIZE10 + SAFE_DIST5, 260, TYPE_SIZE14, TYPE_SIZE5},                           //12 生成间距
        {TYPE_X14 + TYPE_SIZE10 + SAFE_DIST5, 260 + TYPE_SIZE5 + SAFE_DIST6, TYPE_SIZE14, TYPE_SIZE5}, //13 生成次数

        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 4, KEY_X2, KEY_Y2},                             //14 清除1位
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},       //15 +1
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2}, //16 -1
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},                             //17 0
        {TYPE_X15, TYPE_Y13, KEY_X2, KEY_Y2},                                                         //18 1
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13, KEY_X2, KEY_Y2},                                   //19 2
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13, KEY_X2, KEY_Y2},                             //20 3
        {TYPE_X15, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},                                   //21 4
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},             //22 5
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},       //23 6
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},                             //24 7
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},       //25 8
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2}, //26 9

    };

    const tydDisSrcIndex keybmpind[] = {
        //title_counter
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},      //1 屏保
        {{KEY_Silver}, {0}, {72, 88}, {2, 0, 0, 0}, {0}}, //2 返回
        {{KEY_Silver}, {0}, {71, 87}, {3, 0, 0, 0}, {0}}, //3 确认

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {419, 421, 420}, {4, 0, 0, 0}, {0}}, //4 关闭多重缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {422, 424, 423}, {5, 0, 0, 0}, {0}}, //5 折线相接空松
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {425, 427, 426}, {6, 0, 0, 0}, {0}}, //6 方形相接空松
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {428, 430, 429}, {7, 0, 0, 0}, {0}}, //7 离边缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {431, 433, 432}, {8, 0, 0, 0}, {0}}, //8 折线相接缝纫
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {434, 436, 435}, {9, 0, 0, 0}, {0}}, //9 方形相接缝纫

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {437, 0, 438}, {10, 0, 0, 0}, {0}}, //10 左边生成
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {439, 0, 440}, {11, 0, 0, 0}, {0}}, //11 右边生成

        {{KEY_Silver}, {Color_Black, Color_Black}, {Color_White, Color_DeepSkyBlue, Color_Black, 0}, {12, 0, 0, 0}, {0}}, //12 生成间距
        {{KEY_Silver}, {Color_Black, Color_Black}, {Color_White, Color_DeepSkyBlue, Color_Black, 0}, {13, 0, 0, 0}, {0}}, //13 生成次数

        {{KEY_Silver}, {0}, {113}, {14, 0, 0, 0}, {0}}, //14 清除1位
        {{KEY_Silver}, {0}, {199}, {15, 0, 0, 0}, {0}}, //15 +1
        {{KEY_Silver}, {0}, {201}, {16, 0, 0, 0}, {0}}, //16 -1
        {{KEY_Silver}, {0}, {91}, {0, 0, 0, 0}, {0}},   //17 0
        {{KEY_Silver}, {0}, {92}, {0, 0, 0, 0}, {0}},   //18 1
        {{KEY_Silver}, {0}, {93}, {0, 0, 0, 0}, {0}},   //19 2
        {{KEY_Silver}, {0}, {94}, {0, 0, 0, 0}, {0}},   //20 3
        {{KEY_Silver}, {0}, {95}, {0, 0, 0, 0}, {0}},   //21 4
        {{KEY_Silver}, {0}, {96}, {0, 0, 0, 0}, {0}},   //22 5
        {{KEY_Silver}, {0}, {97}, {0, 0, 0, 0}, {0}},   //23 6
        {{KEY_Silver}, {0}, {98}, {0, 0, 0, 0}, {0}},   //24 7
        {{KEY_Silver}, {0}, {99}, {0, 0, 0, 0}, {0}},   //25 8
        {{KEY_Silver}, {0}, {100}, {0, 0, 0, 0}, {0}},  //26 9

    };

    const RECTPAD rect[] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {0}},
        {TYPE_X14, TYPE_Y3, TYPE_SIZE29, TYPE_SIZE28, {Color_Black}, {Color_Black, Color_White}, {17}},                            //1 离边类型
        {TYPE_X14, TYPE_Y3 + TYPE_SIZE28 + SAFE_DIST6, TYPE_SIZE29, TYPE_SIZE28, {Color_Black}, {Color_Black, Color_White}, {18}}, //2 离边方向

        {TYPE_X14, TYPE_Y3 + (TYPE_SIZE28 + SAFE_DIST6) * 2, TYPE_SIZE10, TYPE_SIZE5, {Color_KeyBlue}, {Color_White}, {19}},                           //3 离边距离-标题
        {TYPE_X14, TYPE_Y3 + (TYPE_SIZE28 + SAFE_DIST6) * 2 + TYPE_SIZE5 + SAFE_DIST6, TYPE_SIZE10, TYPE_SIZE5, {Color_KeyBlue}, {Color_White}, {20}}, //4 离边方向-标题

        // {TYPE_X15 + TYPE_SIZE10 + SAFE_DIST5, TYPE_Y3 + (TYPE_SIZE28 + SAFE_DIST6) * 2, TYPE_SIZE14, TYPE_SIZE5, {Color_White, Color_DeepSkyBlue}, {Color_Black, Color_Black}, {0}},                           //5 离边距离-内容
        // {TYPE_X15 + TYPE_SIZE10 + SAFE_DIST5, TYPE_Y3 + (TYPE_SIZE28 + SAFE_DIST6) * 2 + TYPE_SIZE5 + SAFE_DIST6, TYPE_SIZE14, TYPE_SIZE5, {Color_White, Color_DeepSkyBlue}, {Color_Black, Color_Black}, {0}}, //6 离边方向-内容
    };

    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_MULTI); //设置当前文字显示雷人在P1页面，对应41.bin
    InitScreen();
    initViewStatus();
    updateViewStatus();

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    if (pno != MENU_SCRNSVR)
    {
        tmp_para_offset = g_para_offset;
        tmp_direction = g_direction;
        tmp_distance = g_distance;
        tmp_times = g_times;
    }
    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                 SheetPage, rect[0].index[0], rect[0].colorT[0]); //花样设计

    //画出方框显示
    for (i = 1; i < RECT_MULTI_MAX; i++)
    {

        if (i == RECT_MULTI_TYPE)
        {
            DrawRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);

            Draw24x24Str(rect[i].xpis + SAFE_DIST4, rect[i].ypis + SAFE_DIST3,
                         MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
                         SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
        }
        // else if (i == RECT_MULTI_NUM_TIT || i == RECT_MULTI_DIST_TIT)
        // {
        //     DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
        //     Draw24x24Str(rect[i].xpis + (rect[i].xsize - 24 * 2) / 2, rect[i].ypis + (rect[i].ysize - 24) / 2,
        //                  MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
        //                  SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
        // }
    }
    //画出按键显示
    for (i = 2; i < KEY_MULTI_MAX; i++)
    {
        if (i >= KEY_MULTI_BACK && i <= KEY_MULTI_SWREMULT)
        {
            DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
        }
    }

    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************
    ViewPage(usepageno); //设置显示缓存

    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    Timer_ms = 30720; //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        keydata = get_keydata((KEYPAD *)keyd, keynum, 0); //获取键值

        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理
        //无效按键

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            if ((keyon == KEY_MULTI_UP) || (keyon == KEY_MULTI_DOWN))
            {
            }
            else if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {
            //特定情况下不生效按键
            if (((tmp_para_offset == 0) && (keydata >= KEY_MULTI_DIRL) && (keydata <= KEY_MULTI_SELTIME)) ||
                ((tmp_para_offset == 3) && (keydata == KEY_MULTI_SELTIME)))
            {
                keydata = 0;
            }
            else if (tmp_para_offset == 0 && keydata >= KEY_MULTI_CLEAN)
            {
                keydata = 0;
            }
            else
            {
                if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时
                {
                    keyon = keydata;
                    if (keyon == KEY_MULTI_SCRNSVR) //无按键特效
                    {
                    }
                    else if (keyon == KEY_MULTI_SELTIME || keyon == KEY_MULTI_SELDIST) //非常规按键
                    {
                        DrawButtonOnZoomIn(keyd[keyon], 2);
                    }
                    else
                    {
                        DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);
                    }
                    Times = 0;
                    delay = KEYDT; //按键防抖次数
                }
                else if (keyon != keydata) //已有按键按下，不处理新按键信息
                {
                    keydata = 0;
                }

                if (Times > delay) //按键防抖
                {
                    if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                    {
                        beeponf = 1;

                        if (g_keyBellT) //按键时蜂鸣器发声时间
                            Beep_On(g_keyBellT);

                        switch (keyon) //按键按下标题提示语显示
                        {
                        case KEY_MULTI_0:
                        case KEY_MULTI_1:
                        case KEY_MULTI_2:
                        case KEY_MULTI_3:
                        case KEY_MULTI_4:
                        case KEY_MULTI_5:
                        case KEY_MULTI_6:
                        case KEY_MULTI_7:
                        case KEY_MULTI_8:
                        case KEY_MULTI_9:
                            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
                            DrawMFU32(TITLE_XPOS_C2, SAFE_DIST4, keyon - KEY_MULTI_0, 1, rect[0].colorT[0]);
                            break;
                        default:
                            DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                            break;
                        }
                        delay = KEYFT;
                    }
                    else if (beeponf == 1) //第二次进入
                    {
                        beeponf = 2;
                        //带有长按连续功能按键的功能

                        delay = KEYNT;
                    }
                    else if (beeponf < 20)
                    {
                        beeponf++;
                    }

                    if ((keyon == KEY_MULTI_UP) || (keyon == KEY_MULTI_DOWN)) //带有长按连续功能按键的功能
                    {
                        keyoff = keyon;
                        key_on_flag1 = 1;
                    }
                    Times = 0; //当前
                }
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            if ((keyoff >= KEY_MULTI_NTMULT) && (keyoff <= KEY_MULTI_SWREMULT))
            {
                tmp_para_offset = keyoff - KEY_MULTI_NTMULT;
                dis_updata1 = 1;
                dis_updata2 = 1;
                dis_updata3 = 1;
            }
            else if ((keyoff >= KEY_MULTI_DIRL) && (keyoff <= KEY_MULTI_DIRR))
            {
                tmp_direction = keyoff - KEY_MULTI_DIRL;
                dis_updata2 = 1;
            }
            else if ((keyoff >= KEY_MULTI_0) && (keyoff <= KEY_MULTI_9))
            {
                if (tmp_para_offset > 0)
                {
                    if (editflag)
                    {
                        tmp_times = keyoff - KEY_MULTI_0;
                        dis_updata5 = 1;
                        if ((g_times < 2) && (g_times > 9))
                            g_times = 2;
                    }
                    else
                    {
                        tmp_distance = (tmp_distance % 100) * 10 + keyoff - KEY_MULTI_0;
                        if (tmp_distance > 250)
                            tmp_distance = tmp_distance % 100;
                        dis_updata4 = 1;
                    }
                }
            }
            else
            {
                switch (keyoff)
                {
                case KEY_MULTI_SCRNSVR:
                    pno = MENU_SCRNSVR;
                    break;
                case KEY_MULTI_BACK:
                    pnoindex--;
                    pno = poldno[pnoindex];
                    break;
                case KEY_MULTI_ENTER:
                    pnoindex--;
                    pno = poldno[pnoindex];
                    g_para_offset = tmp_para_offset;
                    g_direction = tmp_direction;
                    g_distance = (U8)(tmp_distance);
                    g_times = tmp_times;
                    if ((g_times < 2) && (g_times > 9))
                        g_times = 2;
                    break;

                case KEY_MULTI_SELDIST:
                    editflag = 0;
                    dis_updata3 = 1;
                    break;

                case KEY_MULTI_SELTIME:
                    editflag = 1;
                    dis_updata3 = 1;
                    break;

                case KEY_MULTI_CLEAN:
                    if (tmp_para_offset > 0)
                    {
                        if (editflag == 0)
                        {
                            tmp_distance = 0;
                            dis_updata4 = 1;
                        }
                        else
                        {
                            tmp_times = 2;
                            dis_updata5 = 1;
                        }
                    }
                    break;

                case KEY_MULTI_UP:
                    if (tmp_para_offset > 0)
                    {
                        if (editflag == 0)
                        {
                            if (tmp_distance < 250)
                                tmp_distance++;
                            dis_updata4 = 1;
                        }
                        else
                        {
                            if (tmp_times < 9)
                                tmp_times++;
                            dis_updata5 = 1;
                        }
                    }
                    break;

                case KEY_MULTI_DOWN:
                    if (tmp_para_offset > 0)
                    {
                        if (editflag == 0)
                        {
                            if (tmp_distance > 0)
                                tmp_distance--;
                            dis_updata4 = 1;
                        }
                        else
                        {
                            if (tmp_times > 2)
                                tmp_times--;
                            dis_updata5 = 1;
                        }
                    }

                    break;
                }
            }
            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            if (keyon == KEY_MULTI_SCRNSVR) //不需要显示的按键
            {
            }
            else if (keyon == KEY_MULTI_SELTIME || keyon == KEY_MULTI_SELDIST) //非常规按键
            {
                DrawButtonOnZoomInRes(keyd[keyon]);
            }
            else //常规按键
            {
                DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);
            }

            keyon = 0;
            beeponf = 0;
            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
            Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                         SheetPage, rect[0].index[0], rect[0].colorT[0]); //显示回花样设计
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if (Timerms > 1000)
        {
            Timerms = 0;
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1)
        {
            ErrorMsg(MENU_MULTI);
        }
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*begin]**********************************************************
        if (beeponf == 0)
        {
            ErrorMsg(MENU_MULTI);
        }
        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*end]**********************************************************

        // /[更新离边方法按键*begin]**********************************************************
        if (dis_updata1)
        {
            dis_updata1 = 0;

            f = KEY_MULTI_NTMULT + tmp_para_offset;
            for (i = KEY_MULTI_NTMULT; i <= KEY_MULTI_SWREMULT; i++)
            {
                DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                           (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                           (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
            }
            if (tmp_para_offset == 3 || tmp_para_offset == 0)
                editflag = 0;
        }
        // /[更新离边方法按键*end]**********************************************************

        // /[更新方向按键*begin]**********************************************************
        if (dis_updata2)
        {
            dis_updata2 = 0;

            if (tmp_para_offset)
            {
                f = KEY_MULTI_DIRL + tmp_direction;
                for (i = KEY_MULTI_DIRL; i <= KEY_MULTI_DIRR; i++)
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                               (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                }

                DrawRect(rect[RECT_MULTI_DIR].xpis, rect[RECT_MULTI_DIR].ypis, rect[RECT_MULTI_DIR].xsize, rect[RECT_MULTI_DIR].ysize, rect[RECT_MULTI_DIR].colorB[0]);
                Draw24x24Str(rect[RECT_MULTI_DIR].xpis + SAFE_DIST4, rect[RECT_MULTI_DIR].ypis + SAFE_DIST3,
                             MEM_TITLE_ADD + rect[RECT_MULTI_DIR].index[0] * TitleLengthMax,
                             SheetPage, rect[RECT_MULTI_DIR].index[0], rect[RECT_MULTI_DIR].colorT[0]); //画出方框的文字
            }
            else
            {
                BmpFillRect(rect[RECT_MULTI_DIR].xpis, rect[RECT_MULTI_DIR].ypis, rect[RECT_MULTI_DIR].xsize, rect[RECT_MULTI_DIR].ysize);
            }
        }
        // /[更新方向按键*end]**********************************************************

        // /[更新距离与次数按键*begin]**********************************************************
        if (dis_updata3)
        {
            dis_updata3 = 0;

            if (tmp_para_offset)
            {
                DrawFillRect(rect[RECT_MULTI_DIST_TIT].xpis, rect[RECT_MULTI_DIST_TIT].ypis, rect[RECT_MULTI_DIST_TIT].xsize, rect[RECT_MULTI_DIST_TIT].ysize, rect[RECT_MULTI_DIST_TIT].colorB[0]);
                Draw24x24Str(rect[RECT_MULTI_DIST_TIT].xpis + (rect[RECT_MULTI_DIST_TIT].xsize - strlen((char *)(MEM_TITLE_ADD + rect[RECT_MULTI_DIST_TIT].index[0] * TitleLengthMax)) * 13) / 2,
                             rect[RECT_MULTI_DIST_TIT].ypis + (rect[RECT_MULTI_DIST_TIT].ysize - 24) / 2,
                             MEM_TITLE_ADD + rect[RECT_MULTI_DIST_TIT].index[0] * TitleLengthMax,
                             SheetPage, rect[RECT_MULTI_DIST_TIT].index[0], rect[RECT_MULTI_DIST_TIT].colorT[0]); //画出方框的文字

                DrawButtonEdit(keyd[KEY_MULTI_SELDIST],
                               (editflag == 0) ? keybmpind[KEY_MULTI_SELDIST].icon[1] : keybmpind[KEY_MULTI_SELDIST].icon[0],
                               (editflag == 0) ? keybmpind[KEY_MULTI_SELDIST].textColor[0] : keybmpind[KEY_MULTI_SELDIST].icon[0]);

                DrawF16Str(keyd[KEY_MULTI_SELDIST].xpis + keyd[KEY_MULTI_SELDIST].xsize + SAFE_DIST4,
                           keyd[KEY_MULTI_SELDIST].ypis + (keyd[KEY_MULTI_SELDIST].ysize - 16) / 2,
                           "(0.1-12.7)mm", keybmpind[KEY_MULTI_SELDIST].textColor[1]);

                dis_updata4 = 1;
            }
            else
            {
                BmpFillRect(rect[RECT_MULTI_DIST_TIT].xpis, rect[RECT_MULTI_DIST_TIT].ypis, TYPE_SIZE29, rect[RECT_MULTI_DIST_TIT].ysize);
            }
            if ((tmp_para_offset) && (tmp_para_offset != 3))
            {
                DrawFillRect(rect[RECT_MULTI_NUM_TIT].xpis, rect[RECT_MULTI_NUM_TIT].ypis, rect[RECT_MULTI_NUM_TIT].xsize, rect[RECT_MULTI_NUM_TIT].ysize, rect[RECT_MULTI_NUM_TIT].colorB[0]);
                Draw24x24Str(rect[RECT_MULTI_NUM_TIT].xpis + (rect[RECT_MULTI_NUM_TIT].xsize - strlen((char *)(MEM_TITLE_ADD + rect[RECT_MULTI_NUM_TIT].index[0] * TitleLengthMax)) * 13) / 2,
                             rect[RECT_MULTI_NUM_TIT].ypis + (rect[RECT_MULTI_NUM_TIT].ysize - 24) / 2,
                             MEM_TITLE_ADD + rect[RECT_MULTI_NUM_TIT].index[0] * TitleLengthMax,
                             SheetPage, rect[RECT_MULTI_NUM_TIT].index[0], rect[RECT_MULTI_NUM_TIT].colorT[0]); //画出方框的文字

                DrawButtonEdit(keyd[KEY_MULTI_SELTIME],
                               (editflag == 1) ? keybmpind[KEY_MULTI_SELTIME].icon[1] : keybmpind[KEY_MULTI_SELTIME].icon[0],
                               (editflag == 1) ? keybmpind[KEY_MULTI_SELTIME].textColor[0] : keybmpind[KEY_MULTI_SELTIME].icon[0]);

                DrawF16Str(keyd[KEY_MULTI_SELTIME].xpis + keyd[KEY_MULTI_SELTIME].xsize + SAFE_DIST4,
                           keyd[KEY_MULTI_SELTIME].ypis + (keyd[KEY_MULTI_SELTIME].ysize - 16) / 2,
                           "(2-9)", keybmpind[KEY_MULTI_SELTIME].textColor[1]);

                dis_updata5 = 1;
            }
            else
            {
                BmpFillRect(rect[RECT_MULTI_NUM_TIT].xpis, rect[RECT_MULTI_NUM_TIT].ypis, TYPE_SIZE29, rect[RECT_MULTI_NUM_TIT].ysize);
            }
        }
        // /[更新距离与次数按键*end]**********************************************************

        // /[更新距离数据*begin]**********************************************************
        if (dis_updata4)
        {
            dis_updata4 = 0;
            DrawFillRect(keyd[KEY_MULTI_SELDIST].xpis + 1, keyd[KEY_MULTI_SELDIST].ypis + 1,
                         keyd[KEY_MULTI_SELDIST].xsize - 2, keyd[KEY_MULTI_SELDIST].ysize - 2,
                         (editflag == 0) ? keybmpind[KEY_MULTI_SELDIST].icon[1] : keybmpind[KEY_MULTI_SELDIST].icon[0]);
            DrawMFS32P(keyd[KEY_MULTI_SELDIST].xpis + (keyd[KEY_MULTI_SELDIST].xsize - 13 * 4) / 2,
                       keyd[KEY_MULTI_SELDIST].ypis + (keyd[KEY_MULTI_SELDIST].ysize - 24) / 2,
                       tmp_distance, 4, 1, keybmpind[KEY_MULTI_SELDIST].textColor[0]);
        }
        // /[更新距离数据*end]**********************************************************

        // /[更新次数数据*begin]**********************************************************
        if (dis_updata5)
        {
            dis_updata5 = 0;
            DrawFillRect(keyd[KEY_MULTI_SELTIME].xpis + 1, keyd[KEY_MULTI_SELTIME].ypis + 1,
                         keyd[KEY_MULTI_SELTIME].xsize - 2, keyd[KEY_MULTI_SELTIME].ysize - 2,
                         (editflag == 1) ? keybmpind[KEY_MULTI_SELTIME].icon[1] : keybmpind[KEY_MULTI_SELTIME].icon[0]);
            DrawMFS32P(keyd[KEY_MULTI_SELTIME].xpis + (keyd[KEY_MULTI_SELTIME].xsize - 13 * 1) / 2,
                       keyd[KEY_MULTI_SELTIME].ypis + (keyd[KEY_MULTI_SELTIME].ysize - 24) / 2,
                       tmp_times, 1, 0, keybmpind[KEY_MULTI_SELTIME].textColor[0]);
        }
        // /[更新次数数据*end]**********************************************************

        // /[更新数字按键显示*begin]**********************************************************
        if (tpara_offset != tmp_para_offset || dis_updata6)
        {
            if (tmp_para_offset == 0)
            {
                BmpFillRect(keyd[KEY_MULTI_1].xpis, keyd[KEY_MULTI_1].ypis,
                            (keyd[KEY_MULTI_1].xsize + SAFE_DIST5) * 3, (keyd[KEY_MULTI_1].ysize + SAFE_DIST5) * 5);
            }
            else
            {
                if (tpara_offset == 0)
                {
                    for (i = KEY_MULTI_CLEAN; i <= KEY_MULTI_9; i++)
                    {
                        DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
                    }
                }
            }
            dis_updata6 = 0;
            tpara_offset = tmp_para_offset;
        }
        // /[更新数字按键显示*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if (pno != MENU_MULTI)
        {
            plastno = MENU_MULTI;
            break;
        }
        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

/*******************************************************/
#define tmp_zig_zag g_publicbuf[20]
#define tmp_zig_width g_publicbuf[21]
#define tmp_zig_pitch g_publicbuf[22]
#define tmp_zig_direction g_publicbuf[23]

#define KEY_ZIGZAG_SCRNSVR 1 //1 屏保
#define KEY_ZIGZAG_BACK 2    //2 返回
#define KEY_ZIGZAG_ENTER 3   //3 确认

#define KEY_ZIGZAG_ZIGPAT 4    //4 预览
#define KEY_ZIGZAG_NOTZIG 5    //5 无人字缝
#define KEY_ZIGZAG_ZIGZAG 6    //6 人字缝
#define KEY_ZIGZAG_DIRL 7      //7 左侧生成
#define KEY_ZIGZAG_DIRC 8      //8 居中生成
#define KEY_ZIGZAG_DIRR 9      //9 右侧生成
#define KEY_ZIGZAG_SELWIDTH 10 //10 宽度
#define KEY_ZIGZAG_SELPITCH 11 //11 针距

#define KEY_ZIGZAG_CLEAN 12 //12 清除1位
#define KEY_ZIGZAG_UP 13    //13 +1
#define KEY_ZIGZAG_DOWN 14  //14 -1
#define KEY_ZIGZAG_0 15     //15 0
#define KEY_ZIGZAG_1 16     //16 1
#define KEY_ZIGZAG_2 17     //17 2
#define KEY_ZIGZAG_3 18     //18 3
#define KEY_ZIGZAG_4 19     //19 4
#define KEY_ZIGZAG_5 20     //20 5
#define KEY_ZIGZAG_6 21     //21 6
#define KEY_ZIGZAG_7 22     //22 7
#define KEY_ZIGZAG_8 23     //23 8
#define KEY_ZIGZAG_9 24     //24 9

#define KEY_ZIGZAG_MAX 25

#define RECT_ZIGZAG_TYPE 1      //1 人字类型
#define RECT_ZIGZAG_DIR 2       //2 人字方向
#define RECT_ZIGZAG_WIDTH_TIT 3 //3 人字距离-标题
#define RECT_ZIGZAG_PITCH_TIT 4 //4 人字方向-标题
#define RECT_ZIGZAG_WIDTH_STR 5 //5 人字距离-内容
#define RECT_ZIGZAG_PITCH_STR 6 //6 人字方向-内容

#define RECT_ZIGZAG_MAX 5

void Menu_Ctzigzag(void)
{
    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
                                            /****按键相关参数end****/

    /****标志位相关参数begin****/
    U8 dis_updata1 = 1; //刷新Z字缝方法按键
    U8 dis_updata2 = 1; //刷新Z字缝方向按键
    U8 dis_updata3 = 1; //刷新Z字缝文字选框按键
    U8 dis_updata4 = 0; //更新针距数据
    U8 dis_updata5 = 0; //更新宽度数据
    U32 i;
    U8 f;
    U8 editflag = 0;
    U16 tjog_point = g_jog_point;
    /****标志位相关参数end***/

    const U8 keynum = {KEY_ZIGZAG_MAX};

    const KEYPAD keyd[] = {
        {0, 0, 0, 0},

        {0, 0, 128, 32},                     //1 屏保
        {TYPE_X1, TYPE_Y4, KEY_X1, KEY_Y1},  //2 返回
        {TYPE_X11, TYPE_Y4, KEY_X1, KEY_Y1}, //3 确认
        {TYPE_X9, TYPE_Y4, KEY_X1, KEY_Y1},  //4 预览

        {TYPE_X14 + SAFE_DIST1 + KEY_X6, TYPE_Y31, KEY_X6, KEY_Y6},     //5 无人字缝
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 4, TYPE_Y31, KEY_X6, KEY_Y6}, //6 人字缝

        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 1 / 2, TYPE_Y32, KEY_X6, KEY_Y6}, //7 左侧生成
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 5 / 2, TYPE_Y32, KEY_X6, KEY_Y6}, //8 居中生成
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 9 / 2, TYPE_Y32, KEY_X6, KEY_Y6}, //9 右侧生成

        {TYPE_X14 + TYPE_SIZE15 + SAFE_DIST5, 260, TYPE_SIZE14, TYPE_SIZE5},                           //10 宽度
        {TYPE_X14 + TYPE_SIZE15 + SAFE_DIST5, 260 + TYPE_SIZE5 + SAFE_DIST6, TYPE_SIZE14, TYPE_SIZE5}, //11 针距

        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 4, KEY_X2, KEY_Y2},                             //12 清除1位
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},       //13 +1
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2}, //14 -1
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},                             //15 0
        {TYPE_X15, TYPE_Y13, KEY_X2, KEY_Y2},                                                         //16 1
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13, KEY_X2, KEY_Y2},                                   //17 2
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13, KEY_X2, KEY_Y2},                             //18 3
        {TYPE_X15, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},                                   //19 4
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},             //20 5
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},       //21 6
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},                             //22 7
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},       //23 8
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2}, //24 9

    };

    const tydDisSrcIndex keybmpind[] = {
        //title_counter
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},                              //1 屏保
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {72, 88}, {2, 0, 0, 0}, {0}},     //2 返回
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {71, 87}, {3, 0, 0, 0}, {0}},     //3 确认
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {11, 13, 12}, {4, 0, 0, 0}, {0}}, //4 预览

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {442, 444, 443}, {5, 0, 0, 0}, {0}}, //5 无人字缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {445, 447, 446}, {6, 0, 0, 0}, {0}}, //6 人字缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {448, 0, 449}, {7, 0, 0, 0}, {0}},   //7 左侧生成
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {450, 0, 451}, {8, 0, 0, 0}, {0}},   //8 居中生成
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {452, 0, 453}, {9, 0, 0, 0}, {0}},   //9 右侧生成

        {{KEY_Silver}, {Color_Black, Color_Black}, {Color_White, Color_DeepSkyBlue, Color_Black, 0}, {10, 0, 0, 0}, {0}}, //10 宽度
        {{KEY_Silver}, {Color_Black, Color_Black}, {Color_White, Color_DeepSkyBlue, Color_Black, 0}, {11, 0, 0, 0}, {0}}, //11 针距

        {{KEY_Silver}, {0}, {113}, {12, 0, 0, 0}, {0}}, //14 清除1位
        {{KEY_Silver}, {0}, {199}, {13, 0, 0, 0}, {0}}, //15 +1
        {{KEY_Silver}, {0}, {201}, {14, 0, 0, 0}, {0}}, //16 -1
        {{KEY_Silver}, {0}, {91}, {0, 0, 0, 0}, {0}},   //17 0
        {{KEY_Silver}, {0}, {92}, {0, 0, 0, 0}, {0}},   //18 1
        {{KEY_Silver}, {0}, {93}, {0, 0, 0, 0}, {0}},   //19 2
        {{KEY_Silver}, {0}, {94}, {0, 0, 0, 0}, {0}},   //20 3
        {{KEY_Silver}, {0}, {95}, {0, 0, 0, 0}, {0}},   //21 4
        {{KEY_Silver}, {0}, {96}, {0, 0, 0, 0}, {0}},   //22 5
        {{KEY_Silver}, {0}, {97}, {0, 0, 0, 0}, {0}},   //23 6
        {{KEY_Silver}, {0}, {98}, {0, 0, 0, 0}, {0}},   //24 7
        {{KEY_Silver}, {0}, {99}, {0, 0, 0, 0}, {0}},   //25 8
        {{KEY_Silver}, {0}, {100}, {0, 0, 0, 0}, {0}},  //26 9

    };

    const RECTPAD rect[] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {0}},
        {TYPE_X14, TYPE_Y3, TYPE_SIZE29, TYPE_SIZE28, {Color_Black}, {Color_Black, Color_White}, {15}},                            //1 人字类型
        {TYPE_X14, TYPE_Y3 + TYPE_SIZE28 + SAFE_DIST6, TYPE_SIZE29, TYPE_SIZE28, {Color_Black}, {Color_Black, Color_White}, {18}}, //2 人字方向

        {TYPE_X14, TYPE_Y3 + (TYPE_SIZE28 + SAFE_DIST6) * 2, TYPE_SIZE15, TYPE_SIZE5, {Color_KeyBlue}, {Color_White}, {16}},                           //3 人字距离-标题
        {TYPE_X14, TYPE_Y3 + (TYPE_SIZE28 + SAFE_DIST6) * 2 + TYPE_SIZE5 + SAFE_DIST6, TYPE_SIZE15, TYPE_SIZE5, {Color_KeyBlue}, {Color_White}, {17}}, //4 人字方向-标题

        // {TYPE_X15 + TYPE_SIZE15 + SAFE_DIST5, TYPE_Y3 + (TYPE_SIZE28 + SAFE_DIST6) * 2, TYPE_SIZE14, TYPE_SIZE5, {Color_White, Color_DeepSkyBlue}, {Color_Black, Color_Black}, {0}},                           //5 人字距离-内容
        // {TYPE_X15 + TYPE_SIZE15 + SAFE_DIST5, TYPE_Y3 + (TYPE_SIZE28 + SAFE_DIST6) * 2 + TYPE_SIZE5 + SAFE_DIST6, TYPE_SIZE14, TYPE_SIZE5, {Color_White, Color_DeepSkyBlue}, {Color_Black, Color_Black}, {0}}, //6 人字方向-内容
    };

    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_ZIGZAG); //设置当前文字显示雷人在P1页面，对应41.bin
    InitScreen();
    initViewStatus();
    updateViewStatus();

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    if ((plastno != MENU_SCRNSVR) && (plastno != MENU_MOIMAGE))
    {
        tmp_zig_zag = g_zig_zag;
        tmp_zig_width = g_zig_width;
        tmp_zig_pitch = g_zig_pitch;
        tmp_zig_direction = g_zig_direction;
        g_publicbuf[24] = plastno;
    }
    else
    {
        plastno = g_publicbuf[24];
    }
    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                 SheetPage, rect[0].index[0], rect[0].colorT[0]); //花样设计

    //画出方框显示
    // for (i = 1; i < RECT_ZIGZAG_MAX; i++)
    // {

    //     if (i == RECT_ZIGZAG_TYPE)
    //     {
    //         DrawRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);

    //         Draw24x24Str(rect[i].xpis + SAFE_DIST4, rect[i].ypis + SAFE_DIST3,
    //                      MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
    //                      SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
    //     }
    //     // else if (i == RECT_ZIGZAG_PITCH_TIT || i == RECT_ZIGZAG_WIDTH_TIT)
    //     // {
    //     //     DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
    //     //     Draw24x24Str(rect[i].xpis + (rect[i].xsize - 24 * 2) / 2, rect[i].ypis + (rect[i].ysize - 24) / 2,
    //     //                  MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
    //     //                  SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
    //     // }
    // }
    //画出按键显示
    for (i = 2; i < KEY_ZIGZAG_MAX; i++)
    {
        if (i >= KEY_ZIGZAG_BACK && i <= KEY_ZIGZAG_ENTER)
        {
            DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
        }
        else if (i == KEY_ZIGZAG_ZIGPAT)
        {
            if (plastno == MENU_MODIFYADD)
            {
                DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
                // DrawFillRect(144, 735, 288, 62, mCOLOR ? Color_Blue : Color_White);
                // Draw24x24Str(144, 740, (MEM_TITLE_ADD + 19 * TitleLengthMax), SheetPage, 19, mCOLOR ? Color_White : Color_Black); // 确定变更Z字缝
            }
        }
    }

    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************
    ViewPage(usepageno); //设置显示缓存

    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    Timer_ms = 30720; //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        keydata = get_keydata((KEYPAD *)keyd, keynum, 0); //获取键值

        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理
        //无效按键

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            if ((keyon == KEY_ZIGZAG_UP) || (keyon == KEY_ZIGZAG_DOWN))
            {
            }
            else if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {
            //特定情况下不生效按键
            if (((tmp_zig_zag == 0) && (keydata >= KEY_ZIGZAG_DIRL) && (keydata <= KEY_ZIGZAG_SELPITCH)) ||
                ((plastno != MENU_MODIFYADD) && (keydata == KEY_ZIGZAG_ZIGPAT)))
            {
                keydata = 0;
            }
            else if (tmp_zig_zag == 0 && keydata >= KEY_ZIGZAG_CLEAN)
            {
                keydata = 0;
            }
            else
            {
                if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时
                {
                    keyon = keydata;
                    if (keyon == KEY_ZIGZAG_SCRNSVR) //无按键特效
                    {
                    }
                    else if (keyon == KEY_ZIGZAG_SELPITCH || keyon == KEY_ZIGZAG_SELWIDTH) //非常规按键
                    {
                        DrawButtonOnZoomIn(keyd[keyon], 2);
                    }
                    else
                    {
                        DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);
                    }
                    Times = 0;
                    delay = KEYDT; //按键防抖次数
                }
                else if (keyon != keydata) //已有按键按下，不处理新按键信息
                {
                    keydata = 0;
                }

                if (Times > delay) //按键防抖
                {
                    if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                    {
                        beeponf = 1;

                        if (g_keyBellT) //按键时蜂鸣器发声时间
                            Beep_On(g_keyBellT);

                        switch (keyon) //按键按下标题提示语显示
                        {
                        case KEY_ZIGZAG_0:
                        case KEY_ZIGZAG_1:
                        case KEY_ZIGZAG_2:
                        case KEY_ZIGZAG_3:
                        case KEY_ZIGZAG_4:
                        case KEY_ZIGZAG_5:
                        case KEY_ZIGZAG_6:
                        case KEY_ZIGZAG_7:
                        case KEY_ZIGZAG_8:
                        case KEY_ZIGZAG_9:
                            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
                            DrawMFU32(TITLE_XPOS_C2, SAFE_DIST4, keyon - KEY_ZIGZAG_0, 1, rect[0].colorT[0]);
                            break;
                        default:
                            DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                            break;
                        }
                        delay = KEYFT;
                    }
                    else if (beeponf == 1) //第二次进入
                    {
                        beeponf = 2;
                        //带有长按连续功能按键的功能

                        delay = KEYNT;
                    }
                    else if (beeponf < 20)
                    {
                        beeponf++;
                    }

                    if ((keyon == KEY_ZIGZAG_UP) || (keyon == KEY_ZIGZAG_DOWN)) //带有长按连续功能按键的功能
                    {
                        keyoff = keyon;
                        key_on_flag1 = 1;
                    }
                    Times = 0; //当前
                }
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            if ((keyoff >= KEY_ZIGZAG_NOTZIG) && (keyoff <= KEY_ZIGZAG_ZIGZAG))
            {
                tmp_zig_zag = keyoff - KEY_ZIGZAG_NOTZIG;
                dis_updata1 = 1;
                dis_updata2 = 1;
                dis_updata3 = 1;
            }
            else if ((keyoff >= KEY_ZIGZAG_DIRL) && (keyoff <= KEY_ZIGZAG_DIRR))
            {
                tmp_zig_direction = keyoff - KEY_ZIGZAG_DIRL;
                dis_updata2 = 1;
            }
            else if ((keyoff >= KEY_ZIGZAG_0) && (keyoff <= KEY_ZIGZAG_9))
            {
                if (tmp_zig_zag > 0)
                {
                    if (editflag == 0)
                    {
                        tmp_zig_width = (tmp_zig_width % 100) * 10 + keyoff - KEY_ZIGZAG_0;
                        if (tmp_zig_width > 100)
                            tmp_zig_width = tmp_zig_width % 100;
                        dis_updata4 = 1;
                    }
                    else
                    {
                        tmp_zig_pitch = (tmp_zig_pitch % 100) * 10 + keyoff - KEY_ZIGZAG_0;
                        if (tmp_zig_pitch > 100)
                            tmp_zig_pitch = tmp_zig_pitch % 100;
                        dis_updata5 = 1;
                    }
                }
            }
            else
            {
                switch (keyoff)
                {
                case KEY_ZIGZAG_SCRNSVR:
                    pno = MENU_SCRNSVR;
                    break;
                case KEY_ZIGZAG_BACK:
                    pnoindex--;
                    pno = poldno[pnoindex];
                    break;
                case KEY_ZIGZAG_ENTER:
                    g_zig_zag = tmp_zig_zag;
                    if (tmp_zig_width < 1)
                        tmp_zig_width = 1;
                    g_zig_width = (U8)(tmp_zig_width);
                    if (tmp_zig_pitch < 5)
                        tmp_zig_pitch = 5;
                    g_zig_pitch = (U8)(tmp_zig_pitch);
                    g_zig_direction = tmp_zig_direction;
                    if (plastno == MENU_MODIFYADD)
                    {
                        if (P_FHP) //先按照原花园回到原点
                        {
                            g_patd.pat_add = 52000;
                            tjog_point = g_jog_point;
                            Go_Home(MENU_CONVERT, 1);
                            g_jog_point = tjog_point;
                        }

                        f = Mit_Convert_Data(2);

                        if (P_FHP)
                        {
                            g_jog_point = 0;
                        }

                        if (f == 1)
                        {
                            //AnaPattern(0,0,0);
                            if (g_jog_point > g_patd.feed_sum)
                                g_jog_point = 0;

                            if (P_FHP) //已经回到原点位置了
                            {
                            }
                            else
                            {
                                g_patd.pat_add = 52000;
                                mit_getPointXY(g_jog_point, g_patd.pat_add, (S16 *)&g_tmpoxpos, (S16 *)&g_tmpoypos);
                                Send_Pfoot(1, MENU_CONVERT, 1);                           //压脚升
                                Comm_Move(g_tmpoxpos, g_tmpoypos, 50, MENU_ZIGZAG, 0, 0); //移动到当前坐标
                                Wait_Move_End();                                          //等待平台移动结束
                            }

                            pno = MENU_INHELP;
                            hleppara = 6;
                            poldno[pnoindex] = MENU_ZIGZAG;
                            pnoindex++;
                        }
                        else
                        {
                            pno = MENU_RWHELP;
                            hleppara = 145;
                            poldno[pnoindex] = MENU_ZIGZAG;
                            pnoindex++;
                        }
                    }
                    else
                    {
                        pnoindex--;
                        pno = poldno[pnoindex];
                    }
                    break;

                case KEY_ZIGZAG_ZIGPAT:
                    pno = MENU_MOIMAGE;
                    poldno[pnoindex] = MENU_ZIGZAG;
                    pnoindex++;
                    g_imgpara = MOIMAGE_CVIEW;
                    break;
                case KEY_ZIGZAG_SELWIDTH:
                    editflag = 0;
                    dis_updata3 = 1;
                    break;
                case KEY_ZIGZAG_SELPITCH:
                    editflag = 1;
                    dis_updata3 = 1;
                    break;
                case KEY_ZIGZAG_CLEAN:
                    if (tmp_zig_zag > 0)
                    {
                        if (editflag == 0)
                        {
                            tmp_zig_width = 0;
                            dis_updata4 = 1;
                        }
                        else
                        {
                            tmp_zig_pitch = 0;
                            dis_updata5 = 1;
                        }
                    }
                    break;
                case KEY_ZIGZAG_UP:
                    if (tmp_zig_zag > 0)
                    {
                        if (editflag == 0)
                        {
                            if (tmp_zig_width < 100)
                                tmp_zig_width++;
                            dis_updata4 = 1;
                        }
                        else
                        {
                            if (tmp_zig_pitch < 100)
                                tmp_zig_pitch++;
                            dis_updata5 = 1;
                        }
                    }
                    break;
                case KEY_ZIGZAG_DOWN:
                    if (tmp_zig_zag > 0)
                    {
                        if (editflag == 0)
                        {
                            if (tmp_zig_width > 1)
                                tmp_zig_width--;
                            dis_updata4 = 1;
                        }
                        else
                        {
                            if (tmp_zig_pitch > 5)
                                tmp_zig_pitch--;
                            dis_updata5 = 1;
                        }
                    }
                    break;
                }
            }
            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            if (keyon == KEY_ZIGZAG_SCRNSVR) //不需要显示的按键
            {
            }
            else if (keyon == KEY_ZIGZAG_SELPITCH || keyon == KEY_ZIGZAG_SELWIDTH) //非常规按键
            {
                DrawButtonOnZoomInRes(keyd[keyon]);
            }
            else //常规按键
            {
                DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);
            }

            keyon = 0;
            beeponf = 0;
            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
            Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                         SheetPage, rect[0].index[0], rect[0].colorT[0]); //显示回花样设计
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if (Timerms > 1000)
        {
            Timerms = 0;
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1)
        {
            ErrorMsg(MENU_ZIGZAG);
        }
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*begin]**********************************************************
        if (beeponf == 0)
        {
            ErrorMsg(MENU_ZIGZAG);
        }
        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*end]**********************************************************

        // /[更新人字方法按键与数字输入按键*begin]**********************************************************
        if (dis_updata1)
        {
            dis_updata1 = 0;

            DrawRect(rect[RECT_ZIGZAG_TYPE].xpis, rect[RECT_ZIGZAG_TYPE].ypis,
                     rect[RECT_ZIGZAG_TYPE].xsize, rect[RECT_ZIGZAG_TYPE].ysize, rect[RECT_ZIGZAG_TYPE].colorB[0]);

            Draw24x24Str(rect[RECT_ZIGZAG_TYPE].xpis + SAFE_DIST4, rect[RECT_ZIGZAG_TYPE].ypis + SAFE_DIST3,
                         MEM_TITLE_ADD + rect[RECT_ZIGZAG_TYPE].index[0] * TitleLengthMax,
                         SheetPage, rect[RECT_ZIGZAG_TYPE].index[0], rect[RECT_ZIGZAG_TYPE].colorT[0]); //画出方框的文字

            f = KEY_ZIGZAG_NOTZIG + tmp_zig_zag;
            for (i = KEY_ZIGZAG_NOTZIG; i <= KEY_ZIGZAG_ZIGZAG; i++)
            {
                DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                           (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                           (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
            }
            if (tmp_zig_zag == 0)
            {
                BmpFillRect(keyd[KEY_ZIGZAG_1].xpis, keyd[KEY_ZIGZAG_1].ypis,
                            (keyd[KEY_ZIGZAG_1].xsize + SAFE_DIST5) * 3, (keyd[KEY_ZIGZAG_1].ysize + SAFE_DIST5) * 5);
            }
            else
            {
                for (i = KEY_ZIGZAG_CLEAN; i <= KEY_ZIGZAG_9; i++)
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
                }
            }
            if (tmp_zig_zag == 0)
                editflag = 0;
        }
        // /[更新人字方法按键与数字输入按键*end]**********************************************************

        // /[更新方向按键*begin]**********************************************************
        if (dis_updata2)
        {
            dis_updata2 = 0;

            if (tmp_zig_zag)
            {
                f = KEY_ZIGZAG_DIRL + tmp_zig_direction;
                for (i = KEY_ZIGZAG_DIRL; i <= KEY_ZIGZAG_DIRR; i++)
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                               (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                }

                DrawRect(rect[RECT_ZIGZAG_DIR].xpis, rect[RECT_ZIGZAG_DIR].ypis, rect[RECT_ZIGZAG_DIR].xsize, rect[RECT_ZIGZAG_DIR].ysize, rect[RECT_ZIGZAG_DIR].colorB[0]);
                Draw24x24Str(rect[RECT_ZIGZAG_DIR].xpis + SAFE_DIST4, rect[RECT_ZIGZAG_DIR].ypis + SAFE_DIST3,
                             MEM_TITLE_ADD + rect[RECT_ZIGZAG_DIR].index[0] * TitleLengthMax,
                             SheetPage, rect[RECT_ZIGZAG_DIR].index[0], rect[RECT_ZIGZAG_DIR].colorT[0]); //画出方框的文字
            }
            else
            {
                BmpFillRect(rect[RECT_ZIGZAG_DIR].xpis, rect[RECT_ZIGZAG_DIR].ypis, rect[RECT_ZIGZAG_DIR].xsize, rect[RECT_ZIGZAG_DIR].ysize);
            }
        }
        // /[更新方向按键*end]**********************************************************

        // /[更新宽度与针距按键*begin]**********************************************************
        if (dis_updata3)
        {
            dis_updata3 = 0;

            if (tmp_zig_zag)
            {
                DrawFillRect(rect[RECT_ZIGZAG_WIDTH_TIT].xpis, rect[RECT_ZIGZAG_WIDTH_TIT].ypis, rect[RECT_ZIGZAG_WIDTH_TIT].xsize, rect[RECT_ZIGZAG_WIDTH_TIT].ysize, rect[RECT_ZIGZAG_WIDTH_TIT].colorB[0]);
                Draw24x24Str(rect[RECT_ZIGZAG_WIDTH_TIT].xpis + (rect[RECT_ZIGZAG_WIDTH_TIT].xsize - strlen((char *)(MEM_TITLE_ADD + rect[RECT_ZIGZAG_WIDTH_TIT].index[0] * TitleLengthMax)) * 13) / 2,
                             rect[RECT_ZIGZAG_WIDTH_TIT].ypis + (rect[RECT_ZIGZAG_WIDTH_TIT].ysize - 24) / 2,
                             MEM_TITLE_ADD + rect[RECT_ZIGZAG_WIDTH_TIT].index[0] * TitleLengthMax,
                             SheetPage, rect[RECT_ZIGZAG_WIDTH_TIT].index[0], rect[RECT_ZIGZAG_WIDTH_TIT].colorT[0]); //画出方框的文字

                DrawButtonEdit(keyd[KEY_ZIGZAG_SELWIDTH],
                               (editflag == 0) ? keybmpind[KEY_ZIGZAG_SELWIDTH].icon[1] : keybmpind[KEY_ZIGZAG_SELWIDTH].icon[0],
                               (editflag == 0) ? keybmpind[KEY_ZIGZAG_SELWIDTH].textColor[0] : keybmpind[KEY_ZIGZAG_SELWIDTH].icon[0]);
                DrawF16Str(keyd[KEY_ZIGZAG_SELWIDTH].xpis + keyd[KEY_ZIGZAG_SELWIDTH].xsize + SAFE_DIST4,
                           keyd[KEY_ZIGZAG_SELWIDTH].ypis + (keyd[KEY_ZIGZAG_SELWIDTH].ysize - 16) / 2,
                           "(0.1-10.0)", keybmpind[KEY_ZIGZAG_SELWIDTH].textColor[1]);

                dis_updata4 = 1;

                DrawFillRect(rect[RECT_ZIGZAG_PITCH_TIT].xpis, rect[RECT_ZIGZAG_PITCH_TIT].ypis, rect[RECT_ZIGZAG_PITCH_TIT].xsize, rect[RECT_ZIGZAG_PITCH_TIT].ysize, rect[RECT_ZIGZAG_PITCH_TIT].colorB[0]);
                Draw24x24Str(rect[RECT_ZIGZAG_PITCH_TIT].xpis + (rect[RECT_ZIGZAG_PITCH_TIT].xsize - strlen((char *)(MEM_TITLE_ADD + rect[RECT_ZIGZAG_PITCH_TIT].index[0] * TitleLengthMax)) * 13) / 2,
                             rect[RECT_ZIGZAG_PITCH_TIT].ypis + (rect[RECT_ZIGZAG_PITCH_TIT].ysize - 24) / 2,
                             MEM_TITLE_ADD + rect[RECT_ZIGZAG_PITCH_TIT].index[0] * TitleLengthMax,
                             SheetPage, rect[RECT_ZIGZAG_PITCH_TIT].index[0], rect[RECT_ZIGZAG_PITCH_TIT].colorT[0]); //画出方框的文字

                DrawButtonEdit(keyd[KEY_ZIGZAG_SELPITCH],
                               (editflag == 1) ? keybmpind[KEY_ZIGZAG_SELPITCH].icon[1] : keybmpind[KEY_ZIGZAG_SELPITCH].icon[0],
                               (editflag == 1) ? keybmpind[KEY_ZIGZAG_SELPITCH].textColor[0] : keybmpind[KEY_ZIGZAG_SELPITCH].icon[0]);
                DrawF16Str(keyd[KEY_ZIGZAG_SELPITCH].xpis + keyd[KEY_ZIGZAG_SELPITCH].xsize + SAFE_DIST4,
                           keyd[KEY_ZIGZAG_SELPITCH].ypis + (keyd[KEY_ZIGZAG_SELPITCH].ysize - 16) / 2,
                           "(0.5-10.0)", keybmpind[KEY_ZIGZAG_SELPITCH].textColor[1]);

                dis_updata5 = 1;
            }
            else
            {
                BmpFillRect(rect[RECT_ZIGZAG_WIDTH_TIT].xpis, rect[RECT_ZIGZAG_WIDTH_TIT].ypis, TYPE_SIZE29, rect[RECT_ZIGZAG_WIDTH_TIT].ysize);
                BmpFillRect(rect[RECT_ZIGZAG_PITCH_TIT].xpis, rect[RECT_ZIGZAG_PITCH_TIT].ypis, TYPE_SIZE29, rect[RECT_ZIGZAG_PITCH_TIT].ysize);
            }
        }

        // /[更新宽度与针距按键*end]**********************************************************

        // /[更新宽度数据*begin]**********************************************************
        if (dis_updata4)
        {
            dis_updata4 = 0;
            DrawFillRect(keyd[KEY_ZIGZAG_SELWIDTH].xpis + 1, keyd[KEY_ZIGZAG_SELWIDTH].ypis + 1,
                         keyd[KEY_ZIGZAG_SELWIDTH].xsize - 2, keyd[KEY_ZIGZAG_SELWIDTH].ysize - 2,
                         (editflag == 0) ? keybmpind[KEY_ZIGZAG_SELWIDTH].icon[1] : keybmpind[KEY_ZIGZAG_SELWIDTH].icon[0]);
            DrawMFS32P(keyd[KEY_ZIGZAG_SELWIDTH].xpis + (keyd[KEY_ZIGZAG_SELWIDTH].xsize - 13 * 4) / 2,
                       keyd[KEY_ZIGZAG_SELWIDTH].ypis + (keyd[KEY_ZIGZAG_SELWIDTH].ysize - 24) / 2,
                       tmp_zig_width, 4, 1, keybmpind[KEY_ZIGZAG_SELWIDTH].textColor[0]);
        }
        // /[更新宽度数据*end]**********************************************************

        // /[更新针距数据*begin]**********************************************************
        if (dis_updata5)
        {
            dis_updata5 = 0;
            DrawFillRect(keyd[KEY_ZIGZAG_SELPITCH].xpis + 1, keyd[KEY_ZIGZAG_SELPITCH].ypis + 1,
                         keyd[KEY_ZIGZAG_SELPITCH].xsize - 2, keyd[KEY_ZIGZAG_SELPITCH].ysize - 2,
                         (editflag == 1) ? keybmpind[KEY_ZIGZAG_SELPITCH].icon[1] : keybmpind[KEY_ZIGZAG_SELPITCH].icon[0]);
            DrawMFS32P(keyd[KEY_ZIGZAG_SELPITCH].xpis + (keyd[KEY_ZIGZAG_SELPITCH].xsize - 13 * 4) / 2,
                       keyd[KEY_ZIGZAG_SELPITCH].ypis + (keyd[KEY_ZIGZAG_SELPITCH].ysize - 24) / 2,
                       tmp_zig_pitch, 4, 1, keybmpind[KEY_ZIGZAG_SELPITCH].textColor[0]);
        }
        // /[更新针距数据*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if (pno != MENU_ZIGZAG)
        {
            plastno = MENU_ZIGZAG;
            break;
        }
        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

/*******************************************************/
#define tmp_bt_mode g_publicbuf[25]
#define tmp_repeat g_publicbuf[26]
#define tmp_r_stitch g_publicbuf[27]
#define tmp_srt_bt g_publicbuf[28]
#define tmp_s_stitch g_publicbuf[29]
#define tmp_ent_bt g_publicbuf[30]
#define tmp_e_stitch g_publicbuf[31]

#define KEY_TACKING_SCRNSVR 1  //1 屏保
#define KEY_TACKING_BACK 2     //2 返回
#define KEY_TACKING_ENTER 3    //3 确认
#define KEY_TACKING_TACKPAT 4  //4 预览
#define KEY_TACKING_NOTTACK 5  //5 无倒缝
#define KEY_TACKING_TACK 6     //6 有倒缝
#define KEY_TACKING_OVERLAP 7  //7 重叠缝
#define KEY_TACKING_OVLP1 8    //8 重叠缝样式-1
#define KEY_TACKING_OVLP2 9    //9 重叠缝样式-2
#define KEY_TACKING_OVLP3 10   //10 重叠缝样式-3
#define KEY_TACKING_OVLP4 11   //11 重叠缝样式-4
#define KEY_TACKING_STRV 12    //12 前倒缝样式-1
#define KEY_TACKING_STRN 13    //13 前倒缝样式-2
#define KEY_TACKING_STRW 14    //14 前倒缝样式-3
#define KEY_TACKING_STRM 15    //15 前倒缝样式-4
#define KEY_TACKING_ENDV 16    //16 后倒缝样式-1
#define KEY_TACKING_ENDN 17    //17 后倒缝样式-2
#define KEY_TACKING_ENDW 18    //18 后倒缝样式-3
#define KEY_TACKING_ENDM 19    //19 后倒缝样式-4
#define KEY_TACKING_SELOVER 20 //20 重叠缝针数
#define KEY_TACKING_SELSTRP 21 //21 前倒缝针数
#define KEY_TACKING_SELENDP 22 //22 后倒缝针数
#define KEY_TACKING_CLEAN 23   //23 清除1位
#define KEY_TACKING_UP 24      //24 +1
#define KEY_TACKING_DOWN 15    //25 -1
#define KEY_TACKING_0 26       //26 0
#define KEY_TACKING_1 27       //27 1
#define KEY_TACKING_2 28       //28 2
#define KEY_TACKING_3 29       //29 3
#define KEY_TACKING_4 30       //30 4
#define KEY_TACKING_5 31       //31 5
#define KEY_TACKING_6 32       //32 6
#define KEY_TACKING_7 33       //33 7
#define KEY_TACKING_8 34       //34 8
#define KEY_TACKING_9 35       //35 9

#define KEY_TACKING_MAX 36

#define RECT_TACKING_TYPE 1  //1 倒缝类型
#define RECT_TACKING_OVER 2  //2 重叠缝
#define RECT_TACKING_START 3 //3 起始倒缝
#define RECT_TACKING_END 4   //4 终止倒缝

#define RECT_TACKING_OVER_TIT 5  //5 重叠缝-标题
#define RECT_TACKING_START_TIT 6 //6 起始倒缝-标题
#define RECT_TACKING_END_TIT 7   //7 终止倒缝-标题
#define RECT_TACKING_OVER_STR 8  //8 重叠缝-内容
#define RECT_TACKING_START_STR 9 //9 起始倒缝-内容
#define RECT_TACKING_END_STR 10  //10 终止倒缝-内容

#define RECT_TACKING_MAX 8

void Menu_Cttacking(void)
{
    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
                                            /****按键相关参数end****/

    /****标志位相关参数begin****/
    U8 dis_updata1 = 1; //更新倒缝方法按键
    U8 dis_updata2 = 1; //更新倒缝针数设定的方框
    U8 dis_updata3 = 1; //更新倒缝针数设定的数据选择按钮
    U8 dis_updata4 = 0; //更新起始倒缝针数
    U8 dis_updata5 = 0; //更新终止倒缝针数
    U8 dis_updata6 = 0; //更新重叠缝针数
    U32 i;
    U8 f;
    U8 editflag = 0;
    U32 n1, sum;
    U32 dat, add;
    S16 x, y;
    U8 occlude = 0; //重叠缝有效标志
    U8 tmpbtmode = 0xff;
    U32 St_point = 0, En_point = 0;
    /****标志位相关参数end***/

    //const U8 keynum = {KEY_TACKING_MAX};

    const KEYPAD keyd[] = {
        {0, 0, 0, 0},

        {0, 0, 128, 32},                     //1 屏保
        {TYPE_X1, TYPE_Y4, KEY_X1, KEY_Y1},  //2 返回
        {TYPE_X11, TYPE_Y4, KEY_X1, KEY_Y1}, //3 确认
        {TYPE_X9, TYPE_Y4, KEY_X1, KEY_Y1},  //4 预览

        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 1 / 2, TYPE_Y31, KEY_X6, KEY_Y6},                                          //5 无倒缝
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 5 / 2, TYPE_Y31, KEY_X6, KEY_Y6},                                          //6 有倒缝
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 9 / 2, TYPE_Y31, KEY_X6, KEY_Y6},                                          //7 重叠缝
        {TYPE_X14 + SAFE_DIST1, TYPE_Y32, KEY_X6, KEY_Y6},                                                           //8 重叠缝样式-1
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 5 / 3, TYPE_Y32, KEY_X6, KEY_Y6},                                          //9 重叠缝样式-2
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 10 / 3, TYPE_Y32, KEY_X6, KEY_Y6},                                         //10 重叠缝样式-3
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 15 / 3, TYPE_Y32, KEY_X6, KEY_Y6},                                         //11 重叠缝样式-4
        {TYPE_X14 + SAFE_DIST1, TYPE_Y32, KEY_X6, KEY_Y6},                                                           //12 前倒缝样式-1
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 5 / 3, TYPE_Y32, KEY_X6, KEY_Y6},                                          //13 前倒缝样式-2
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 10 / 3, TYPE_Y32, KEY_X6, KEY_Y6},                                         //14 前倒缝样式-3
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 15 / 3, TYPE_Y32, KEY_X6, KEY_Y6},                                         //15 前倒缝样式-4
        {TYPE_X14 + SAFE_DIST1, TYPE_Y35, KEY_X6, KEY_Y6},                                                           //16 后倒缝样式-1
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 5 / 3, TYPE_Y35, KEY_X6, KEY_Y6},                                          //17 后倒缝样式-2
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 10 / 3, TYPE_Y35, KEY_X6, KEY_Y6},                                         //18 后倒缝样式-3
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 15 / 3, TYPE_Y35, KEY_X6, KEY_Y6},                                         //19 后倒缝样式-4
        {TYPE_X14 + SAFE_DIST1 + TYPE_SIZE15 + SAFE_DIST5, TYPE_Y32 + KEY_Y6 + SAFE_DIST6, TYPE_SIZE14, TYPE_SIZE5}, //20 重叠缝针数
        {TYPE_X14 + SAFE_DIST1 + TYPE_SIZE15 + SAFE_DIST5, TYPE_Y32 + KEY_Y6 + SAFE_DIST6, TYPE_SIZE14, TYPE_SIZE5}, //21 前倒缝针数
        {TYPE_X14 + SAFE_DIST1 + TYPE_SIZE15 + SAFE_DIST5, TYPE_Y35 + KEY_Y6 + SAFE_DIST6, TYPE_SIZE14, TYPE_SIZE5}, //22 后倒缝针数

        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 4, KEY_X2, KEY_Y2},                             //23 清除1位
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},       //24 +1
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2}, //25 -1
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},                             //26 0
        {TYPE_X15, TYPE_Y13, KEY_X2, KEY_Y2},                                                         //27 1
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13, KEY_X2, KEY_Y2},                                   //28 2
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13, KEY_X2, KEY_Y2},                             //29 3
        {TYPE_X15, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},                                   //30 4
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},             //31 5
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},       //32 6
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},                             //33 7
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},       //34 8
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2}, //35 9

    };

    const tydDisSrcIndex keybmpind[] = {
        //title_counter
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},                              //1 屏保
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {72, 88}, {2, 0, 0, 0}, {0}},     //2 返回
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {71, 87}, {3, 0, 0, 0}, {0}},     //3 确认
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {11, 13, 12}, {4, 0, 0, 0}, {0}}, //4 预览

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {457, 459, 458}, {5, 0, 0, 0}, {0}},                                      //5 无倒缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {460, 462, 461}, {6, 0, 0, 0}, {0}},                                      //6 有倒缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {463, 465, 464}, {7, 0, 0, 0}, {0}},                                      //7 重叠缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {477, 0, 478}, {8, 0, 0, 0}, {0}},                                        //8 重叠缝样式-1
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {479, 0, 480}, {9, 0, 0, 0}, {0}},                                        //9 重叠缝样式-2
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {481, 0, 482}, {10, 0, 0, 0}, {0}},                                       //10 重叠缝样式-3
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {483, 0, 484}, {11, 0, 0, 0}, {0}},                                       //11 重叠缝样式-4
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {469, 0, 470}, {12, 0, 0, 0}, {0}},                                       //12 前倒缝样式-1
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {471, 0, 472}, {13, 0, 0, 0}, {0}},                                       //13 前倒缝样式-2
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {473, 0, 474}, {14, 0, 0, 0}, {0}},                                       //14 前倒缝样式-3
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {475, 0, 476}, {15, 0, 0, 0}, {0}},                                       //15 前倒缝样式-4
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {469, 0, 470}, {16, 0, 0, 0}, {0}},                                       //16 后倒缝样式-1
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {471, 0, 472}, {17, 0, 0, 0}, {0}},                                       //17 后倒缝样式-2
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {473, 0, 474}, {18, 0, 0, 0}, {0}},                                       //18 后倒缝样式-3
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {475, 0, 476}, {19, 0, 0, 0}, {0}},                                       //19 后倒缝样式-4
        {{KEY_Silver}, {Color_Black, Color_Black}, {Color_White, Color_DeepSkyBlue, Color_Black, 0}, {30, 0, 0, 0}, {0}}, //20 重叠缝针数
        {{KEY_Silver}, {Color_Black, Color_Black}, {Color_White, Color_DeepSkyBlue, Color_Black, 0}, {20, 0, 0, 0}, {0}}, //21 前倒缝针数
        {{KEY_Silver}, {Color_Black, Color_Black}, {Color_White, Color_DeepSkyBlue, Color_Black, 0}, {21, 0, 0, 0}, {0}}, //22 后倒缝针数

        {{KEY_Silver}, {0}, {113}, {22, 0, 0, 0}, {0}}, //23 清除1位
        {{KEY_Silver}, {0}, {199}, {23, 0, 0, 0}, {0}}, //24 +1
        {{KEY_Silver}, {0}, {201}, {24, 0, 0, 0}, {0}}, //25 -1
        {{KEY_Silver}, {0}, {91}, {0, 0, 0, 0}, {0}},   //26 0
        {{KEY_Silver}, {0}, {92}, {0, 0, 0, 0}, {0}},   //27 1
        {{KEY_Silver}, {0}, {93}, {0, 0, 0, 0}, {0}},   //28 2
        {{KEY_Silver}, {0}, {94}, {0, 0, 0, 0}, {0}},   //29 3
        {{KEY_Silver}, {0}, {95}, {0, 0, 0, 0}, {0}},   //30 4
        {{KEY_Silver}, {0}, {96}, {0, 0, 0, 0}, {0}},   //31 5
        {{KEY_Silver}, {0}, {97}, {0, 0, 0, 0}, {0}},   //32 6
        {{KEY_Silver}, {0}, {98}, {0, 0, 0, 0}, {0}},   //33 7
        {{KEY_Silver}, {0}, {99}, {0, 0, 0, 0}, {0}},   //34 8
        {{KEY_Silver}, {0}, {100}, {0, 0, 0, 0}, {0}},  //35 9

    };

    const RECTPAD rect[] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {0}},
        {TYPE_X14, TYPE_Y3, TYPE_SIZE29, TYPE_SIZE28, {Color_Black}, {Color_Black, Color_White}, {TLFNADD_CTTACK1 + 3}},                      //1 倒缝类型
        {TYPE_X14, TYPE_Y3 + TYPE_SIZE28 + SAFE_DIST6, TYPE_SIZE29, 139, {Color_Black}, {Color_Black, Color_White}, {29}},                    //2 重叠缝
        {TYPE_X14, TYPE_Y3 + TYPE_SIZE28 + SAFE_DIST6, TYPE_SIZE29, 139, {Color_Black}, {Color_Black, Color_White}, {27}},                    //3 起始倒缝
        {TYPE_X14, TYPE_Y3 + TYPE_SIZE28 + SAFE_DIST6 + 139 + SAFE_DIST6, TYPE_SIZE29, 139, {Color_Black}, {Color_Black, Color_White}, {28}}, //4 终止倒缝

        {TYPE_X14 + SAFE_DIST1, TYPE_Y3 + TYPE_SIZE28 + SAFE_DIST6 + 139 - SAFE_DIST1 - TYPE_SIZE5, TYPE_SIZE15, TYPE_SIZE5, {Color_KeyBlue}, {Color_White}, {30}},         //5 重叠缝-标题
        {TYPE_X14 + SAFE_DIST1, TYPE_Y3 + TYPE_SIZE28 + SAFE_DIST6 + 139 - SAFE_DIST1 - TYPE_SIZE5, TYPE_SIZE15, TYPE_SIZE5, {Color_KeyBlue}, {Color_White}, {20}},         //6 起始倒缝-标题
        {TYPE_X14 + SAFE_DIST1, TYPE_Y3 + TYPE_SIZE28 + SAFE_DIST6 * 2 + 139 * 2 - SAFE_DIST1 - TYPE_SIZE5, TYPE_SIZE15, TYPE_SIZE5, {Color_KeyBlue}, {Color_White}, {21}}, //7 终止倒缝-标题

    };

    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_TACKING); //设置当前文字显示雷人在P1页面，对应41.bin
    InitScreen();
    initViewStatus();
    updateViewStatus();

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    if ((plastno != MENU_SCRNSVR) && (plastno != MENU_MOIMAGE))
    {
        tmp_bt_mode = g_bt_mode;
        tmp_repeat = g_repeat;
        tmp_r_stitch = g_r_stitch;
        tmp_srt_bt = g_srt_bt;
        tmp_s_stitch = g_s_stitch;
        tmp_ent_bt = g_ent_bt;
        tmp_e_stitch = g_e_stitch;
        g_publicbuf[32] = plastno;
    }
    else
    {
        plastno = g_publicbuf[32];
    }

    if (plastno == MENU_MODIFYADD)
    {
        // DrawButton2(keyd[KEY_TACKING_TACKPAT], Color_White1, keybmpind[KEY_TACKING_TACKPAT], 1);
        DrawButton(keyd[KEY_TACKING_TACKPAT], (U16 *)(ADD_ICONBMP),
                   keybmpind[KEY_TACKING_TACKPAT].border[0], keybmpind[KEY_TACKING_TACKPAT].icon[0]);

        // DrawFillRect(144, 735, 288, 62, mCOLOR ? Color_Blue : Color_White);
        // Draw24x24Str(144, 740, (MEM_TITLE_ADD + 31 * TitleLengthMax), SheetPage, 31, mCOLOR ? Color_White : Color_Black); // 确定变更倒针

        if (F_FILETYPE == PAT_MIT)
        { //三菱
            add = g_patd.draw_add;
            sum = 0;
            while (sum <= g_patd.feed_sum)
            {
                dat = Mit_Analyse_Data1(&n1, &sum, add);
                if (dat == 0)
                {
                    add = 0;
                    break;
                }
                if (g_jog_point < sum)
                {
                    add = dat;
                    break;
                }
                add = dat + 4;
            }
            occlude = 0; // 所选的绘图数据是否是封闭标志
            dat = SREG[add] & 0x1fd;
            if (dat == 0xcc)
            {
                occlude = 1;
            }
            else if ((dat == 0xd4) || (dat == 0xd8))
            {
                x = ((S16)SREG[add + 2]);
                y = ((S16)SREG[add + 3]);
                dat = dat + 0x100;
                for (add -= 4; add > g_patd.draw_add; add -= 4)
                {
                    if ((SREG[add] != dat) && (SREG[add] != 0x2d4))
                        break;
                    x += ((S16)SREG[add + 2]);
                    y += ((S16)SREG[add + 3]);
                }
                if ((x == 0) && (y == 0))
                    occlude = 1;
            }
        }
        else if (F_FILETYPE == PAT_SEW)
        { //兄弟
            tmp_bt_mode = 1;
            St_point = g_jog_point;
            En_point = g_jog_point;
            occlude = Bor_Isocclu(g_jog_point, &St_point, &En_point, (F_FILELEN));
        }
    }
    else if ((g_input_method == 1) || (g_input_method == 2) || (g_input_method == 5))
    { //直线,点,曲线没有重叠缝
        occlude = 0;
    }
    else
    {
        occlude = 1;
    }

    if ((occlude == 0) && (g_bt_mode == 2))
        g_bt_mode = 0;
    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                 SheetPage, rect[0].index[0], rect[0].colorT[0]); //倒针参数

    //画出方框显示
    // for (i = 1; i < RECT_TACKING_MAX; i++)
    // {

    //     if (i == RECT_TACKING_TYPE)
    //     {
    //         DrawRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);

    //         Draw24x24Str(rect[i].xpis + SAFE_DIST4, rect[i].ypis + SAFE_DIST3,
    //                      MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
    //                      SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
    //     }
    //     // else if (i == RECT_TACKING_END_TIT || i == RECT_TACKING_START_TIT)
    //     // {
    //     //     DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
    //     //     Draw24x24Str(rect[i].xpis + (rect[i].xsize - 24 * 2) / 2, rect[i].ypis + (rect[i].ysize - 24) / 2,
    //     //                  MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
    //     //                  SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
    //     // }
    // }
    //画出按键显示
    for (i = 2; i < KEY_TACKING_MAX; i++)
    {
        if (i >= KEY_TACKING_BACK && i <= KEY_TACKING_ENTER)
        {
            DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
        }
    }

    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************
    ViewPage(usepageno); //设置显示缓存

    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    Timer_ms = 30720; //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        keydata = get_keydata((KEYPAD *)keyd, KEY_TACKING_OVERLAP + 1, 0); //获取键值
        if (keydata == 0)
        {
            keydata = get_keydata((KEYPAD *)keyd, KEY_TACKING_9 + 1, KEY_TACKING_CLEAN); //获取键值
        }

        if ((tmp_bt_mode == 1) && (keydata == 0))
        {
            keydata = get_keydata((KEYPAD *)keyd, KEY_TACKING_ENDM + 1, KEY_TACKING_STRV); //获取键值
            if (keydata == 0)
            {
                keydata = get_keydata((KEYPAD *)keyd, KEY_TACKING_SELENDP + 1, KEY_TACKING_SELSTRP); //获取键值
            }
        }
        else if ((tmp_bt_mode == 2) && (keydata == 0))
        {
            keydata = get_keydata((KEYPAD *)keyd, KEY_TACKING_OVLP4 + 1, KEY_TACKING_OVLP1); //获取键值
            if (keydata == 0)
            {
                keydata = get_keydata((KEYPAD *)keyd, KEY_TACKING_SELOVER + 1, KEY_TACKING_SELOVER); //获取键值
            }
        }

        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理
        //无效按键

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            if ((keyon == KEY_TACKING_UP) || (keyon == KEY_TACKING_DOWN))
            {
            }
            else if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {
            //特定情况下不生效按键
            if ((tmp_bt_mode == 0) && (keydata >= KEY_TACKING_OVLP1) && (keydata <= KEY_TACKING_SELENDP))
            {
                keydata = 0;
            }
            else if ((plastno != MENU_MODIFYADD) && (keydata == KEY_TACKING_TACKPAT))
            {
                keydata = 0;
            }
            else if ((tmp_bt_mode != 1) &&
                     ((keydata >= KEY_TACKING_STRV && keydata <= KEY_TACKING_ENDM) ||
                      (keydata >= KEY_TACKING_SELSTRP && keydata <= KEY_TACKING_SELENDP)))
            {
                keydata = 0;
            }
            else if ((tmp_bt_mode != 2) &&
                     ((keydata >= KEY_TACKING_OVLP1 && keydata <= KEY_TACKING_OVLP4) ||
                      keydata == KEY_TACKING_SELOVER))
            {
                keydata = 0;
            }
            else if ((keydata == KEY_TACKING_OVERLAP) && (occlude == 0))
            {
                keydata = 0;
            }
            else if ((F_FILETYPE == PAT_SEW) && (plastno == MENU_MODIFYADD) && (keydata == KEY_TACKING_NOTTACK))
            {
                keydata = 0;
            }
            else if (tmp_bt_mode == 0 && keydata >= KEY_TACKING_CLEAN)
            {
                keydata = 0;
            }
            else
            {
                if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时
                {
                    keyon = keydata;
                    if (keyon == KEY_TACKING_SCRNSVR) //无按键特效
                    {
                    }
                    else if (keyon == KEY_TACKING_SELENDP || keyon == KEY_TACKING_SELSTRP || keyon == KEY_TACKING_SELOVER) //非常规按键
                    {
                        DrawButtonOnZoomIn(keyd[keyon], 2);
                    }
                    else
                    {
                        DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);
                    }
                    Times = 0;
                    delay = KEYDT; //按键防抖次数
                }
                else if (keyon != keydata) //已有按键按下，不处理新按键信息
                {
                    keydata = 0;
                }

                if (Times > delay) //按键防抖
                {
                    if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                    {
                        beeponf = 1;

                        if (g_keyBellT) //按键时蜂鸣器发声时间
                            Beep_On(g_keyBellT);

                        switch (keyon) //按键按下标题提示语显示
                        {
                        case KEY_TACKING_0:
                        case KEY_TACKING_1:
                        case KEY_TACKING_2:
                        case KEY_TACKING_3:
                        case KEY_TACKING_4:
                        case KEY_TACKING_5:
                        case KEY_TACKING_6:
                        case KEY_TACKING_7:
                        case KEY_TACKING_8:
                        case KEY_TACKING_9:
                            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
                            DrawMFU32(TITLE_XPOS_C2, SAFE_DIST4, keyon - KEY_TACKING_0, 1, rect[0].colorT[0]);
                            break;
                        default:
                            DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                            break;
                        }
                        delay = KEYFT;
                    }
                    else if (beeponf == 1) //第二次进入
                    {
                        beeponf = 2;
                        //带有长按连续功能按键的功能

                        delay = KEYNT;
                    }
                    else if (beeponf < 20)
                    {
                        beeponf++;
                    }

                    if ((keyon == KEY_TACKING_UP) || (keyon == KEY_TACKING_DOWN)) //带有长按连续功能按键的功能
                    {
                        keyoff = keyon;
                        key_on_flag1 = 1;
                    }
                    Times = 0; //当前
                }
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            if ((keyoff >= KEY_TACKING_NOTTACK) && (keyoff <= KEY_TACKING_OVERLAP))
            { // 5 -7
                tmp_bt_mode = keyoff - KEY_TACKING_NOTTACK;
                editflag = 0;
                dis_updata1 = 1;
                dis_updata2 = 1;
                dis_updata3 = 1;
            }
            else if ((keyoff >= KEY_TACKING_STRV) && (keyoff <= KEY_TACKING_STRM))
            { //12 - 15
                tmp_srt_bt = keyoff - KEY_TACKING_STRV;
                dis_updata2 = 1;
            }
            else if ((keyoff >= KEY_TACKING_ENDV) && (keyoff <= KEY_TACKING_ENDM))
            { //16 - 20
                tmp_ent_bt = keyoff - KEY_TACKING_ENDV;
                dis_updata2 = 1;
            }
            else if ((keyoff >= KEY_TACKING_OVLP1) && (keyoff <= KEY_TACKING_OVLP4))
            { //8-11
                tmp_repeat = keyoff - KEY_TACKING_OVLP1;
                dis_updata2 = 1;
            }
            else if ((keyoff >= KEY_TACKING_0) && (keyoff <= KEY_TACKING_9))
            { // 25 -34
                if (tmp_bt_mode == 2)
                {
                    tmp_r_stitch = keyoff - KEY_TACKING_0;
                    dis_updata6 = 1;
                }
                else if (tmp_bt_mode == 1)
                {
                    if (editflag == 0)
                    {
                        tmp_s_stitch = keyoff - KEY_TACKING_0;
                        dis_updata4 = 1;
                    }
                    else
                    {
                        tmp_e_stitch = keyoff - KEY_TACKING_0;
                        dis_updata5 = 1;
                    }
                }
            }
            else
            {
                switch (keyoff)
                {
                case KEY_TACKING_SCRNSVR:
                    pno = MENU_SCRNSVR;
                    break;
                case KEY_TACKING_BACK:
                    pnoindex--;
                    pno = poldno[pnoindex];
                    break;
                case KEY_TACKING_ENTER:

                    g_bt_mode = tmp_bt_mode;
                    g_repeat = tmp_repeat;
                    g_r_stitch = tmp_r_stitch;
                    g_srt_bt = tmp_srt_bt;
                    g_s_stitch = tmp_s_stitch;
                    g_ent_bt = tmp_ent_bt;
                    g_e_stitch = tmp_e_stitch;

                    if (F_FILETYPE == PAT_MIT)
                    { //三菱
                        if (plastno == MENU_MODIFYADD)
                        {

                            if ((tmp_bt_mode == 0) || ((tmp_e_stitch == 0) && (tmp_s_stitch == 0) && (tmp_r_stitch == 0)))
                            {
                            }
                            else
                            {
                                g_bt_mode = 0;
                                g_mitdotack = 0;
                                Mit_Convert_Data(1);
                                if (g_mitdotack == 1)
                                {
                                    g_savetimes--;
                                    g_Tsavetimes--;
                                }

                                g_bt_mode = tmp_bt_mode;
                            }
                            g_mitdotack = 0;
                            f = Mit_Convert_Data(1);

                            if (f == 1)
                            {
                                U32 dat1 = 0, dat2 = 0, ii = 0;
                                S16 tmpx = 0, tmpy = 0;
                                U8 dx = 0, dy = 0;

                                pnoindex -= 2;
                                pno = poldno[pnoindex];
                                if (g_mitdotack == 1)
                                {
                                    dat1 = 52000 + 1;

                                    Send_Pfoot(1, pno, 1); //压脚升

                                    if (g_jog_point > 0)
                                    {
                                        for (ii = 0; ii < g_jog_point; ii++)
                                        {
                                            dat2 = SREG[dat1 - 1] & 0x00ff;
                                            if ((dat2 == 0x61) || (dat2 == 0x41) || (dat2 == 0x21) || (dat2 == 0x1) || (dat2 == 0x1b) || (dat2 == 0x3))
                                            {
                                                dat2 = SREG[dat1];
                                                dx = (U8)(dat2);
                                                dy = (U8)((U16)(dat2 >> 8));
                                                if (dx >= 0x80)
                                                {
                                                    dx -= 0x80;
                                                    tmpx -= (S16)(dx);
                                                }
                                                else
                                                {
                                                    tmpx += (S16)(dx);
                                                }
                                                if (dy >= 0x80)
                                                {
                                                    dy -= 0x80;
                                                    tmpy -= (S16)(dy);
                                                }
                                                else
                                                {
                                                    tmpy += (S16)(dy);
                                                }
                                            }
                                            dat1 += 2;
                                        }
                                    }

                                    Comm_Move(tmpx, tmpy, 50, pno, 0, 0);
                                }
                                else
                                {
                                    poldno[pnoindex] = pno;
                                    pno = MENU_RWHELP;
                                    hleppara = 144;
                                    pnoindex++;
                                    break;
                                }

                                //									pno = MENU_INHELP;hleppara = 6;poldno[pnoindex] = MENU_TACKING;pnoindex ++;
                            }
                        }
                        else
                        {
                            pnoindex--;
                            pno = poldno[pnoindex];
                        }
                    }
                    else if (F_FILETYPE == PAT_SEW)
                    { //兄弟	tmp_repeat
                        if (plastno == MENU_MODIFYADD)
                        {
                            U16 Borcmd;
                            S16 tmpx, tmpy, dx, dy;
                            U8 speed;
                            S8 Borpooft, Borpfdis;

                            Bor_ModTack(St_point, g_s_stitch, g_e_stitch, g_r_stitch, F_FILELEN);
                            Bor_feedInfo(g_jog_point, g_patd.pat_len, &Borcmd, &tmpx, &tmpy, &dx, &dy, &speed, &Borpooft, &Borpfdis);

                            //								pno = MENU_INHELP;hleppara = 6;poldno[pnoindex] = MENU_TACKING;pnoindex ++;
                            pnoindex -= 2;
                            pno = poldno[pnoindex];

                            Send_Pfoot(1, pno, 1); //压脚升
                            Comm_Move(tmpx + dx, tmpy + dy, 50, pno, 1, 1);

                            g_modifyflag = 1;
                            g_Tsavetimes = g_savetimes;
                            g_Tsavetimes++;
                            g_savetimes = g_Tsavetimes;
                            BackupSREG(g_Tsavetimes, 0, g_patd.pat_len, 1);
                        }
                        else
                        {
                            pnoindex--;
                            pno = poldno[pnoindex];
                        }
                    }

                    break;
                case KEY_TACKING_TACKPAT:
                    pno = MENU_MOIMAGE;
                    poldno[pnoindex] = MENU_TACKING;
                    pnoindex++;
                    g_imgpara = MOIMAGE_CVIEW;
                    break;
                case KEY_TACKING_SELOVER:
                    editflag = 0;
                    dis_updata3 = 1;
                    break;
                case KEY_TACKING_SELSTRP:
                    editflag = 0;
                    dis_updata3 = 1;
                    break;
                case KEY_TACKING_SELENDP:
                    editflag = 1;
                    dis_updata3 = 1;
                    break;
                case KEY_TACKING_CLEAN:
                    if (tmp_bt_mode == 2)
                    {
                        tmp_r_stitch = 0;
                        dis_updata6 = 1;
                    }
                    else if (tmp_bt_mode == 1)
                    {
                        if (editflag == 0)
                        {
                            tmp_s_stitch = 0;
                            dis_updata4 = 1;
                        }
                        else
                        {
                            tmp_e_stitch = 0;
                            dis_updata5 = 1;
                        }
                    }
                    break;
                case KEY_TACKING_UP:
                    if (tmp_bt_mode == 2)
                    {
                        if (tmp_r_stitch < 9)
                            tmp_r_stitch++;
                        dis_updata6 = 1;
                    }
                    else if (tmp_bt_mode == 1)
                    {
                        if (editflag == 0)
                        {
                            if (tmp_s_stitch < 9)
                                tmp_s_stitch++;
                            dis_updata4 = 1;
                        }
                        else
                        {
                            if (tmp_e_stitch < 9)
                                tmp_e_stitch++;
                            dis_updata5 = 1;
                        }
                    }
                    break;
                case KEY_TACKING_DOWN:
                    if (tmp_bt_mode == 2)
                    {
                        if (tmp_r_stitch)
                            tmp_r_stitch--;
                        dis_updata6 = 1;
                    }
                    else if (tmp_bt_mode == 1)
                    {
                        if (editflag == 0)
                        {
                            if (tmp_s_stitch)
                                tmp_s_stitch--;
                            dis_updata4 = 1;
                        }
                        else
                        {
                            if (tmp_e_stitch)
                                tmp_e_stitch--;
                            dis_updata5 = 1;
                        }
                    }
                    break;
                }
            }
            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            if (keyon == KEY_TACKING_SCRNSVR) //不需要显示的按键
            {
            }
            else if (keyon == KEY_TACKING_SELENDP || keyon == KEY_TACKING_SELSTRP || keyon == KEY_TACKING_SELOVER) //非常规按键
            {
                DrawButtonOnZoomInRes(keyd[keyon]);
            }
            else //常规按键
            {
                DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);
            }

            keyon = 0;
            beeponf = 0;
            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
            Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                         SheetPage, rect[0].index[0], rect[0].colorT[0]); //显示倒针设置
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if (Timerms > 1000)
        {
            Timerms = 0;
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1)
        {
            ErrorMsg(MENU_TACKING);
        }
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*begin]**********************************************************
        if (beeponf == 0)
        {
            ErrorMsg(MENU_TACKING);
        }
        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*end]**********************************************************

        // /[更新倒缝方法按键与数字输入按键*begin]**********************************************************
        if (dis_updata1)
        {
            dis_updata1 = 0;

            BmpFillRect(rect[RECT_TACKING_TYPE].xpis, rect[RECT_TACKING_TYPE].ypis, rect[RECT_TACKING_TYPE].xsize, rect[RECT_TACKING_TYPE].ysize);

            DrawRect(rect[RECT_TACKING_TYPE].xpis, rect[RECT_TACKING_TYPE].ypis,
                     rect[RECT_TACKING_TYPE].xsize, rect[RECT_TACKING_TYPE].ysize, rect[RECT_TACKING_TYPE].colorB[0]);

            Draw24x24Str(rect[RECT_TACKING_TYPE].xpis + SAFE_DIST4, rect[RECT_TACKING_TYPE].ypis + SAFE_DIST3,
                         MEM_TITLE_ADD + rect[RECT_TACKING_TYPE].index[0] * TitleLengthMax,
                         SheetPage, rect[RECT_TACKING_TYPE].index[0], rect[RECT_TACKING_TYPE].colorT[0]); //画出方框的文字

            f = KEY_TACKING_NOTTACK + tmp_bt_mode;
            for (i = KEY_TACKING_NOTTACK; i <= KEY_TACKING_OVERLAP; i++)
            {
                if (((occlude == 0) && (i == KEY_TACKING_OVERLAP)) ||
                    ((plastno == MENU_MODIFYADD) && (F_FILETYPE == PAT_SEW) && (i == KEY_TACKING_NOTTACK)))
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[1], keybmpind[i].icon[1]);
                }
                else
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                               (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                }
            }
            if (tmp_bt_mode == 0)
            {
                BmpFillRect(keyd[KEY_TACKING_1].xpis, keyd[KEY_TACKING_1].ypis,
                            (keyd[KEY_TACKING_1].xsize + SAFE_DIST5) * 3, (keyd[KEY_TACKING_1].ysize + SAFE_DIST5) * 5);
            }
            else
            {
                for (i = KEY_TACKING_CLEAN; i <= KEY_TACKING_9; i++)
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
                }
            }
            if (tmp_bt_mode == 0 || tmp_bt_mode == 2)
                editflag = 0;
        }

        // /[更新倒缝方法按键与数字输入按键*end]**********************************************************

        // /[更新倒缝针数设定的方框*begin]**********************************************************
        if (dis_updata2)
        {
            dis_updata2 = 0;
            if (tmpbtmode != tmp_bt_mode)
            {
                tmpbtmode = tmp_bt_mode;
                BmpFillRect(rect[RECT_TACKING_OVER].xpis, rect[RECT_TACKING_OVER].ypis, rect[RECT_TACKING_OVER].xsize, rect[RECT_TACKING_OVER].ysize);
                BmpFillRect(rect[RECT_TACKING_START].xpis, rect[RECT_TACKING_START].ypis, rect[RECT_TACKING_START].xsize, rect[RECT_TACKING_START].ysize);
                BmpFillRect(rect[RECT_TACKING_END].xpis, rect[RECT_TACKING_END].ypis, rect[RECT_TACKING_END].xsize, rect[RECT_TACKING_END].ysize);
            }
            if (tmp_bt_mode == 1)
            {
                f = KEY_TACKING_STRV + tmp_srt_bt;
                for (i = KEY_TACKING_STRV; i <= KEY_TACKING_STRM; i++)
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                               (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                }

                DrawRect(rect[RECT_TACKING_START].xpis, rect[RECT_TACKING_START].ypis, rect[RECT_TACKING_START].xsize, rect[RECT_TACKING_START].ysize, rect[RECT_TACKING_START].colorB[0]);
                Draw24x24Str(rect[RECT_TACKING_START].xpis + SAFE_DIST4, rect[RECT_TACKING_START].ypis + SAFE_DIST3,
                             MEM_TITLE_ADD + rect[RECT_TACKING_START].index[0] * TitleLengthMax,
                             SheetPage, rect[RECT_TACKING_START].index[0], rect[RECT_TACKING_START].colorT[0]); //画出方框的文字

                f = KEY_TACKING_ENDV + tmp_ent_bt;
                for (i = KEY_TACKING_ENDV; i <= KEY_TACKING_ENDM; i++)
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                               (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                }
                DrawRect(rect[RECT_TACKING_END].xpis, rect[RECT_TACKING_END].ypis, rect[RECT_TACKING_END].xsize, rect[RECT_TACKING_END].ysize, rect[RECT_TACKING_END].colorB[0]);
                Draw24x24Str(rect[RECT_TACKING_END].xpis + SAFE_DIST4, rect[RECT_TACKING_END].ypis + SAFE_DIST3,
                             MEM_TITLE_ADD + rect[RECT_TACKING_END].index[0] * TitleLengthMax,
                             SheetPage, rect[RECT_TACKING_END].index[0], rect[RECT_TACKING_END].colorT[0]); //画出方框的文字
            }
            else if (tmp_bt_mode == 2)
            {
                f = KEY_TACKING_OVLP1 + tmp_repeat;
                for (i = KEY_TACKING_OVLP1; i <= KEY_TACKING_OVLP4; i++)
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                               (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                }

                DrawRect(rect[RECT_TACKING_OVER].xpis, rect[RECT_TACKING_OVER].ypis, rect[RECT_TACKING_OVER].xsize, rect[RECT_TACKING_OVER].ysize, rect[RECT_TACKING_OVER].colorB[0]);
                Draw24x24Str(rect[RECT_TACKING_OVER].xpis + SAFE_DIST4, rect[RECT_TACKING_OVER].ypis + SAFE_DIST3,
                             MEM_TITLE_ADD + rect[RECT_TACKING_OVER].index[0] * TitleLengthMax,
                             SheetPage, rect[RECT_TACKING_OVER].index[0], rect[RECT_TACKING_OVER].colorT[0]); //画出方框的文字
            }
        }

        // /[更新倒缝针数设定的方框*end]**********************************************************

        // /[更新倒缝针数设定的数据选择按钮*begin]**********************************************************
        if (dis_updata3)
        {
            dis_updata3 = 0;

            if (tmp_bt_mode)
            {
                if (tmp_bt_mode == 1)
                {
                    DrawFillRect(rect[RECT_TACKING_START_TIT].xpis, rect[RECT_TACKING_START_TIT].ypis, rect[RECT_TACKING_START_TIT].xsize, rect[RECT_TACKING_START_TIT].ysize, rect[RECT_TACKING_START_TIT].colorB[0]);
                    Draw24x24Str(rect[RECT_TACKING_START_TIT].xpis + (rect[RECT_TACKING_START_TIT].xsize - strlen((char *)(MEM_TITLE_ADD + rect[RECT_TACKING_START_TIT].index[0] * TitleLengthMax)) * 13) / 2,
                                 rect[RECT_TACKING_START_TIT].ypis + (rect[RECT_TACKING_START_TIT].ysize - 24) / 2,
                                 MEM_TITLE_ADD + rect[RECT_TACKING_START_TIT].index[0] * TitleLengthMax,
                                 SheetPage, rect[RECT_TACKING_START_TIT].index[0], rect[RECT_TACKING_START_TIT].colorT[0]); //画出方框的文字

                    DrawButtonEdit(keyd[KEY_TACKING_SELSTRP],
                                   (editflag == 0) ? keybmpind[KEY_TACKING_SELSTRP].icon[1] : keybmpind[KEY_TACKING_SELSTRP].icon[0],
                                   (editflag == 0) ? keybmpind[KEY_TACKING_SELSTRP].textColor[0] : keybmpind[KEY_TACKING_SELSTRP].icon[0]);
                    DrawF16Str(keyd[KEY_TACKING_SELSTRP].xpis + keyd[KEY_TACKING_SELSTRP].xsize + SAFE_DIST4,
                               keyd[KEY_TACKING_SELSTRP].ypis + (keyd[KEY_TACKING_SELSTRP].ysize - 16) / 2,
                               "(0-9)", keybmpind[KEY_TACKING_SELSTRP].textColor[1]);

                    dis_updata4 = 1;

                    DrawFillRect(rect[RECT_TACKING_END_TIT].xpis, rect[RECT_TACKING_END_TIT].ypis, rect[RECT_TACKING_END_TIT].xsize, rect[RECT_TACKING_END_TIT].ysize, rect[RECT_TACKING_END_TIT].colorB[0]);
                    Draw24x24Str(rect[RECT_TACKING_END_TIT].xpis + (rect[RECT_TACKING_END_TIT].xsize - strlen((char *)(MEM_TITLE_ADD + rect[RECT_TACKING_END_TIT].index[0] * TitleLengthMax)) * 13) / 2,
                                 rect[RECT_TACKING_END_TIT].ypis + (rect[RECT_TACKING_END_TIT].ysize - 24) / 2,
                                 MEM_TITLE_ADD + rect[RECT_TACKING_END_TIT].index[0] * TitleLengthMax,
                                 SheetPage, rect[RECT_TACKING_END_TIT].index[0], rect[RECT_TACKING_END_TIT].colorT[0]); //画出方框的文字

                    DrawButtonEdit(keyd[KEY_TACKING_SELENDP],
                                   (editflag == 1) ? keybmpind[KEY_TACKING_SELENDP].icon[1] : keybmpind[KEY_TACKING_SELENDP].icon[0],
                                   (editflag == 1) ? keybmpind[KEY_TACKING_SELENDP].textColor[0] : keybmpind[KEY_TACKING_SELENDP].icon[0]);
                    DrawF16Str(keyd[KEY_TACKING_SELENDP].xpis + keyd[KEY_TACKING_SELENDP].xsize + SAFE_DIST4,
                               keyd[KEY_TACKING_SELENDP].ypis + (keyd[KEY_TACKING_SELENDP].ysize - 16) / 2,
                               "(0-9)", keybmpind[KEY_TACKING_SELENDP].textColor[1]);

                    dis_updata5 = 1;
                }
                else if (tmp_bt_mode == 2)
                {
                    DrawFillRect(rect[RECT_TACKING_OVER_TIT].xpis, rect[RECT_TACKING_OVER_TIT].ypis, rect[RECT_TACKING_OVER_TIT].xsize, rect[RECT_TACKING_OVER_TIT].ysize, rect[RECT_TACKING_OVER_TIT].colorB[0]);
                    Draw24x24Str(rect[RECT_TACKING_OVER_TIT].xpis + (rect[RECT_TACKING_OVER_TIT].xsize - strlen((char *)(MEM_TITLE_ADD + rect[RECT_TACKING_OVER_TIT].index[0] * TitleLengthMax)) * 13) / 2,
                                 rect[RECT_TACKING_OVER_TIT].ypis + (rect[RECT_TACKING_OVER_TIT].ysize - 24) / 2,
                                 MEM_TITLE_ADD + rect[RECT_TACKING_OVER_TIT].index[0] * TitleLengthMax,
                                 SheetPage, rect[RECT_TACKING_OVER_TIT].index[0], rect[RECT_TACKING_OVER_TIT].colorT[0]); //画出方框的文字

                    DrawButtonEdit(keyd[KEY_TACKING_SELOVER],
                                   (editflag == 0) ? keybmpind[KEY_TACKING_SELOVER].icon[1] : keybmpind[KEY_TACKING_SELOVER].icon[0],
                                   (editflag == 0) ? keybmpind[KEY_TACKING_SELOVER].textColor[0] : keybmpind[KEY_TACKING_SELOVER].icon[0]);
                    DrawF16Str(keyd[KEY_TACKING_SELOVER].xpis + keyd[KEY_TACKING_SELOVER].xsize + SAFE_DIST4,
                               keyd[KEY_TACKING_SELOVER].ypis + (keyd[KEY_TACKING_SELOVER].ysize - 16) / 2,
                               "(0-9)", keybmpind[KEY_TACKING_SELOVER].textColor[1]);

                    dis_updata6 = 1;
                }
            }
            else
            {
                BmpFillRect(rect[RECT_TACKING_OVER_TIT].xpis, rect[RECT_TACKING_OVER_TIT].ypis, TYPE_SIZE29 - 2 * SAFE_DIST1, rect[RECT_TACKING_OVER_TIT].ysize);
                BmpFillRect(rect[RECT_TACKING_START_TIT].xpis, rect[RECT_TACKING_START_TIT].ypis, TYPE_SIZE29 - 2 * SAFE_DIST1, rect[RECT_TACKING_START_TIT].ysize);
                BmpFillRect(rect[RECT_TACKING_END_TIT].xpis, rect[RECT_TACKING_END_TIT].ypis, TYPE_SIZE29 - 2 * SAFE_DIST1, rect[RECT_TACKING_END_TIT].ysize);
            }
        }

        // /[更新倒缝针数设定的数据选择按钮*end]**********************************************************

        // /[更新起始倒缝针数*begin]**********************************************************
        if (dis_updata4)
        {
            dis_updata4 = 0;
            DrawFillRect(keyd[KEY_TACKING_SELSTRP].xpis + 1, keyd[KEY_TACKING_SELSTRP].ypis + 1,
                         keyd[KEY_TACKING_SELSTRP].xsize - 2, keyd[KEY_TACKING_SELSTRP].ysize - 2,
                         (editflag == 0) ? keybmpind[KEY_TACKING_SELSTRP].icon[1] : keybmpind[KEY_TACKING_SELSTRP].icon[0]);
            DrawMFS32P(keyd[KEY_TACKING_SELSTRP].xpis + (keyd[KEY_TACKING_SELSTRP].xsize - 13) / 2,
                       keyd[KEY_TACKING_SELSTRP].ypis + (keyd[KEY_TACKING_SELSTRP].ysize - 24) / 2,
                       tmp_s_stitch, 1, 0, keybmpind[KEY_TACKING_SELSTRP].textColor[0]);
        }

        // /[更新起始倒缝针数*end]**********************************************************

        // /[更新终止倒缝针数*begin]**********************************************************
        if (dis_updata5)
        {
            dis_updata5 = 0;
            DrawFillRect(keyd[KEY_TACKING_SELENDP].xpis + 1, keyd[KEY_TACKING_SELENDP].ypis + 1,
                         keyd[KEY_TACKING_SELENDP].xsize - 2, keyd[KEY_TACKING_SELENDP].ysize - 2,
                         (editflag == 1) ? keybmpind[KEY_TACKING_SELENDP].icon[1] : keybmpind[KEY_TACKING_SELENDP].icon[0]);
            DrawMFS32P(keyd[KEY_TACKING_SELENDP].xpis + (keyd[KEY_TACKING_SELENDP].xsize - 13) / 2,
                       keyd[KEY_TACKING_SELENDP].ypis + (keyd[KEY_TACKING_SELENDP].ysize - 24) / 2,
                       tmp_e_stitch, 1, 0, keybmpind[KEY_TACKING_SELENDP].textColor[0]);
        }
        // /[更新终止倒缝针数*end]**********************************************************

        // /[更新重叠缝针数*begin]**********************************************************
        if (dis_updata6)
        {
            dis_updata6 = 0;
            DrawFillRect(keyd[KEY_TACKING_SELOVER].xpis + 1, keyd[KEY_TACKING_SELOVER].ypis + 1,
                         keyd[KEY_TACKING_SELOVER].xsize - 2, keyd[KEY_TACKING_SELOVER].ysize - 2,
                         (editflag == 0) ? keybmpind[KEY_TACKING_SELOVER].icon[1] : keybmpind[KEY_TACKING_SELOVER].icon[0]);
            DrawMFS32P(keyd[KEY_TACKING_SELOVER].xpis + (keyd[KEY_TACKING_SELOVER].xsize - 13) / 2,
                       keyd[KEY_TACKING_SELOVER].ypis + (keyd[KEY_TACKING_SELOVER].ysize - 24) / 2,
                       tmp_r_stitch, 1, 0, keybmpind[KEY_TACKING_SELOVER].textColor[0]);
        }
        // /[更新重叠缝针数*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if (pno != MENU_TACKING)
        {
            plastno = MENU_TACKING;
            break;
        }
        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

/*******************************************************/
#define KEY_TACKING1_SCRNSVR 1   //1 屏保
#define KEY_TACKING1_BACK 2      //2 返回
#define KEY_TACKING1_ENTER 3     //3 确认
#define KEY_TACKING1_NOOVERLAP 4 //4 无重叠缝
#define KEY_TACKING1_OVERLAP 5   //5 重叠缝
#define KEY_TACKING1_OVLP1 6     //6 重叠缝样式-1
#define KEY_TACKING1_OVLP2 7     //7 重叠缝样式-2
#define KEY_TACKING1_OVLP3 8     //8 重叠缝样式-3
#define KEY_TACKING1_OVLP4 9     //9 重叠缝样式-4
#define KEY_TACKING1_SELOVER 10  //10 重叠缝针数
#define KEY_TACKING1_CLEAN 11    //11 清除1位
#define KEY_TACKING1_UP 12       //12 +1
#define KEY_TACKING1_DOWN 13     //13 -1
#define KEY_TACKING1_0 14        //14 0
#define KEY_TACKING1_1 15        //15 1
#define KEY_TACKING1_2 16        //16 2
#define KEY_TACKING1_3 17        //17 3
#define KEY_TACKING1_4 18        //18 4
#define KEY_TACKING1_5 19        //19 5
#define KEY_TACKING1_6 20        //20 6
#define KEY_TACKING1_7 21        //21 7
#define KEY_TACKING1_8 22        //22 8
#define KEY_TACKING1_9 23        //23 9

#define KEY_TACKING1_MAX 24

#define RECT_TACKING1_TYPE 1 //1 重叠缝类型
#define RECT_TACKING1_OVER 2 //2 重叠缝

#define RECT_TACKING1_OVER_TIT 3 //3 重叠缝-标题
#define RECT_TACKING1_OVER_STR 4 //4 重叠缝-内容

#define RECT_TACKING1_MAX 4

void Menu_CtTack1(void)
{
    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
                                            /****按键相关参数end****/

    /****标志位相关参数begin****/
    U8 dis_updata1 = 1; //更新重叠缝方法按键
    U8 dis_updata2 = 1; //更新重叠缝针数设定的方框
    U8 dis_updata3 = 1; //更新重叠缝针数设定的数据选择按钮
    U8 dis_updata6 = 0; //更新重叠缝针数
    U32 i;
    U8 f;
    U8 editflag = 0;
    U32 tdaar;
    U8 tmpbtmode = 0xff;
    /****标志位相关参数end***/

    const U8 keynum = {KEY_TACKING1_MAX};

    const KEYPAD keyd[] = {
        {0, 0, 0, 0},

        {0, 0, 128, 32},                     //1 屏保
        {TYPE_X1, TYPE_Y4, KEY_X1, KEY_Y1},  //2 返回
        {TYPE_X11, TYPE_Y4, KEY_X1, KEY_Y1}, //3 确认

        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 1 / 2, TYPE_Y31, KEY_X6, KEY_Y6},                                          //4 无重叠缝
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 9 / 2, TYPE_Y31, KEY_X6, KEY_Y6},                                          //5 重叠缝
        {TYPE_X14 + SAFE_DIST1, TYPE_Y32, KEY_X6, KEY_Y6},                                                           //6 重叠缝样式-1
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 5 / 3, TYPE_Y32, KEY_X6, KEY_Y6},                                          //7 重叠缝样式-2
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 10 / 3, TYPE_Y32, KEY_X6, KEY_Y6},                                         //8 重叠缝样式-3
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 15 / 3, TYPE_Y32, KEY_X6, KEY_Y6},                                         //9 重叠缝样式-4
        {TYPE_X14 + SAFE_DIST1 + TYPE_SIZE15 + SAFE_DIST5, TYPE_Y32 + KEY_Y6 + SAFE_DIST6, TYPE_SIZE14, TYPE_SIZE5}, //10 重叠缝针数

        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 4, KEY_X2, KEY_Y2},                             //11 清除1位
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},       //12 +1
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2}, //13 -1
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},                             //14 0
        {TYPE_X15, TYPE_Y13, KEY_X2, KEY_Y2},                                                         //15 1
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13, KEY_X2, KEY_Y2},                                   //16 2
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13, KEY_X2, KEY_Y2},                             //17 3
        {TYPE_X15, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},                                   //18 4
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},             //19 5
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},       //20 6
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},                             //21 7
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},       //22 8
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2}, //23 9

    };

    const tydDisSrcIndex keybmpind[] = {
        //title_counter
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},                          //1 屏保
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {72, 88}, {2, 0, 0, 0}, {0}}, //2 返回
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {71, 87}, {3, 0, 0, 0}, {0}}, //3 确认

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {457, 459, 458}, {TLFNADD_CTTACK1 + 1, 0, 0, 0}, {0}},                    //4 无重叠缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {463, 465, 464}, {TLFNADD_CTTACK1 + 2, 0, 0, 0}, {0}},                    //5 重叠缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {477, 0, 478}, {8, 0, 0, 0}, {0}},                                        //6 重叠缝样式-1
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {479, 0, 480}, {9, 0, 0, 0}, {0}},                                        //7 重叠缝样式-2
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {481, 0, 482}, {10, 0, 0, 0}, {0}},                                       //8 重叠缝样式-3
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {483, 0, 484}, {11, 0, 0, 0}, {0}},                                       //9 重叠缝样式-4
        {{KEY_Silver}, {Color_Black, Color_Black}, {Color_White, Color_DeepSkyBlue, Color_Black, 0}, {30, 0, 0, 0}, {0}}, //10 重叠缝针数

        {{KEY_Silver}, {0}, {113}, {22, 0, 0, 0}, {0}}, //11 清除1位
        {{KEY_Silver}, {0}, {199}, {23, 0, 0, 0}, {0}}, //12 +1
        {{KEY_Silver}, {0}, {201}, {24, 0, 0, 0}, {0}}, //13 -1
        {{KEY_Silver}, {0}, {91}, {0, 0, 0, 0}, {0}},   //14 0
        {{KEY_Silver}, {0}, {92}, {0, 0, 0, 0}, {0}},   //15 1
        {{KEY_Silver}, {0}, {93}, {0, 0, 0, 0}, {0}},   //16 2
        {{KEY_Silver}, {0}, {94}, {0, 0, 0, 0}, {0}},   //17 3
        {{KEY_Silver}, {0}, {95}, {0, 0, 0, 0}, {0}},   //18 4
        {{KEY_Silver}, {0}, {96}, {0, 0, 0, 0}, {0}},   //19 5
        {{KEY_Silver}, {0}, {97}, {0, 0, 0, 0}, {0}},   //20 6
        {{KEY_Silver}, {0}, {98}, {0, 0, 0, 0}, {0}},   //21 7
        {{KEY_Silver}, {0}, {99}, {0, 0, 0, 0}, {0}},   //22 8
        {{KEY_Silver}, {0}, {100}, {0, 0, 0, 0}, {0}},  //23 9

    };

    const RECTPAD rect[] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {TLFNADD_CTTACK1}},
        {TYPE_X14, TYPE_Y3, TYPE_SIZE29, TYPE_SIZE28, {Color_Black}, {Color_Black, Color_White}, {TLFNADD_CTTACK1 + 3}},                    //1 重叠缝类型
        {TYPE_X14, TYPE_Y3 + TYPE_SIZE28 + SAFE_DIST6, TYPE_SIZE29, 139, {Color_Black}, {Color_Black, Color_White}, {TLFNADD_CTTACK + 26}}, //2 重叠缝

        {TYPE_X14 + SAFE_DIST1, TYPE_Y3 + TYPE_SIZE28 + SAFE_DIST6 + 139 - SAFE_DIST1 - TYPE_SIZE5, TYPE_SIZE15, TYPE_SIZE5, {Color_KeyBlue}, {Color_White}, {TLFNADD_CTTACK + 30}}, //5 重叠缝-标题

    };

    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_TACKING); //设置当前文字显示雷人在P1页面，对应41.bin
    InitScreen();
    initViewStatus();
    updateViewStatus();

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    tmp_bt_mode = 1; //默认重叠缝
    tmp_repeat = g_repeat;
    tmp_r_stitch = g_r_stitch;

    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                 SheetPage, rect[0].index[0], rect[0].colorT[0]); //倒针参数

    //画出方框显示
    // for (i = 1; i < RECT_TACKING1_MAX; i++)
    // {

    //     if (i == RECT_TACKING1_TYPE)
    //     {
    //         DrawRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);

    //         Draw24x24Str(rect[i].xpis + SAFE_DIST4, rect[i].ypis + SAFE_DIST3,
    //                      MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
    //                      SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
    //     }
    //     // else if (i == RECT_TACKING1_END_TIT || i == RECT_TACKING1_START_TIT)
    //     // {
    //     //     DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
    //     //     Draw24x24Str(rect[i].xpis + (rect[i].xsize - 24 * 2) / 2, rect[i].ypis + (rect[i].ysize - 24) / 2,
    //     //                  MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
    //     //                  SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
    //     // }
    // }
    //画出按键显示
    for (i = 2; i < KEY_TACKING1_MAX; i++)
    {
        if (i >= KEY_TACKING1_BACK && i <= KEY_TACKING1_ENTER)
        {
            DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
        }
    }

    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************
    ViewPage(usepageno); //设置显示缓存

    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    Timer_ms = 30720; //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        keydata = get_keydata((KEYPAD *)keyd, keynum, 0); //获取键值

        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理
        //无效按键

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            if ((keyon == KEY_TACKING1_UP) || (keyon == KEY_TACKING1_DOWN))
            {
            }
            else if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {
            //特定情况下不生效按键
            if ((tmp_bt_mode == 0) && (keydata > KEY_TACKING1_OVERLAP))
            {
                keydata = 0;
            }
            else
            {
                if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时
                {
                    keyon = keydata;
                    if (keyon == KEY_TACKING1_SCRNSVR) //无按键特效
                    {
                    }
                    else if (keyon == KEY_TACKING1_SELOVER) //非常规按键
                    {
                        DrawButtonOnZoomIn(keyd[keyon], 2);
                    }
                    else
                    {
                        DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);
                    }
                    Times = 0;
                    delay = KEYDT; //按键防抖次数
                }
                else if (keyon != keydata) //已有按键按下，不处理新按键信息
                {
                    keydata = 0;
                }

                if (Times > delay) //按键防抖
                {
                    if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                    {
                        beeponf = 1;

                        if (g_keyBellT) //按键时蜂鸣器发声时间
                            Beep_On(g_keyBellT);

                        switch (keyon) //按键按下标题提示语显示
                        {
                        case KEY_TACKING1_0:
                        case KEY_TACKING1_1:
                        case KEY_TACKING1_2:
                        case KEY_TACKING1_3:
                        case KEY_TACKING1_4:
                        case KEY_TACKING1_5:
                        case KEY_TACKING1_6:
                        case KEY_TACKING1_7:
                        case KEY_TACKING1_8:
                        case KEY_TACKING1_9:
                            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
                            DrawMFU32(TITLE_XPOS_C2, SAFE_DIST4, keyon - KEY_TACKING1_0, 1, rect[0].colorT[0]);
                            break;
                        default:
                            DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                            break;
                        }
                        delay = KEYFT;
                    }
                    else if (beeponf == 1) //第二次进入
                    {
                        beeponf = 2;
                        //带有长按连续功能按键的功能

                        delay = KEYNT;
                    }
                    else if (beeponf < 20)
                    {
                        beeponf++;
                    }

                    if ((keyon == KEY_TACKING1_UP) || (keyon == KEY_TACKING1_DOWN)) //带有长按连续功能按键的功能
                    {
                        keyoff = keyon;
                        key_on_flag1 = 1;
                    }
                    Times = 0; //当前
                }
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            if ((keyoff >= KEY_TACKING1_NOOVERLAP) && (keyoff <= KEY_TACKING1_OVERLAP))
            { // 5 -7
                tmp_bt_mode = keyoff - KEY_TACKING1_NOOVERLAP;
                dis_updata1 = 1;
                dis_updata2 = 1;
                dis_updata3 = 1;
            }
            else if ((keyoff >= KEY_TACKING1_OVLP1) && (keyoff <= KEY_TACKING1_OVLP4))
            { //8-11
                tmp_repeat = keyoff - KEY_TACKING1_OVLP1;
                dis_updata2 = 1;
            }
            else if ((keyoff >= KEY_TACKING1_0) && (keyoff <= KEY_TACKING1_9))
            { // 25 -34
                tmp_r_stitch = keyoff - KEY_TACKING1_0;
                dis_updata6 = 1;
            }
            else
            {
                switch (keyoff)
                {
                case KEY_TACKING1_SCRNSVR:
                    pno = MENU_SCRNSVR;
                    break;
                case KEY_TACKING1_BACK:
                    pnoindex--;
                    pno = poldno[pnoindex];
                    break;
                case KEY_TACKING1_ENTER:
                    pnoindex -= 2;
                    pno = poldno[pnoindex];
                    //g_bt_mode = tmp_bt_mode==0?tmp_bt_mode:2;
                    //g_repeat = tmp_repeat;
                    if (tmp_bt_mode == 0)
                        break;

                    g_autoOvlp.evepins = tmp_r_stitch;
                    g_autoOvlp.retimes = tmp_repeat + 1;
                    if (g_autoOvlp.retimes > 4)
                        g_autoOvlp.retimes = 4;
                    if (g_autoOvlp.evepins > 9)
                        g_autoOvlp.evepins = 9;
                    if (g_autoOvlp.retimes != 0 && g_autoOvlp.evepins != 0)
                    {
                        if (g_GreatPatType == 1)
                        {
                            f = mit_ctOverlap();
                            if (f)
                            {
                                g_feedsum = g_patd.feed_sum;
                                g_feedc = g_patd.feed_sum;
                                g_disxpos = g_oxpos;
                                g_disypos = g_oypos;
                                Comm_Move(g_oxpos, g_oypos, 80, MENU_CURSOR, 0, 0);
                            }
                            else
                            {
                                pno = MENU_RWHELP;
                                hleppara = 181;
                                poldno[pnoindex++] = MENU_CURSOR;
                            }
                        }
                        else if (g_GreatPatType == 2)
                        {
                            tdaar = g_Ctendaddr;
                            f = sew_ctOverlap((U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen);
                            //printf("sew_ctOverlap f = %d tdaar = %d g_Ctendaddr = %d\r\n",f,tdaar,g_Ctendaddr);
                            if (f == 1)
                            { //成功  则备份本次花样数据
                                g_Ctstaddr = tdaar;
                                Bor_CreatBack((U16 *)&g_Ctsavetimes, g_Ctstaddr, g_Ctendaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);

                                g_feedsum = g_patd.feed_sum;
                                g_feedc = g_patd.feed_sum;
                                g_disxpos = g_oxpos;
                                g_disypos = g_oypos;
                                Comm_Move(g_oxpos, g_oypos, 80, MENU_CURSOR, 1, 1);
                            }
                            else
                            {
                                pno = MENU_RWHELP;
                                hleppara = 181;
                                poldno[pnoindex++] = MENU_CURSOR;
                            }
                        }
                    }

                    break;
                case KEY_TACKING1_SELOVER:
                    editflag = 0;
                    dis_updata3 = 1;
                    break;
                case KEY_TACKING1_CLEAN:
                    if (tmp_bt_mode == 1)
                    {
                        tmp_r_stitch = 0;
                        dis_updata6 = 1;
                    }
                    break;
                case KEY_TACKING1_UP:
                    if (tmp_bt_mode == 1)
                    {
                        if (tmp_r_stitch < 9)
                            tmp_r_stitch++;
                        dis_updata6 = 1;
                    }
                    break;
                case KEY_TACKING1_DOWN:
                    if (tmp_bt_mode == 1)
                    {
                        if (tmp_r_stitch)
                            tmp_r_stitch--;
                        dis_updata6 = 1;
                    }
                    break;
                }
            }
            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            if (keyon == KEY_TACKING1_SCRNSVR) //不需要显示的按键
            {
            }
            else if (keyon == KEY_TACKING1_SELOVER) //非常规按键
            {
                DrawButtonOnZoomInRes(keyd[keyon]);
            }
            else //常规按键
            {
                DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);
            }

            keyon = 0;
            beeponf = 0;
            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
            Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                         SheetPage, rect[0].index[0], rect[0].colorT[0]); //显示倒针设置
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if (Timerms > 1000)
        {
            Timerms = 0;
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1)
        {
            ErrorMsg(MENU_TACKING1);
        }
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*begin]**********************************************************
        if (beeponf == 0)
        {
            ErrorMsg(MENU_TACKING1);
        }
        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*end]**********************************************************

        // /[更新重叠缝方法按键与数字输入按键*begin]**********************************************************
        if (dis_updata1)
        {
            dis_updata1 = 0;

            BmpFillRect(rect[RECT_TACKING1_TYPE].xpis, rect[RECT_TACKING1_TYPE].ypis, rect[RECT_TACKING1_TYPE].xsize, rect[RECT_TACKING1_TYPE].ysize);

            DrawRect(rect[RECT_TACKING1_TYPE].xpis, rect[RECT_TACKING1_TYPE].ypis,
                     rect[RECT_TACKING1_TYPE].xsize, rect[RECT_TACKING1_TYPE].ysize, rect[RECT_TACKING1_TYPE].colorB[0]);

            Draw24x24Str(rect[RECT_TACKING1_TYPE].xpis + SAFE_DIST4, rect[RECT_TACKING1_TYPE].ypis + SAFE_DIST3,
                         MEM_TITLE_ADD + rect[RECT_TACKING1_TYPE].index[0] * TitleLengthMax,
                         SheetPage, rect[RECT_TACKING1_TYPE].index[0], rect[RECT_TACKING1_TYPE].colorT[0]); //画出方框的文字

            f = KEY_TACKING1_NOOVERLAP + tmp_bt_mode;
            for (i = KEY_TACKING1_NOOVERLAP; i <= KEY_TACKING1_OVERLAP; i++)
            {
                DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                           (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                           (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
            }
            if (tmp_bt_mode == 0)
            {
                BmpFillRect(keyd[KEY_TACKING1_1].xpis, keyd[KEY_TACKING1_1].ypis,
                            (keyd[KEY_TACKING1_1].xsize + SAFE_DIST5) * 3, (keyd[KEY_TACKING1_1].ysize + SAFE_DIST5) * 5);
            }
            else
            {
                for (i = KEY_TACKING1_CLEAN; i <= KEY_TACKING1_9; i++)
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
                }
            }
            if (tmp_bt_mode == 0 || tmp_bt_mode == 1)
                editflag = 0;
        }
        // /[更新重叠缝方法按键与数字输入按键*end]**********************************************************

        // /[更新重叠缝针数设定的方框*begin]**********************************************************
        if (dis_updata2)
        {
            dis_updata2 = 0;
            if (tmpbtmode != tmp_bt_mode)
            {
                tmpbtmode = tmp_bt_mode;
                BmpFillRect(rect[RECT_TACKING1_OVER].xpis, rect[RECT_TACKING1_OVER].ypis, rect[RECT_TACKING1_OVER].xsize, rect[RECT_TACKING1_OVER].ysize);
            }
            if (tmp_bt_mode == 1)
            {
                f = KEY_TACKING1_OVLP1 + tmp_repeat;
                for (i = KEY_TACKING1_OVLP1; i <= KEY_TACKING1_OVLP4; i++)
                {
                    DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                               (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                               (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                }

                DrawRect(rect[RECT_TACKING1_OVER].xpis, rect[RECT_TACKING1_OVER].ypis, rect[RECT_TACKING1_OVER].xsize, rect[RECT_TACKING1_OVER].ysize, rect[RECT_TACKING1_OVER].colorB[0]);
                Draw24x24Str(rect[RECT_TACKING1_OVER].xpis + SAFE_DIST4, rect[RECT_TACKING1_OVER].ypis + SAFE_DIST3,
                             MEM_TITLE_ADD + rect[RECT_TACKING1_OVER].index[0] * TitleLengthMax,
                             SheetPage, rect[RECT_TACKING1_OVER].index[0], rect[RECT_TACKING1_OVER].colorT[0]); //画出方框的文字
            }
        }

        // /[更新重叠缝针数设定的方框*end]**********************************************************

        // /[更新重叠缝针数设定的数据选择按钮*begin]**********************************************************
        if (dis_updata3)
        {
            dis_updata3 = 0;

            if (tmp_bt_mode)
            {
                if (tmp_bt_mode == 1)
                {
                    DrawFillRect(rect[RECT_TACKING1_OVER_TIT].xpis, rect[RECT_TACKING1_OVER_TIT].ypis, rect[RECT_TACKING1_OVER_TIT].xsize, rect[RECT_TACKING1_OVER_TIT].ysize, rect[RECT_TACKING1_OVER_TIT].colorB[0]);
                    Draw24x24Str(rect[RECT_TACKING1_OVER_TIT].xpis + (rect[RECT_TACKING1_OVER_TIT].xsize - strlen((char *)(MEM_TITLE_ADD + rect[RECT_TACKING1_OVER_TIT].index[0] * TitleLengthMax)) * 13) / 2,
                                 rect[RECT_TACKING1_OVER_TIT].ypis + (rect[RECT_TACKING1_OVER_TIT].ysize - 24) / 2,
                                 MEM_TITLE_ADD + rect[RECT_TACKING1_OVER_TIT].index[0] * TitleLengthMax,
                                 SheetPage, rect[RECT_TACKING1_OVER_TIT].index[0], rect[RECT_TACKING1_OVER_TIT].colorT[0]); //画出方框的文字

                    DrawButtonEdit(keyd[KEY_TACKING1_SELOVER],
                                   (editflag == 0) ? keybmpind[KEY_TACKING1_SELOVER].icon[1] : keybmpind[KEY_TACKING1_SELOVER].icon[0],
                                   (editflag == 0) ? keybmpind[KEY_TACKING1_SELOVER].textColor[0] : keybmpind[KEY_TACKING1_SELOVER].icon[0]);
                    DrawF16Str(keyd[KEY_TACKING1_SELOVER].xpis + keyd[KEY_TACKING1_SELOVER].xsize + SAFE_DIST4,
                               keyd[KEY_TACKING1_SELOVER].ypis + (keyd[KEY_TACKING1_SELOVER].ysize - 16) / 2,
                               "(0-9)", keybmpind[KEY_TACKING1_SELOVER].textColor[1]);

                    dis_updata6 = 1;
                }
            }
            else
            {
                BmpFillRect(rect[RECT_TACKING1_OVER_TIT].xpis, rect[RECT_TACKING1_OVER_TIT].ypis, TYPE_SIZE29 - 2 * SAFE_DIST1, rect[RECT_TACKING1_OVER_TIT].ysize);
            }
        }

        // /[更新重叠缝针数设定的数据选择按钮*end]**********************************************************

        // /[更新重叠缝针数*begin]**********************************************************
        if (dis_updata6)
        {
            dis_updata6 = 0;
            DrawFillRect(keyd[KEY_TACKING1_SELOVER].xpis + 1, keyd[KEY_TACKING1_SELOVER].ypis + 1,
                         keyd[KEY_TACKING1_SELOVER].xsize - 2, keyd[KEY_TACKING1_SELOVER].ysize - 2,
                         (editflag == 0) ? keybmpind[KEY_TACKING1_SELOVER].icon[1] : keybmpind[KEY_TACKING1_SELOVER].icon[0]);
            DrawMFS32P(keyd[KEY_TACKING1_SELOVER].xpis + (keyd[KEY_TACKING1_SELOVER].xsize - 13) / 2,
                       keyd[KEY_TACKING1_SELOVER].ypis + (keyd[KEY_TACKING1_SELOVER].ysize - 24) / 2,
                       tmp_r_stitch, 1, 0, keybmpind[KEY_TACKING1_SELOVER].textColor[0]);
        }
        // /[更新重叠缝针数*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if (pno != MENU_TACKING1)
        {
            plastno = MENU_TACKING1;
            break;
        }
        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

/*****************************************************/

#define KEY_CODE_SCRNSVR 1 //1 屏保
#define KEY_CODE_BACK 2    //2 返回
#define KEY_CODE_ENTER 3   //3 确认
#define KEY_CODE_FUNC1 4   //4 功能-1
#define KEY_CODE_FUNC2 5   //5 功能-2
#define KEY_CODE_FUNC3 6   //6 功能-3
#define KEY_CODE_FUNC4 7   //7 功能-4
#define KEY_CODE_FUNC5 8   //8 功能-5
#define KEY_CODE_FUNC6 9   //9 功能-6
#define KEY_CODE_FUNC7 10  //10 功能-7
#define KEY_CODE_FUNC8 11  //11 功能-8
#define KEY_CODE_USTP 12   //12 上停针
#define KEY_CODE_DSTP 13   //13 下停针
#define KEY_CODE_TRIM 14   //14 剪线
#define KEY_CODE_BAT 15    //15 跳缝
#define KEY_CODE_2HP 16    //16 次原点
#define KEY_CODE_EXT1 17   //17 延伸-1
#define KEY_CODE_EXT2 18   //18 延伸-2
#define KEY_CODE_RECIV 19  //19 输入阵列
#define KEY_CODE_TACK 20   //20 追加重叠缝

#define KEY_CODE_MAX 21

#define RECT_CODE_MAX 1
void Menu_CtCode(void)
{
    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
                                            /****按键相关参数end****/

    /****标志位相关参数begin****/
    U32 i;
    U8 f;
    U8 dis_updata = 1;
    U8 tmp_code_mode, excode = 0;
    U32 tmpCreatStaddr = 0;
    U8 enExt2 = 1; //使能延伸2
    U8 enRecv = 0; //阵列使能
    //U8 chpins = 0;
    U32 addr1 = 0;
    /****标志位相关参数end***/

    const U8 keynum = {KEY_CODE_MAX};

    const KEYPAD keyd[] = {
        {0, 0, 0, 0},

        {0, 0, 128, 32},                     //1 屏保
        {TYPE_X1, TYPE_Y4, KEY_X1, KEY_Y1},  //2 返回
        {TYPE_X11, TYPE_Y4, KEY_X1, KEY_Y1}, //3 确认

        {114, TYPE_Y3 + (KEY_Y8 + SAFE_DIST8) * 2, KEY_X8, KEY_Y8},                             //4 功能-1
        {114 + (KEY_X8 + SAFE_DIST8), TYPE_Y3 + (KEY_Y8 + SAFE_DIST8) * 2, KEY_X8, KEY_Y8},     //5 功能-2
        {114 + (KEY_X8 + SAFE_DIST8) * 2, TYPE_Y3 + (KEY_Y8 + SAFE_DIST8) * 2, KEY_X8, KEY_Y8}, //6 功能-3
        {114 + (KEY_X8 + SAFE_DIST8) * 3, TYPE_Y3 + (KEY_Y8 + SAFE_DIST8) * 2, KEY_X8, KEY_Y8}, //7 功能-4

        {114, TYPE_Y3 + (KEY_Y8 + SAFE_DIST8) * 3, KEY_X8, KEY_Y8},                             //8 功能-5
        {114 + (KEY_X8 + SAFE_DIST8), TYPE_Y3 + (KEY_Y8 + SAFE_DIST8) * 3, KEY_X8, KEY_Y8},     //9 功能-6
        {114 + (KEY_X8 + SAFE_DIST8) * 2, TYPE_Y3 + (KEY_Y8 + SAFE_DIST8) * 3, KEY_X8, KEY_Y8}, //10 功能-7
        {114 + (KEY_X8 + SAFE_DIST8) * 3, TYPE_Y3 + (KEY_Y8 + SAFE_DIST8) * 3, KEY_X8, KEY_Y8}, //11 功能-8

        {114, TYPE_Y3, KEY_X8, KEY_Y8},                             //12 上停针
        {114 + (KEY_X8 + SAFE_DIST8), TYPE_Y3, KEY_X8, KEY_Y8},     //13 下停针
        {114 + (KEY_X8 + SAFE_DIST8) * 2, TYPE_Y3, KEY_X8, KEY_Y8}, //14 剪线
        {114 + (KEY_X8 + SAFE_DIST8) * 3, TYPE_Y3, KEY_X8, KEY_Y8}, //15 跳缝
        {114, TYPE_Y3 + KEY_Y8 + SAFE_DIST8, KEY_X8, KEY_Y8},       //16 次原点

        {114, TYPE_Y3 + (KEY_Y8 + SAFE_DIST8) * 4, KEY_X8, KEY_Y8},                         //17 延伸-1
        {114 + (KEY_X8 + SAFE_DIST8), TYPE_Y3 + (KEY_Y8 + SAFE_DIST8) * 4, KEY_X8, KEY_Y8}, //18 延伸-2

        {TYPE_X12 + KEY_X1 / 2 + SAFE_DIST1, TYPE_Y4, KEY_X1, KEY_Y1}, //19 输入阵列
        {TYPE_X12 - KEY_X1 / 2, TYPE_Y4, KEY_X1, KEY_Y1},              //20 追加重叠缝

    };

    const tydDisSrcIndex keybmpind[] = {
        //title_counter
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},                          //1 屏保
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {72, 88}, {2, 0, 0, 0}, {0}}, //2 返回
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {71, 87}, {3, 0, 0, 0}, {0}}, //3 确认

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {4, 0, 0, 0}, {18}}, //4 功能-1
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {5, 0, 0, 0}, {19}}, //5 功能-2
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {6, 0, 0, 0}, {20}}, //6 功能-3
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {7, 0, 0, 0}, {21}}, //7 功能-4

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {8, 0, 0, 0}, {22}},  //8 功能-5
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {9, 0, 0, 0}, {23}},  //9 功能-6
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {10, 0, 0, 0}, {24}}, //10 功能-7
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {11, 0, 0, 0}, {25}}, //11 功能-8

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {12, 0, 0, 0}, {26}}, //12 上停针
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {13, 0, 0, 0}, {27}}, //13 下停针
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {14, 0, 0, 0}, {28}}, //14 剪线
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {15, 0, 0, 0}, {29}}, //15 跳缝
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {16, 0, 0, 0}, {30}}, //16 次原点

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {17, 0, 0, 0}, {31}}, //17 延伸-1
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {17, 0, 0, 0}, {0}},  //18 延伸-2

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {485}, {63, 0, 0, 0}, {0}},           //19 输入阵列
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {463, 465, 464}, {69, 0, 0, 0}, {0}}, //20 追加重叠缝

    };

    const RECTPAD rect[] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {0}},

    };

    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_CODE); //设置当前文字显示雷人在P1页面，对应41.bin
    InitScreen();
    initViewStatus();
    updateViewStatus();

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    if ((g_UdZhouFlag != 1) && (g_UdZhouFlag != 2))
    { //不显示延伸2
        enExt2 = 0;
    }
    if (g_readcovnflag1 && F_FILETYPE == PAT_SEW)
    {
        enRecv = 1;
    }
    if (enRecv)
        DrawButton2(keyd[KEY_CODE_RECIV], keybmpind[KEY_CODE_RECIV].border[0], keybmpind[KEY_CODE_RECIV].icon[0], 1);
    if (g_enctTackCode)
        DrawButton2(keyd[KEY_CODE_TACK], keybmpind[KEY_CODE_TACK].border[0], keybmpind[KEY_CODE_TACK].icon[0], 1);

    if ((plastno != MENU_SCRNSVR) && (plastno != MENU_EXCODE) &&
        (plastno != MENU_RWHELP) && (plastno != MENU_MODIFY3))
    {
        g_publicbuf[33] = plastno;
    }
    else
    {
        plastno = g_publicbuf[33];
    }

    g_BorAddFuns = 0; //默认不插入附加功能
    g_code_mode = 9;
    tmp_code_mode = g_code_mode;

    if (F_FILETYPE == PAT_SEW)
    {
        if ((g_patd.orgX != 0) || (g_patd.orgY != 0))
        { //有次原点
            g_home_2flag = 1;
        }
        else
        {
            g_home_2flag = 0;
        }
    }

    if ((poldno[pnoindex - 1] == MENU_CURSOR) && (g_home_2flag == 0))
    { //打板画面进来，并且无次原点，默认选择插入次原点
        g_code_mode = 13;
        tmp_code_mode = g_code_mode;
    }
    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                 SheetPage, rect[0].index[0], rect[0].colorT[0]); //倒针参数

    //画出方框显示

    //画出按键显示
    for (i = 2; i < KEY_CODE_MAX; i++)
    {
        if (i >= KEY_CODE_BACK && i <= KEY_CODE_ENTER)
        {
            DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
        }
    }

    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************
    ViewPage(usepageno); //设置显示缓存

    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    Timer_ms = 30720; //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        keydata = get_keydata((KEYPAD *)keyd, keynum, 0); //获取键值

        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理
        //无效按键

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {
            //特定情况下不生效按键
            if (keydata == KEY_CODE_EXT2 && enExt2 == 0)
            {
                keydata = 0;
            }
            else if (keydata == KEY_CODE_RECIV && enRecv == 0)
            {
                keydata = 0;
            }
            else if (keydata == KEY_CODE_TACK && g_enctTackCode == 0)
            {
                keydata = 0;
            }
            else
            {
                if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时
                {
                    keyon = keydata;
                    if (keyon == KEY_CODE_SCRNSVR) //无按键特效
                    {
                    }
                    else
                    {
                        DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);
                    }
                    Times = 0;
                    delay = KEYDT; //按键防抖次数
                }
                else if (keyon != keydata) //已有按键按下，不处理新按键信息
                {
                    keydata = 0;
                }

                if (Times > delay) //按键防抖
                {
                    if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                    {
                        beeponf = 1;

                        if (g_keyBellT) //按键时蜂鸣器发声时间
                            Beep_On(g_keyBellT);

                        switch (keyon) //按键按下标题提示语显示
                        {
                        default:
                            DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                            break;
                        }
                        delay = KEYFT;
                    }
                    else if (beeponf == 1) //第二次进入
                    {
                        beeponf = 2;
                        //带有长按连续功能按键的功能

                        delay = KEYNT;
                    }
                    else if (beeponf < 20)
                    {
                        beeponf++;
                    }
                    Times = 0; //当前
                }
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            if ((keyoff >= KEY_CODE_FUNC1) && (keyoff <= KEY_CODE_EXT2))
            {
                tmp_code_mode = keyoff - KEY_CODE_FUNC1 + 1;
                if ((tmp_code_mode < 1) || (tmp_code_mode > 8)) //不为功能1-8
                {
                    g_BorAddFuns = 0;
                }
                else
                {
                    g_BorAddFuns |= (1 << (tmp_code_mode - 1));
                }
                dis_updata = 1;
            }
            else
            {
                switch (keyoff)
                {
                case KEY_CODE_SCRNSVR:
                    pno = MENU_SCRNSVR;
                    break;
                case KEY_CODE_BACK:
                    pnoindex--;
                    pno = poldno[pnoindex];
                    break;
                case KEY_CODE_ENTER:
                    if (F_FILETYPE == PAT_MIT)
                    { //三菱
                        g_code_mode = tmp_code_mode;
                        if (g_code_mode == 14)
                        {
                            pno = MENU_EXCODE;
                            poldno[pnoindex] = MENU_CODE;
                            pnoindex++;
                        }
                        else if (g_code_mode == 15)
                        {
                            pno = MENU_EXCODE1;
                            poldno[pnoindex] = MENU_CODE;
                            pnoindex++;
                        }
                        else if ((poldno[pnoindex - 1] == MENU_MODIFYADD) || (g_publicbuf[33] == MENU_MODIFYADD))
                        {
                            pno = MENU_MODIFY3;
                            poldno[pnoindex] = MENU_CODE;
                            pnoindex++;
                        }
                        else if ((poldno[pnoindex - 1] == MENU_CURSOR) || (g_publicbuf[33] == MENU_CURSOR))
                        {
                            pnoindex--;
                            pno = poldno[pnoindex]; //MENU_CURSOR;//
                            if (g_code_mode == 11)
                            {                   // 剪线
                                g_feed_sew = 0; // 空送标志
                            }
                            else if (g_code_mode == 12)
                            { // 跳缝
                                g_feed_sew = 0;
                                g_feed_flag = 0;
                                g_ct_status_flag = 0;
                                g_ct_status_flag |= (bit1 | bit4 | bit7 | bit9 | bit10);
                            }
                            else if (g_code_mode == 13)
                            { // 次原点
                                if (g_home_2flag)
                                {
                                    EREG[1] = 160;
                                    pno = MENU_RWHELP;
                                    hleppara = 22;
                                    pnoindex++;
                                    poldno[pnoindex] = MENU_CODE;
                                    pnoindex++;
                                    break;
                                }
                                else if (SREG[g_draw_p - 4] != 0x88)
                                {
                                    EREG[1] = 144;
                                    pno = MENU_RWHELP;
                                    hleppara = 22;
                                    pnoindex++;
                                    poldno[pnoindex] = MENU_CODE;
                                    pnoindex++;
                                    break;
                                }
                                else
                                {
                                    g_home_2flag = 1;
                                    g_home_2xpos = g_oxpos;
                                    g_home_2ypos = g_oypos;
                                }
                            }

                            if ((g_code_mode >= 1) && (g_code_mode <= 8))
                            { //功能一到八
                                excode = 0x01 << (g_code_mode - 1);
                                OutputExcode(g_BorAddFuns, excode);
                            }

                            //#if Debug
                            //printf("g_code_mode = %d excode = %02x  g_feed_sew = %d  g_DoTrim = %d\r\n",g_code_mode,excode,g_feed_sew,g_DoTrim);
                            //#endif
                            if ((g_UdZhouFlag == 3) && (g_code_mode == 8))
                            { //换针钱需要剪线
                                if (g_feed_sew)
                                { //添加剪线
                                    SREG[g_draw_p++] = draw_code[11][0];
                                    SREG[g_draw_p++] = draw_code[11][1];
                                    SREG[g_draw_p++] = 0;
                                    SREG[g_draw_p++] = 0;
                                    SREG[g_line_p++] = g_line_sum++;
                                    SREG[g_pat_p++] = pat_code[11];
                                    SREG[g_pat_p++] = 0;
                                    g_feed_sew = 0;
                                }
                            }

                            SREG[g_draw_p++] = draw_code[g_code_mode][0];
                            SREG[g_draw_p++] = draw_code[g_code_mode][1];
                            SREG[g_draw_p++] = 0;
                            SREG[g_draw_p++] = 0;
                            SREG[g_line_p++] = g_line_sum++;
                            SREG[g_pat_p++] = pat_code[g_code_mode];
                            SREG[g_pat_p++] = 0;

                            g_feedc = g_line_p - (SREG[2] + 0x40) / 2; //当前已打版出的针数
                            g_feedsum = g_feedc;
                            g_modifyflag |= 0x01;
                        }
                        else
                        {
                            pnoindex--;
                            pno = poldno[pnoindex];
                        }
                    }
                    else if (F_FILETYPE == PAT_SEW)
                    { //兄弟
                        //#if Debug
                        //printf("tmp_code_mode = %d \r\n",tmp_code_mode);
                        //#endif
                        g_code_mode = tmp_code_mode;
                        if (g_code_mode == 14)
                        {
                            pno = MENU_EXCODE;
                            poldno[pnoindex] = MENU_CODE;
                            pnoindex++;
                        }
                        else if (g_code_mode == 15)
                        {
                            pno = MENU_EXCODE1;
                            poldno[pnoindex] = MENU_CODE;
                            pnoindex++;
                        }
                        else if ((poldno[pnoindex - 1] == MENU_MODIFYADD) || (g_publicbuf[33] == MENU_MODIFYADD))
                        { //修改功能 插入删除附加功能
                            pno = MENU_MODIFY3;
                            poldno[pnoindex] = MENU_CODE;
                            pnoindex++;
                            g_code_mode += 8;
                            //#if Debug
                            //printf("code_mode = %d \r\n",g_code_mode);
                            //#endif
                        }
                        else if (poldno[pnoindex - 1] == MENU_CURSOR)
                        { //打板添加附加功能
                            tmpCreatStaddr = g_Ctendaddr;
                            addr1 = g_Ctendaddr;
                            //#if Debug
                            //printf("g_code_mode = %d g_BorAddFuns = %02x\r\n",g_code_mode,g_BorAddFuns);
                            //#endif
                            if ((g_pf_dis != 0) && g_pf_mode)
                            { //跳缝前插入中压脚指令
                                if (g_code_mode == 13)
                                {
                                    pno = MENU_RWHELP;
                                    hleppara = 66;
                                    break;
                                }
                                Bor_doPF((U16 *)SREG, (U32 *)&addr1, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, g_pf_absval - g_pfootd.base, &g_patd.feed_sum);
                                g_updata_pf_valflg = 1;
                                g_pf_mode = 0;
                                tmpCreatStaddr = g_Ctendaddr;
                            }
                            f = Bor_doCode((U16 *)SREG, (U32 *)&tmpCreatStaddr, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, g_code_mode, g_BorAddFuns);

                            if (g_code_mode >= 1 && g_code_mode <= 8)
                            { //附加功能
                                if (g_BorAddFuns != 0)
                                {
                                    OutputExcode(g_BorAddFuns, MENU_CODE);
                                }
                            }
                            g_ct_status_flag = 0;
                            if (g_code_mode == 12)
                            { //跳缝，之后默认为空送
                                g_feed_flag = 0;
                                g_ct_status_flag |= (bit1 | bit4 | bit6 | bit7 | bit9 | bit10);
                                //									g_isBAT = 1;	//设置为跳缝
                            }
                            else
                            {
                                //									g_isBAT = 0;	//清除跳缝标志
                            }
                            g_feedsum = g_patd.feed_sum;
                            g_feedc = g_patd.feed_sum;
                            g_array4[0][0] = 0;
                            g_point_num = 1;

                            //printf("g_code_mode = %d \r\n",g_code_mode);
                            if (f == 1)
                            { //成功
                                g_Ctstaddr = addr1;
                                if (g_code_mode == 13)
                                { //次原点
                                    g_home_2flag = 1;
                                    g_Ctsavetimes = 0;
                                    g_Ctstaddr = sew_getPinAddr((U16 *)SREG, g_CtPatLen, g_feedc, 2);
                                    //Bor_CtBefDatAny((U32*)&g_Ctstaddr,(U32*)&g_CtPatLen,(U8*)&g_oldspeed,1);
                                    g_Ctendaddr = g_Ctstaddr;
                                }

                                Bor_CreatBack((U16 *)&g_Ctsavetimes, g_Ctstaddr, g_Ctendaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);
                                pnoindex--;
                                pno = poldno[pnoindex];
                            }
                            else if (f == 3)
                            {
                                pno = MENU_RWHELP;
                                hleppara = 22;
                                EREG[1] = 160;
                            }
                            else if (f == 4)
                            {
                                pno = MENU_RWHELP;
                                hleppara = 66;
                            }
                        }
                        else
                        {
                            pnoindex--;
                            pno = poldno[pnoindex];
                        }
                    }

                    break;

                case KEY_CODE_RECIV:
                    //printf("KEY_CODE_RECIV------\r\n");
                    if ((g_pf_dis != 0) && g_pf_mode)
                    { //中压脚有设置不能复制图形
                        pno = MENU_RWHELP;
                        hleppara = 66;
                        poldno[pnoindex++] = MENU_CODE;
                        break;
                    }
                    pno = MENU_READCOVN;
                    poldno[pnoindex++] = MENU_CODE;
                    break;

                case KEY_CODE_TACK:
                    if ((g_pf_dis != 0) && g_pf_mode)
                    { //中压脚有设置不能复制图形
                        pno = MENU_RWHELP;
                        hleppara = 66;
                        poldno[pnoindex++] = MENU_CODE;
                        break;
                    }
                    pno = MENU_TACKING1;
                    poldno[pnoindex++] = MENU_CODE;
                    break;
                }
            }
            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            if (keyon == KEY_CODE_SCRNSVR) //不需要显示的按键
            {
            }
            else //常规按键
            {
                DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);
            }

            keyon = 0;
            beeponf = 0;
            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
            Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                         SheetPage, rect[0].index[0], rect[0].colorT[0]); //显示倒针设置
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if (Timerms > 1000)
        {
            Timerms = 0;
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1)
        {
            ErrorMsg(MENU_CODE);
        }
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        if (dis_updata)
        {
            dis_updata = 0;

            f = KEY_CODE_FUNC1 + tmp_code_mode - 1;
            if (F_FILETYPE == PAT_MIT)
            { //三菱
                for (i = KEY_CODE_FUNC1; i <= KEY_CODE_EXT2; i++)
                {
                    if (enExt2 == 0 && i == KEY_CODE_EXT2)
                    {
                    }
                    else
                    {
                        DrawButtonSingleColor(keyd[i], (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                                              (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                        Draw24X24FFStr(keyd[i].xpis + (keyd[i].xsize - 13 * strlen((char *)(MEM_TITLE_ADD + ((U32)keybmpind[i].nameStr[0]) * TitleLengthMax))) / 2,
                                       keyd[i].ypis + (keyd[i].ysize - 24) / 2,
                                       MEM_TITLE_ADD + ((U32)keybmpind[i].nameStr[0]) * TitleLengthMax,
                                       (f == i) ? keybmpind[i].textColor[2] : keybmpind[i].textColor[0]);
                    }
                }
            }
            else if (F_FILETYPE == PAT_SEW)
            {
                for (i = KEY_CODE_FUNC1; i <= KEY_CODE_EXT2; i++)
                {
                    if (i == KEY_CODE_EXT1)
                    {
                        DrawButtonSingleColor(keyd[i], (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                                              (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                        Draw24X24FFStr(keyd[i].xpis + (keyd[i].xsize - 13 * strlen((char *)(MEM_TITLE_ADD + ((U32)keybmpind[i].nameStr[0]) * TitleLengthMax))) / 2,
                                       keyd[i].ypis + (keyd[i].ysize - 24) / 2,
                                       MEM_TITLE_ADD + ((U32)keybmpind[i].nameStr[0]) * TitleLengthMax,
                                       (f == i) ? keybmpind[i].textColor[2] : keybmpind[i].textColor[0]);
                    }
                    else
                    {
                        if (enExt2 == 0 && i == KEY_CODE_EXT2)
                        {
                        }
                        else
                        {
                            if (g_BorAddFuns == 0)
                            {

                                DrawButtonSingleColor(keyd[i], (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                                                      (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                                Draw24X24FFStr(keyd[i].xpis + (keyd[i].xsize - 13 * strlen((char *)(MEM_TITLE_ADD + ((U32)keybmpind[i].nameStr[0]) * TitleLengthMax))) / 2,
                                               keyd[i].ypis + (keyd[i].ysize - 24) / 2,
                                               MEM_TITLE_ADD + ((U32)keybmpind[i].nameStr[0]) * TitleLengthMax,
                                               (f == i) ? keybmpind[i].textColor[2] : keybmpind[i].textColor[0]);
                            }
                            else
                            {

                                DrawButtonSingleColor(keyd[i], ((g_BorAddFuns >> (i - KEY_CODE_FUNC1)) & 0x01) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                                                      ((g_BorAddFuns >> (i - KEY_CODE_FUNC1)) & 0x01) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                                Draw24X24FFStr(keyd[i].xpis + (keyd[i].xsize - 13 * strlen((char *)(MEM_TITLE_ADD + ((U32)keybmpind[i].nameStr[0]) * TitleLengthMax))) / 2,
                                               keyd[i].ypis + (keyd[i].ysize - 24) / 2,
                                               MEM_TITLE_ADD + ((U32)keybmpind[i].nameStr[0]) * TitleLengthMax,
                                               ((g_BorAddFuns >> (i - KEY_CODE_FUNC1)) & 0x01) ? keybmpind[i].textColor[2] : keybmpind[i].textColor[0]);
                            }
                        }
                    }
                }
            }
        }

        // /[页面切换*begin]**********************************************************
        if (pno != MENU_CODE)
        {
            plastno = MENU_CODE;
            break;
        }
        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

/*******************************************************/

#define KEY_EXCODE_SCRNSVR 1   //1 屏保
#define KEY_EXCODE_BACK 2      //2 返回
#define KEY_EXCODE_ENTER 3     //3 确认
#define KEY_EXCODE_FEEDSP 4    //4 移送速度
#define KEY_EXCODE_RESTART 5   //5 重启动
#define KEY_EXCODE_THICKNESS 6 //6 物料厚
#define KEY_EXCODE_CLWEIGHT 7  //7 压板重
#define KEY_EXCODE_THICKL 8    //8 物料厚度-薄
#define KEY_EXCODE_THICKM 9    //9 物料厚度-中
#define KEY_EXCODE_THICKH 10   //10 物料厚度-厚
#define KEY_EXCODE_WEIGHT1 11  //11 压板力度-轻
#define KEY_EXCODE_WEIGHT2 12  //12 压板力度-中
#define KEY_EXCODE_WEIGHT3 13  //13 压板力度-重
#define KEY_EXCODE_CLEAN 14    //14 清除1位
#define KEY_EXCODE_UP 15       //15 +1
#define KEY_EXCODE_DOWN 16     //16 -1
#define KEY_EXCODE_0 17        //17 0
#define KEY_EXCODE_1 18        //18 1
#define KEY_EXCODE_2 19        //19 2
#define KEY_EXCODE_3 20        //20 3
#define KEY_EXCODE_4 21        //21 4
#define KEY_EXCODE_5 22        //22 5
#define KEY_EXCODE_6 23        //23 6
#define KEY_EXCODE_7 24        //24 7
#define KEY_EXCODE_8 25        //25 8
#define KEY_EXCODE_9 26        //26 9
#define KEY_EXCODE_SET1 27     //27 设置一
#define KEY_EXCODE_SET2 28     //28 设置二
#define KEY_EXCODE_MAX 29

#define RECT_EXCODE_TYPE 1 //1 额外代码类型
#define RECT_EXCODE_PARA 2 //2 额外代码

#define RECT_EXCODE_PARA_TIT 3 //3 额外代码-标题
#define RECT_EXCODE_PARA_STR 4 //4 额外代码-内容

#define RECT_EXCODE_MAX 4

void Menu_CtExCode(void)
{
    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
                                            /****按键相关参数end****/

    /****标志位相关参数begin****/
    U8 dis_updata1 = 1; //更新额外代码方法按键
    U8 dis_updata2 = 1; //更新额外代码针数设定的方框
    U8 dis_updata3 = 0; //更新额外代码针数设定的数据选择按钮
    U8 dis_updata4 = 0; //更新额外代码针数
    U32 i;
    U8 f;
    U16 parasel = 0, paravol = 0;
    U8 tmp_code_mode, tmpcodemode = 0xff;
    U32 tmpCreatStaddr;
    /****标志位相关参数end***/

    const U8 keynum = {KEY_EXCODE_MAX};

    const KEYPAD keyd[] = {
        {0, 0, 0, 0},

        {0, 0, 128, 32},                     //1 屏保
        {TYPE_X1, TYPE_Y4, KEY_X1, KEY_Y1},  //2 返回
        {TYPE_X11, TYPE_Y4, KEY_X1, KEY_Y1}, //3 确认

        {TYPE_X14 + SAFE_DIST8, TYPE_Y3 + SAFE_DIST6, KEY_X8, KEY_Y8},                            //4 移送速度
        {TYPE_X14 + SAFE_DIST8, TYPE_Y3 + SAFE_DIST6 * 2 + KEY_Y8, KEY_X8, KEY_Y8},               //5 重启动
        {TYPE_X14 + SAFE_DIST8 + KEY_X8 + 56, TYPE_Y3 + SAFE_DIST6, KEY_X8, KEY_Y8},              //6 物料厚
        {TYPE_X14 + SAFE_DIST8 + KEY_X8 + 56, TYPE_Y3 + SAFE_DIST6 * 2 + KEY_Y8, KEY_X8, KEY_Y8}, //7 压板重

        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 1 / 2, 275, KEY_X6, KEY_Y6}, //8 物料厚度-薄
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 5 / 2, 275, KEY_X6, KEY_Y6}, //9 物料厚度-中
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 9 / 2, 275, KEY_X6, KEY_Y6}, //10 物料厚度-厚

        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 1 / 2, 275, KEY_X6, KEY_Y6}, //11 压板力度-轻
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 5 / 2, 275, KEY_X6, KEY_Y6}, //12 压板力度-中
        {TYPE_X14 + SAFE_DIST1 + KEY_X6 * 9 / 2, 275, KEY_X6, KEY_Y6}, //13 压板力度-重

        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 4, KEY_X2, KEY_Y2}, //14 清除1位

        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},       //15 +1
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2}, //16 -1
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},                             //17 0
        {TYPE_X15, TYPE_Y13, KEY_X2, KEY_Y2},                                                         //18 1
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13, KEY_X2, KEY_Y2},                                   //19 2
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13, KEY_X2, KEY_Y2},                             //20 3
        {TYPE_X15, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},                                   //21 4
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},             //22 5
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},       //23 6
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},                             //24 7
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},       //25 8
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2}, //26 9

        {TYPE_X14 + SAFE_DIST8, TYPE_Y3 + SAFE_DIST6 * 3 + KEY_Y8 * 2, KEY_X8, KEY_Y8},               //27 设置一
        {TYPE_X14 + SAFE_DIST8 + KEY_X8 + 56, TYPE_Y3 + SAFE_DIST6 * 3 + KEY_Y8 * 2, KEY_X8, KEY_Y8}, //28 设置二
    };

    const tydDisSrcIndex keybmpind[] = {
        //title_counter
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {33}},                          //1 屏保
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {72, 88}, {34, 0, 0, 0}, {0}}, //2 返回
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {71, 87}, {35, 0, 0, 0}, {0}}, //3 确认

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {36}, {48}}, //4 移送速度
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {37}, {49}}, //5 重启动
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {38}, {50}}, //6 物料厚
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {39}, {51}}, //7 压板重

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {881, 0, 882}, {40, 0, 0, 0}, {0}}, //8 物料厚度-薄
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {883, 0, 884}, {41, 0, 0, 0}, {0}}, //9 物料厚度-中
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {885, 0, 886}, {42, 0, 0, 0}, {0}}, //10 物料厚度-厚
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {887, 0, 888}, {43, 0, 0, 0}, {0}}, //11 压板力度-轻
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {889, 0, 890}, {44, 0, 0, 0}, {0}}, //12 压板力度-中
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {0}, {891, 0, 892}, {45, 0, 0, 0}, {0}}, ///13 压板力度-重

        {{KEY_Silver}, {0}, {113}, {53, 0, 0, 0}, {0}}, //14 清除1位

        {{KEY_Silver}, {0}, {199}, {46, 0, 0, 0}, {0}}, //15 +1
        {{KEY_Silver}, {0}, {201}, {47, 0, 0, 0}, {0}}, //16 -1
        {{KEY_Silver}, {0}, {91}, {0, 0, 0, 0}, {0}},   //17 0
        {{KEY_Silver}, {0}, {92}, {0, 0, 0, 0}, {0}},   //18 1
        {{KEY_Silver}, {0}, {93}, {0, 0, 0, 0}, {0}},   //19 2
        {{KEY_Silver}, {0}, {94}, {0, 0, 0, 0}, {0}},   //20 3
        {{KEY_Silver}, {0}, {95}, {0, 0, 0, 0}, {0}},   //21 4
        {{KEY_Silver}, {0}, {96}, {0, 0, 0, 0}, {0}},   //22 5
        {{KEY_Silver}, {0}, {97}, {0, 0, 0, 0}, {0}},   //23 6
        {{KEY_Silver}, {0}, {98}, {0, 0, 0, 0}, {0}},   //24 7
        {{KEY_Silver}, {0}, {99}, {0, 0, 0, 0}, {0}},   //25 8
        {{KEY_Silver}, {0}, {100}, {0, 0, 0, 0}, {0}},  //26 9

        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {66}, {64}}, //27 设置一
        {{KEY_Silver, KEY_Gray, KEY_Blue}, {Color_Blue, Color_Black, Color_White}, {KEY_Silver, KEY_Gray, KEY_Blue, 0}, {67}, {65}}, //28 设置二

    };

    const RECTPAD rect[] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {32}},
        {TYPE_X14, TYPE_Y3, TYPE_SIZE29, 184, {Color_Black}, {Color_Black, Color_White}, {0}},                    //1 额外代码类型
        {TYPE_X14, TYPE_Y3 + 184 + SAFE_DIST6, TYPE_SIZE29, 95, {Color_Black}, {Color_Black, Color_White}, {52}}, //2 额外代码

        {TYPE_X14, TYPE_Y3 + 184 + SAFE_DIST6, TYPE_SIZE10, TYPE_SIZE5, {Color_KeyBlue}, {Color_White}, {52}},                               //3 额外代码-标题
        {TYPE_X14 + TYPE_SIZE10 + SAFE_DIST5, TYPE_Y3 + 184 + SAFE_DIST6, TYPE_SIZE14, TYPE_SIZE5, {Color_DeepSkyBlue}, {Color_Black}, {0}}, //4 额外代码-内容

    };

    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_EXCODE); //设置当前文字显示雷人在P1页面，对应41.bin
    InitScreen();
    initViewStatus();
    updateViewStatus();

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    if (plastno != MENU_SCRNSVR)
    {
        g_publicbuf[34] = plastno;
    }
    else
    {
        plastno = g_publicbuf[34];
    }
    if (g_exType == 1) //移送速
    {
        g_code_mode = 15;
        paravol = g_exFeedSp;
    }
    else if (g_exType == 2) //重启动
    {
        g_code_mode = 16;
        paravol = g_exRestart;
    }
    else if (g_exType == 3) //物料厚
    {
        g_code_mode = 17;
        parasel = g_exThickness;
    }
    else if (g_exType == 4) //压板重
    {
        g_code_mode = 18;
        parasel = g_exClweight;
    }
    else if (g_exType == 5) //设置一
    {
        g_code_mode = 40;
        paravol = g_pointSetPara1;
    }
    else if (g_exType == 6) //设置二
    {
        g_code_mode = 41;
        paravol = g_pointSetPara2;
    }

    if ((g_code_mode > 14 && g_code_mode < 19) || (g_code_mode >= 40 && g_code_mode <= 41))
        tmp_code_mode = g_code_mode;
    else
        tmp_code_mode = 15;
    if (F_FILETYPE == PAT_SEW)
    { //SEW
        if (tmp_code_mode < 40 || tmp_code_mode > 41)
            tmp_code_mode = 40;
    }
    if (parasel > 2)
        parasel = 1;

    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                 SheetPage, rect[0].index[0], rect[0].colorT[0]); //倒针参数

    //画出方框显示
    // for (i = 1; i < RECT_EXCODE_MAX; i++)
    // {

    //     if (i == RECT_EXCODE_TYPE)
    //     {
    //         DrawRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);

    //         Draw24x24Str(rect[i].xpis + SAFE_DIST4, rect[i].ypis + SAFE_DIST3,
    //                      MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
    //                      SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
    //     }
    //     // else if (i == RECT_EXCODE_END_TIT || i == RECT_EXCODE_START_TIT)
    //     // {
    //     //     DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
    //     //     Draw24x24Str(rect[i].xpis + (rect[i].xsize - 24 * 2) / 2, rect[i].ypis + (rect[i].ysize - 24) / 2,
    //     //                  MEM_TITLE_ADD + rect[i].index[0] * TitleLengthMax,
    //     //                  SheetPage, rect[i].index[0], rect[i].colorT[0]); //画出方框的文字
    //     // }
    // }

    // BmpFillRect(rect[RECT_EXCODE_TYPE].xpis, rect[RECT_EXCODE_TYPE].ypis, rect[RECT_EXCODE_TYPE].xsize, rect[RECT_EXCODE_TYPE].ysize);
    DrawRect(rect[RECT_EXCODE_TYPE].xpis, rect[RECT_EXCODE_TYPE].ypis,
             rect[RECT_EXCODE_TYPE].xsize, rect[RECT_EXCODE_TYPE].ysize, rect[RECT_EXCODE_TYPE].colorB[0]);

    // Draw24x24Str(rect[RECT_EXCODE_TYPE].xpis + SAFE_DIST4, rect[RECT_EXCODE_TYPE].ypis + SAFE_DIST3,
    //              MEM_TITLE_ADD + rect[RECT_EXCODE_TYPE].index[0] * TitleLengthMax,
    //              SheetPage, rect[RECT_EXCODE_TYPE].index[0], rect[RECT_EXCODE_TYPE].colorT[0]); //画出方框的文字

    //画出按键显示
    for (i = 2; i < KEY_EXCODE_MAX; i++)
    {
        if (i >= KEY_EXCODE_BACK && i <= KEY_EXCODE_ENTER)
        {
            DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
        }
    }

    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************
    ViewPage(usepageno); //设置显示缓存

    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    Timer_ms = 30720; //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        // keydata = get_keydata((KEYPAD *)keyd, KEY_EXCODE_CLWEIGHT + 1, 0); //获取键值
        // if(keydata == 0 && tmp_code_mode == 17)
        // {
        //     keydata = get_keydata((KEYPAD *)keyd, KEY_EXCODE_THICKH + 1, KEY_EXCODE_THICKL); //获取键值
        // }
        // if(keydata == 0 && tmp_code_mode == 18)
        // {
        //     keydata = get_keydata((KEYPAD *)keyd, KEY_EXCODE_WEIGHT3 + 1, KEY_EXCODE_WEIGHT1); //获取键值
        // }
        // if(keydata == 0)
        // {
        //     keydata = get_keydata((KEYPAD *)keyd, keynum, KEY_EXCODE_UP); //获取键值
        // }

        keydata = get_keydata((KEYPAD *)keyd, keynum, 0); //获取键值
        if ((tmp_code_mode == 18) && (keydata >= KEY_EXCODE_THICKL) && (keydata <= KEY_EXCODE_THICKH))
        {
            keydata += 3;
        }
        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理
        //无效按键

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            if ((keyon == KEY_EXCODE_UP) || (keyon == KEY_EXCODE_DOWN))
            {
            }
            else if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {
            //特定情况下不生效按键
            if (keydata >= KEY_EXCODE_FEEDSP && keydata <= KEY_EXCODE_CLWEIGHT && F_FILETYPE == PAT_SEW)
            {
                keydata = 0;
            }
            else if (((tmp_code_mode < 17 || tmp_code_mode == 40 || tmp_code_mode == 41) &&
                      (keydata >= KEY_EXCODE_THICKL) && (keydata <= KEY_EXCODE_WEIGHT3)) ||
                     ((tmp_code_mode == 17 || tmp_code_mode == 18) &&
                      keydata >= KEY_EXCODE_UP && keydata <= KEY_EXCODE_9))
            {
                keydata = 0;
            }

            else
            {
                if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时
                {
                    keyon = keydata;
                    if (keyon == KEY_EXCODE_SCRNSVR) //无按键特效
                    {
                    }
                    else
                    {
                        DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);
                    }
                    Times = 0;
                    delay = KEYDT; //按键防抖次数
                }
                else if (keyon != keydata) //已有按键按下，不处理新按键信息
                {
                    keydata = 0;
                }

                if (Times > delay) //按键防抖
                {
                    if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                    {
                        beeponf = 1;

                        if (g_keyBellT) //按键时蜂鸣器发声时间
                            Beep_On(g_keyBellT);

                        switch (keyon) //按键按下标题提示语显示
                        {
                        case KEY_EXCODE_0:
                        case KEY_EXCODE_1:
                        case KEY_EXCODE_2:
                        case KEY_EXCODE_3:
                        case KEY_EXCODE_4:
                        case KEY_EXCODE_5:
                        case KEY_EXCODE_6:
                        case KEY_EXCODE_7:
                        case KEY_EXCODE_8:
                        case KEY_EXCODE_9:
                            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
                            DrawMFU32(TITLE_XPOS_C2, SAFE_DIST4, keyon - KEY_EXCODE_0, 1, rect[0].colorT[0]);
                            break;
                        default:
                            DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                            break;
                        }
                        delay = KEYFT;
                    }
                    else if (beeponf == 1) //第二次进入
                    {
                        beeponf = 2;
                        //带有长按连续功能按键的功能

                        delay = KEYNT;
                    }
                    else if (beeponf < 20)
                    {
                        beeponf++;
                    }

                    if ((keyon == KEY_EXCODE_UP) || (keyon == KEY_EXCODE_DOWN)) //带有长按连续功能按键的功能
                    {
                        keyoff = keyon;
                        key_on_flag1 = 1;
                    }
                    Times = 0; //当前
                }
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            if ((keyoff >= KEY_EXCODE_FEEDSP) && (keyoff <= KEY_EXCODE_CLWEIGHT))
            {
                tmp_code_mode = keyoff + 11;
                dis_updata1 = 1;
                dis_updata2 = 1;
            }
            else if ((keyoff >= KEY_EXCODE_THICKL) && (keyoff <= KEY_EXCODE_THICKH))
            {
                parasel = keyoff - KEY_EXCODE_THICKL;
                dis_updata2 = 1;
            }
            else if ((keyoff >= KEY_EXCODE_WEIGHT1) && (keyoff <= KEY_EXCODE_WEIGHT3))
            {
                parasel = keyoff - KEY_EXCODE_WEIGHT1;
                dis_updata2 = 1;
            }
            else if ((keyoff >= KEY_EXCODE_0) && (keyoff <= KEY_EXCODE_9))
            {
                if ((tmp_code_mode == 15) || (tmp_code_mode == 16) ||
                    (tmp_code_mode == 40) || (tmp_code_mode == 41))
                {
                    if (tmp_code_mode == 41)
                    {
                        paravol = (paravol % 100) * 10 + keyoff - KEY_EXCODE_0;
                        if (paravol > 255)
                            paravol %= 100;
                    }
                    else
                    {
                        paravol = keyoff - KEY_EXCODE_0;
                    }
                    dis_updata4 = 1;
                }
            }
            else if (keyoff >= KEY_EXCODE_SET1 && keyoff <= KEY_EXCODE_SET2)
            {
                tmp_code_mode = keyoff + 14 - 1;
                dis_updata1 = 1;
                dis_updata2 = 1;
            }
            else
            {
                switch (keyoff)
                {
                case KEY_EXCODE_SCRNSVR:
                    pno = MENU_SCRNSVR;
                    break;
                case KEY_EXCODE_BACK:
                    pnoindex--;
                    pno = MENU_CODE;
                    break;
                case KEY_EXCODE_ENTER:
                    g_code_mode = tmp_code_mode;
                    if (g_code_mode < 17 || g_code_mode == 40 || g_code_mode == 41)
                        g_code_para = paravol;
                    else
                        g_code_para = parasel;
                    if ((poldno[pnoindex - 2] == MENU_MODIFYADD) || (g_publicbuf[33] == MENU_MODIFYADD))
                    { //插入代码
                        if ((g_code_mode == 15 && g_exType == 1) || (g_code_mode == 16 && g_exType == 2) || (g_code_mode == 17 && g_exType == 3) || (g_code_mode == 18 && g_exType == 4))
                        { //移送速,重启动,物料厚,压板重
                            pnoindex -= 3;
                            pno = poldno[pnoindex];
                            if (F_FILETYPE == PAT_MIT)
                            {
                                f = Mit_Convert_Data(11);
                            }
                            break;
                        }
                        else if (g_code_mode == 40 && g_exType == 5)
                        { //修改设置一的值
                            pnoindex -= 3;
                            pno = poldno[pnoindex];
                            if (F_FILETYPE == PAT_MIT)
                            {
                                f = Mit_Convert_Data(10);
                            }
                            else if (F_FILETYPE == PAT_SEW)
                            {
                                f = Bor_ModCode(g_jog_point, 1, 32, g_patd.pat_len, 0);
                                g_modifyflag = 1;
                                g_Tsavetimes = g_savetimes;
                                g_Tsavetimes++;
                                g_savetimes = g_Tsavetimes;
                                BackupSREG(g_Tsavetimes, 0, g_patd.pat_len, 1);
                            }
                            Write_Cmd(C_SET_PARA1, g_code_para, 0);
                            Read_Status();
                            g_curSetPara1 = g_code_para;
                            g_jog_point++;
                            break;
                        }
                        else if (g_code_mode == 41 && g_exType == 6)
                        { //修改设置二的值
                            pnoindex -= 3;
                            pno = poldno[pnoindex];
                            if (F_FILETYPE == PAT_MIT)
                            {
                                f = Mit_Convert_Data(10);
                            }
                            else if (F_FILETYPE == PAT_SEW)
                            {
                                f = Bor_ModCode(g_jog_point, 1, 33, g_patd.pat_len, 0);
                                g_modifyflag = 1;
                                g_Tsavetimes = g_savetimes;
                                g_Tsavetimes++;
                                g_savetimes = g_Tsavetimes;
                                BackupSREG(g_Tsavetimes, 0, g_patd.pat_len, 1);
                            }
                            Write_Cmd(C_SET_PARA2, g_code_para, 0);
                            Read_Status();
                            g_curSetPara1 = g_code_para;
                            g_jog_point++;
                            break;
                        }
                        if (F_FILETYPE == PAT_MIT)
                        {
                            if (g_code_mode == 40 || g_code_mode == 41)
                            {
                                g_code_mode -= 19;
                            }
                        }
                        pno = MENU_MODIFY3;
                        poldno[pnoindex] = MENU_EXCODE;
                        pnoindex++;
                    }
                    else if ((poldno[pnoindex - 2] == MENU_CURSOR) || (g_publicbuf[33] == MENU_CURSOR))
                    {
                        pno = MENU_CURSOR;
                        pnoindex -= 2;
                        if (F_FILETYPE == PAT_MIT)
                        { //mit
                            if (g_code_mode == 40)
                            { //设置1
                                if (g_code_para > 9)
                                    g_code_para = 0;

                                SREG[g_draw_p++] = 0x3d01;
                                SREG[g_draw_p++] = (g_code_para & 0xff);
                                SREG[g_draw_p++] = 0;
                                SREG[g_draw_p++] = 0;
                                SREG[g_line_p++] = g_line_sum++;
                                SREG[g_pat_p++] = (g_code_para & 0xff) << 8 | 0x3d;
                                SREG[g_pat_p++] = 0;
                            }
                            else if (g_code_mode == 41)
                            { //设置2
                                if (g_code_para > 255)
                                    g_code_para = 0;
                                SREG[g_draw_p++] = 0x3e01;
                                SREG[g_draw_p++] = (g_code_para & 0xff);
                                SREG[g_draw_p++] = 0;
                                SREG[g_draw_p++] = 0;
                                SREG[g_line_p++] = g_line_sum++;
                                SREG[g_pat_p++] = (g_code_para & 0xff) << 8 | 0x3e;
                                SREG[g_pat_p++] = 0;
                            }
                            else
                            {
                                SREG[g_draw_p++] = 0x1c01;
                                if (g_code_mode == 15)
                                { //移送速
                                    if (paravol > 9)
                                        paravol = 0;
                                    SREG[g_draw_p++] = 0x0 + (paravol << 8);
                                    SREG[g_pat_p++] = 0x1c;
                                    SREG[g_pat_p++] = paravol;
                                }
                                else if (g_code_mode == 16)
                                { //重启动
                                    if (paravol > 9)
                                        paravol = 0;
                                    SREG[g_draw_p++] = 0x3 + (paravol << 8);
                                    SREG[g_pat_p++] = 0x31c;
                                    SREG[g_pat_p++] = paravol;
                                }
                                else if (g_code_mode == 17)
                                { //物料后
                                    if (parasel > 2)
                                        parasel = 1;
                                    SREG[g_draw_p++] = 0x1 + (parasel << 8);
                                    SREG[g_pat_p++] = 0x11c;
                                    SREG[g_pat_p++] = parasel;
                                }
                                else
                                { //压板重
                                    if (parasel > 2)
                                        parasel = 1;
                                    SREG[g_draw_p++] = 0x2 + (parasel << 8);
                                    SREG[g_pat_p++] = 0x21c;
                                    SREG[g_pat_p++] = parasel;
                                }
                                SREG[g_draw_p++] = 0;
                                SREG[g_draw_p++] = 0;
                                SREG[g_line_p++] = g_line_sum++;
                            }

                            g_feedc = g_line_p - (SREG[2] + 0x40) / 2;
                            g_feedsum = g_feedc;
                            g_modifyflag |= 0x01;
                        }
                        else if (F_FILETYPE == PAT_SEW)
                        { //SEW
                            if (g_code_mode == 40 || g_code_mode == 41)
                            {
                                if (g_code_mode == 40 && g_code_para > 9)
                                    g_code_para = 0;
                                if (g_code_mode == 41 && g_code_para > 255)
                                    g_code_para = 0;
                                tmpCreatStaddr = g_Ctendaddr;
                                f = Bor_doExCode((U16 *)SREG, (U32 *)&tmpCreatStaddr, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, g_code_mode == 40 ? 1 : 2, g_code_para);
                                g_feedsum = g_patd.feed_sum;
                                g_feedc = g_patd.feed_sum;
                                g_array4[0][0] = 0;
                                g_point_num = 1;
                                if (f == 1)
                                {
                                    g_modifyflag |= 0x01;
                                    g_Ctstaddr = tmpCreatStaddr;
                                    Bor_CreatBack((U16 *)&g_Ctsavetimes, g_Ctstaddr, g_Ctendaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);
                                }
                            }
                        }
                        if (g_code_mode == 40 || g_code_mode == 41)
                        {
                            Write_Cmd(g_code_mode == 40 ? C_SET_PARA1 : C_SET_PARA2, g_code_para, 0);
                            if (Read_Status() != 100)
                            {
                                poldno[pnoindex++] = pno;
                                pno = MENU_RWHELP;
                                hleppara = 16;
                                break;
                            }
                            if (g_code_mode == 40)
                                g_curSetPara1 = g_code_para;
                            else
                                g_curSetPara2 = g_code_para;
                        }
                    }
                    else
                    {
                        pnoindex -= 2;
                        pno = poldno[pnoindex];
                    }
                    break;
                case KEY_EXCODE_UP:
                    if ((tmp_code_mode == 15) || (tmp_code_mode == 16) || (tmp_code_mode == 40) || (tmp_code_mode == 41))
                    {
                        if (tmp_code_mode == 40)
                        {
                            if (paravol < 255)
                                paravol++;
                            dis_updata4 = 1;
                        }
                        else
                        {
                            if (paravol < 9)
                                paravol++;
                            dis_updata4 = 1;
                        }
                    }
                    break;
                case KEY_EXCODE_DOWN:
                    if ((tmp_code_mode == 15) || (tmp_code_mode == 16) || (tmp_code_mode == 40) || (tmp_code_mode == 41))
                    {
                        if (paravol > 0)
                            paravol--;
                        dis_updata4 = 1;
                    }
                    break;
                case KEY_EXCODE_CLEAN:
                    if ((tmp_code_mode == 15) || (tmp_code_mode == 16) || (tmp_code_mode == 40) || (tmp_code_mode == 41))
                    {
                        paravol = 0;
                        dis_updata4 = 1;
                    }
                    break;
                }
            }
            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            if (keyon == KEY_EXCODE_SCRNSVR) //不需要显示的按键
            {
            }

            else //常规按键
            {
                DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);
            }

            keyon = 0;
            beeponf = 0;
            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
            Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                         SheetPage, rect[0].index[0], rect[0].colorT[0]); //显示倒针设置
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if (Timerms > 1000)
        {
            Timerms = 0;
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1)
        {
            ErrorMsg(MENU_EXCODE);
        }
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*begin]**********************************************************
        if (beeponf == 0)
        {
            ErrorMsg(MENU_EXCODE);
        }
        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*end]**********************************************************

        // /[更新额外代码方法按键*begin]**********************************************************
        if (dis_updata1)
        {
            dis_updata1 = 0;

            f = tmp_code_mode - 11;
            for (i = KEY_EXCODE_FEEDSP; i <= KEY_EXCODE_CLWEIGHT; i++)
            {
                DrawButtonSingleColor(keyd[i], (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                                      (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                Draw24X24FFStr(keyd[i].xpis + (keyd[i].xsize - 13 * strlen((char *)(MEM_TITLE_ADD + ((U32)keybmpind[i].nameStr[0]) * TitleLengthMax))) / 2,
                               keyd[i].ypis + (keyd[i].ysize - 24) / 2,
                               MEM_TITLE_ADD + ((U32)keybmpind[i].nameStr[0]) * TitleLengthMax,
                               (f == i) ? keybmpind[i].textColor[2] : keybmpind[i].textColor[0]);
            }
            f = tmp_code_mode - 13;
            for (i = KEY_EXCODE_SET1; i <= KEY_EXCODE_SET2; i++)
            {
                DrawButtonSingleColor(keyd[i], (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                                      (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                Draw24X24FFStr(keyd[i].xpis + (keyd[i].xsize - 13 * strlen((char *)(MEM_TITLE_ADD + ((U32)keybmpind[i].nameStr[0]) * TitleLengthMax))) / 2,
                               keyd[i].ypis + (keyd[i].ysize - 24) / 2,
                               MEM_TITLE_ADD + ((U32)keybmpind[i].nameStr[0]) * TitleLengthMax,
                               (f == i) ? keybmpind[i].textColor[2] : keybmpind[i].textColor[0]);
            }
        }

        // /[更新额外代码方法按键*end]**********************************************************

        // /[更新参数方框，包括文本输入框与按钮选择框*begin]**********************************************************
        if (dis_updata2)
        {
            dis_updata2 = 0;

            if (tmpcodemode != tmp_code_mode)
            {
                if (tmp_code_mode != 17 && tmp_code_mode != 18) //目标不为-物料厚-压板重-界面
                {
                    BmpFillRect(rect[RECT_EXCODE_PARA].xpis, rect[RECT_EXCODE_PARA].ypis, rect[RECT_EXCODE_PARA].xsize, rect[RECT_EXCODE_PARA].ysize);
                }
                if (tmp_code_mode == 17 || tmp_code_mode == 18) //目标为-物料厚-压板重-界面
                {
                    BmpFillRect(rect[RECT_EXCODE_PARA].xpis, rect[RECT_EXCODE_PARA].ypis, rect[RECT_EXCODE_PARA].xsize, rect[RECT_EXCODE_PARA].ysize);
                    BmpFillRect(keyd[KEY_EXCODE_1].xpis, keyd[KEY_EXCODE_1].ypis,
                                (keyd[KEY_EXCODE_1].xsize + SAFE_DIST5) * 3, (keyd[KEY_EXCODE_1].ysize + SAFE_DIST5) * 5);
                }
                tmpcodemode = tmp_code_mode;

                if (g_exType == 1 && tmp_code_mode == 15) //移送速
                {
                    paravol = g_exFeedSp;
                }
                else if (g_exType == 2 && tmp_code_mode == 16) //重启动
                {
                    paravol = g_exRestart;
                }
                else if (g_exType == 3 && tmp_code_mode == 17) //物料厚
                {
                    parasel = g_exThickness;
                }
                else if (g_exType == 4 && tmp_code_mode == 18) //压板重
                {
                    parasel = g_exClweight;
                }
                else if (g_exType == 5 && tmp_code_mode == 40) //设置一
                {
                    paravol = g_pointSetPara1;
                }
                else if (g_exType == 6 && tmp_code_mode == 41) //设置二
                {
                    paravol = g_pointSetPara2;
                }
            }
            if (tmp_code_mode < 17 || tmp_code_mode == 40 || tmp_code_mode == 41)
            {
                DrawFillRect(rect[RECT_EXCODE_PARA_TIT].xpis, rect[RECT_EXCODE_PARA_TIT].ypis, rect[RECT_EXCODE_PARA_TIT].xsize, rect[RECT_EXCODE_PARA_TIT].ysize, rect[RECT_EXCODE_PARA_TIT].colorB[0]);
                Draw24x24Str(rect[RECT_EXCODE_PARA_TIT].xpis + (rect[RECT_EXCODE_PARA_TIT].xsize - strlen((char *)(MEM_TITLE_ADD + rect[RECT_EXCODE_PARA_TIT].index[0] * TitleLengthMax)) * 13) / 2,
                             rect[RECT_EXCODE_PARA_TIT].ypis + (rect[RECT_EXCODE_PARA_TIT].ysize - 24) / 2,
                             MEM_TITLE_ADD + rect[RECT_EXCODE_PARA_TIT].index[0] * TitleLengthMax,
                             SheetPage, rect[RECT_EXCODE_PARA_TIT].index[0], rect[RECT_EXCODE_PARA_TIT].colorT[0]); //画出方框的文字

                DrawEdit(rect[RECT_EXCODE_PARA_STR], rect[RECT_EXCODE_PARA_STR].colorT[0], rect[RECT_EXCODE_PARA_STR].colorB[0]);
                if (tmp_code_mode == 41)
                {
                    DrawF16Str(rect[RECT_EXCODE_PARA_STR].xpis + rect[RECT_EXCODE_PARA_STR].xsize + SAFE_DIST4,
                               rect[RECT_EXCODE_PARA_STR].ypis + (rect[RECT_EXCODE_PARA_STR].ysize - 16) / 2,
                               "(0-255)", rect[RECT_EXCODE_PARA_STR].colorT[0]);
                }
                else
                {
                    DrawF16Str(rect[RECT_EXCODE_PARA_STR].xpis + rect[RECT_EXCODE_PARA_STR].xsize + SAFE_DIST4,
                               rect[RECT_EXCODE_PARA_STR].ypis + (rect[RECT_EXCODE_PARA_STR].ysize - 16) / 2,
                               "(0-9)", rect[RECT_EXCODE_PARA_STR].colorT[0]);
                }

                dis_updata3 = 1;
                dis_updata4 = 1;
            }
            else
            {
                DrawRect(rect[RECT_EXCODE_PARA].xpis, rect[RECT_EXCODE_PARA].ypis, rect[RECT_EXCODE_PARA].xsize, rect[RECT_EXCODE_PARA].ysize, rect[RECT_EXCODE_PARA].colorB[0]);
                Draw24x24Str(rect[RECT_EXCODE_PARA].xpis + SAFE_DIST4, rect[RECT_EXCODE_PARA].ypis + SAFE_DIST3,
                             MEM_TITLE_ADD + rect[RECT_EXCODE_PARA].index[0] * TitleLengthMax,
                             SheetPage, rect[RECT_EXCODE_PARA].index[0], rect[RECT_EXCODE_PARA].colorT[0]); //画出方框的文字
                if (tmp_code_mode == 17)
                {

                    f = KEY_EXCODE_THICKL + parasel;
                    for (i = KEY_EXCODE_THICKL; i <= KEY_EXCODE_THICKH; i++)
                    {
                        DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                                   (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                                   (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                    }
                    dis_updata3 = 0;
                    dis_updata4 = 0;
                }
                else if (tmp_code_mode == 18)
                {
                    f = KEY_EXCODE_WEIGHT1 + parasel;
                    for (i = KEY_EXCODE_WEIGHT1; i <= KEY_EXCODE_WEIGHT3; i++)
                    {
                        DrawButton(keyd[i], (U16 *)(ADD_ICONBMP),
                                   (f == i) ? keybmpind[i].border[2] : keybmpind[i].border[0],
                                   (f == i) ? keybmpind[i].icon[2] : keybmpind[i].icon[0]);
                    }
                    dis_updata3 = 0;
                    dis_updata4 = 0;
                }
            }
        }
        // /[更新参数方框，包括文本输入框与按钮选择框*end]**********************************************************

        // /[更新键盘按钮*begin]**********************************************************
        if (dis_updata3)
        {
            dis_updata3 = 0;

            for (i = KEY_EXCODE_CLEAN; i <= KEY_EXCODE_9; i++)
            {
                DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
            }
        }

        // /[更新键盘按钮*end]**********************************************************

        // /[更新参数数值*begin]**********************************************************
        if (dis_updata4)
        {
            dis_updata4 = 0;
            DrawFillRect(rect[RECT_EXCODE_PARA_STR].xpis + 1, rect[RECT_EXCODE_PARA_STR].ypis + 1,
                         rect[RECT_EXCODE_PARA_STR].xsize - 2, rect[RECT_EXCODE_PARA_STR].ysize - 2,
                         rect[RECT_EXCODE_PARA_STR].colorB[0]);
            DrawMFS32P(rect[RECT_EXCODE_PARA_STR].xpis + (rect[RECT_EXCODE_PARA_STR].xsize - 13 * 4) / 2,
                       rect[RECT_EXCODE_PARA_STR].ypis + (rect[RECT_EXCODE_PARA_STR].ysize - 24) / 2,
                       paravol, 3, 0, rect[RECT_EXCODE_PARA_STR].colorT[0]);
        }

        // /[更新参数数值*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if (pno != MENU_EXCODE)
        {
            plastno = MENU_EXCODE;
            break;
        }
        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

/*******************************************************/
#define KEY_PFOOT_SCRNSVR 1 //1 屏保
#define KEY_PFOOT_BACK 2    //2 返回
#define KEY_PFOOT_ENTER 3   //3 确认
#define KEY_PFOOT_PINUP 4   //4 针上升下降
#define KEY_PFOOT_SPFOOT 5  //5 压脚上升下降
#define KEY_PFOOT_UP 6      //6 +1
#define KEY_PFOOT_DOWN 7    //7 -1
#define KEY_PFOOT_RESET 8   //8 数值复位

#define KEY_PFOOT_MAX 9

#define RECT_PFOOT_PROMPT 1       //1 提示语
#define RECT_PFOOT_PROMPT1 2      //2 提示语1-标题
#define RECT_PFOOT_PROMPT1_STR 3  //3 提示语1-数值
#define RECT_PFOOT_PROMPT2 4      //4 提示语2-标题
#define RECT_PFOOT_PROMPT2_STR 5  //5 提示语2-数值
#define RECT_PFOOT_PROMPT3 6      //6 提示语3-标题
#define RECT_PFOOT_PROMPT3_STR 7  //7 提示语3-数值
#define RECT_PFOOT_PROMPT4 8      //8 提示语4-标题
#define RECT_PFOOT_PROMPT4_STR 9  //9 提示语4-数值
#define RECT_PFOOT_PROMPT5 10     //10 提示语5-标题
#define RECT_PFOOT_PROMPT5_STR 11 //11 提示语5-数值

#define RECT_PFOOT_MAX 12

// note: para：0：主界面进入修改 1：无 2:打板中修改 3：花样修改中修改
void Menu_CtPfootSet(U16 para)
{

    U32 i /*, j, k*/;
    U8 f = 0;
    U16 times50ms = 0xffff;

    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
                                            /****按键相关参数end****/
    /****标志位相关参数begin****/
    U8 page_flash = 1; //page_flash:当前值数据更新
    S16 vmax = 0;
    S16 val = 0, vmin = 0;
    U16 pfootf = 0xffff, pfootf1 = 0xfff;
    U16 needlef = 0xffff;
    //    U8 jogflag = 1;
    S8 tmpbase = 0;
    U8 viewToast = 0;
    static S16 temp_pf_absval;
    U32 BorPFaddr = 0, BorLFaddr = 0;
    //    U8 linemaxdisplay = 28; //一行显示最大字符数
    /****标志位相关参数end***/

    const U8 keynum = {KEY_PFOOT_MAX};
    const KEYPAD keyd[] = {
        {0, 0, 0, 0},
        {0, 0, 128, 32},                     //1 屏保
        {TYPE_X1, TYPE_Y4, KEY_X1, KEY_Y1},  //2 返回
        {TYPE_X11, TYPE_Y4, KEY_X1, KEY_Y1}, //3 确认

        {TYPE_X8, TYPE_Y4, KEY_X1, KEY_Y1},               //4 针上升下降
        {TYPE_X9, TYPE_Y4, KEY_X1, KEY_Y1},               //5 压脚上升下降
        {712, 231, KEY_X2, KEY_Y2},                       //6 +1
        {712, 231 + KEY_Y2 + SAFE_DIST1, KEY_X2, KEY_Y2}, //7 -1
        {TYPE_X10, TYPE_Y4, KEY_X1, KEY_Y1},              //8 数值复位

    };

    const tydDisSrcIndex keybmpind[] = {
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},  //1 屏保
        {{KEY_Silver}, {0}, {72}, {2, 0, 0, 0}, {0}}, //2 返回
        {{KEY_Silver}, {0}, {71}, {3, 0, 0, 0}, {0}}, //3 确认

        {{KEY_Silver, KEY_Gray}, {0}, {21, 23}, {8, 4, 0, 0}, {0}},         //4 针上升下降
        {{KEY_Silver, KEY_Gray}, {0}, {17, 18, 19, 20}, {9, 5, 0, 0}, {0}}, //5 压脚上升下降
        {{KEY_Silver, KEY_Gray}, {0}, {199}, {6, 0, 0, 0}, {0}},            //6 +1
        {{KEY_Silver, KEY_Gray}, {0}, {201}, {7, 0, 0, 0}, {0}},            //7 -1
        {{KEY_Silver, KEY_Gray}, {0}, {236}, {18, 0, 0, 0}, {0}},           //8 数值复位

    };

    const RECTPAD rect[RECT_PFOOT_MAX] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {0}},

        {TYPE_X17, TYPE_Y2, 720, TYPE_SIZE5, {Color_Red}, {Color_White}, {10}},                                                             //1 提示语
        {TYPE_X17, TYPE_Y8, TYPE_SIZE25, TYPE_SIZE5, {Color_LightGray}, {Color_Black}, {11, 11}},                                           //2 提示语1-标题
        {TYPE_X17 + TYPE_SIZE25 + SAFE_DIST5, TYPE_Y8, 215, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},                                 //3 提示语1-数值
        {TYPE_X17, TYPE_Y8 + TYPE_SIZE5 + SAFE_DIST5, TYPE_SIZE25, TYPE_SIZE5, {Color_LightGray}, {Color_Black}, {12, 12}},                 //4 提示语2-标题
        {TYPE_X17 + TYPE_SIZE25 + SAFE_DIST5, TYPE_Y8 + TYPE_SIZE5 + SAFE_DIST5, 215, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}},       //5 提示语2-数值
        {TYPE_X17, TYPE_Y8 + (TYPE_SIZE5 + SAFE_DIST5) * 2, TYPE_SIZE25, TYPE_SIZE5, {Color_LightGray}, {Color_Black}, {13, 14}},           //6 提示语3-标题
        {TYPE_X17 + TYPE_SIZE25 + SAFE_DIST5, TYPE_Y8 + (TYPE_SIZE5 + SAFE_DIST5) * 2, 215, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}}, //7 提示语3-数值
        {TYPE_X17, TYPE_Y8 + (TYPE_SIZE5 + SAFE_DIST5) * 3, TYPE_SIZE25, TYPE_SIZE5, {Color_LightGray}, {Color_Black}, {0, 16}},            //8 提示语4-标题
        {TYPE_X17 + TYPE_SIZE25 + SAFE_DIST5, TYPE_Y8 + (TYPE_SIZE5 + SAFE_DIST5) * 3, 215, TYPE_SIZE5, {Color_White}, {Color_Black}, {0}}, //9 提示语4-数值
        {TYPE_X17, 266, TYPE_SIZE25, TYPE_SIZE5, {Color_LightGray}, {Color_Black}, {14, 15}},                                               //10 提示语5-标题
        {TYPE_X17 + TYPE_SIZE25 + SAFE_DIST5, 266, TYPE_SIZE17, TYPE_SIZE5, {Color_DeepSkyBlue}, {Color_Black}, {0}},                       //11 提示语5-数值
    };

    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_PFOOT); //设置当前文字显示雷人在P1页面，对应41.bin
    InitScreen();
    initViewStatus();
    updateViewStatus();
    ToastInit();
    ToastSetBackColor(Color_Yellow);
    ToastSetTextColor(Color_Black);
    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    //读取当前中压脚基准值
    f = Read_D(D_Address[SYS] + SYS_PFOOTSET, 1, (U16 *)(&YREG[SYS_PFOOTSET]));
    if (f == 0)
    {
        pno = MENU_RWHELP;
        hleppara = 15;
        return;
    }
    g_pfootd.base = YREG[SYS_PFOOTSET];
    tmpbase = g_pfootd.base;

    Read_D(D_Address[SYS] + SYS_STATUS, 1, (U16 *)(&YREG[SYS_STATUS])); //获取进来此界面时中压脚状态
    pfootf1 = (U16)(S_PFOOT);

#if 0
    if (para == 1)
    { // 设定中压脚基准值
    }
    else if (para == 2)
    { // 打版中设置中压脚修正值

        Draw24x24Str(24, 66, MEM_TITLE_ADD + (U32)(10) * TitleLengthMax, SheetPage, 10, mCOLOR ? Color_White : Color_Black);  //提示:把机针降到最低
        Draw24x24Str(24, 118, MEM_TITLE_ADD + (U32)(11) * TitleLengthMax, SheetPage, 11, mCOLOR ? Color_White : Color_Black); //A.中压脚升降最大行程[PLP]:
        DrawMFS32P(488, 118, P_PLP, 4, 1, mCOLOR ? Color_White : Color_Black);
        Draw24X24FStr(548, 118, "mm", mCOLOR ? Color_White : Color_Black);

        Draw24x24Str(24, 154, MEM_TITLE_ADD + (U32)(12) * TitleLengthMax, SheetPage, 12, mCOLOR ? Color_White : Color_Black); //B.中压脚修正量(0-8.0mm)
        Draw24X24FStr(522, 154, "-", mCOLOR ? Color_White : Color_Black);
        DrawMFS32P(470, 154, g_patd.PFmin, 4, 1, mCOLOR ? Color_White : Color_Black);
        DrawMFS32P(535, 154, g_patd.PFmax, 3, 1, mCOLOR ? Color_White : Color_Black);
        val = g_pf_dis;

        if (g_updata_pf_valflg)
        { //需更新中压脚当前值、当前花样范围
            g_updata_pf_valflg = 0;
            temp_pf_absval = g_pf_absval;
            if (temp_pf_absval > (g_patd.PFmax + g_pfootd.base))
                g_patd.PFmax = temp_pf_absval - g_pfootd.base;
            if (temp_pf_absval < (g_patd.PFmin + g_pfootd.base))
                g_patd.PFmin = temp_pf_absval - g_pfootd.base;
        }
        vmax = PF_ABS_MAX - temp_pf_absval;
        vmin = PF_ABS_MIN - temp_pf_absval;

        Draw24x24Str(24, 192, MEM_TITLE_ADD + (U32)(14) * TitleLengthMax, SheetPage, 14, mCOLOR ? Color_White : Color_Black); //C.物料厚度设定(基准值):
        DrawMFS32P(501, 192, g_pfootd.base, 3, 1, mCOLOR ? Color_White : Color_Black);
        Draw24X24FStr(548, 192, "mm", mCOLOR ? Color_White : Color_Black);

        Draw24x24Str(24, 230, MEM_TITLE_ADD + (U32)(16) * TitleLengthMax, SheetPage, 16, mCOLOR ? Color_White : Color_Black); //花样中中压脚当前值
        DrawMFS32P(501, 230, temp_pf_absval, 3, 1, mCOLOR ? Color_White : Color_Black);
        Draw24X24FStr(548, 230, "mm", mCOLOR ? Color_White : Color_Black);

        Draw24x24Str(32, 302, MEM_TITLE_ADD + (U32)(15) * TitleLengthMax, SheetPage, 15, Color_Black); //物料厚度设定(修正量)

        Draw24X24FStr(242, 410, "(", Color_Black);
        Draw24X24FStr(307, 410, "-", Color_Black);
        Draw24X24FStr(372, 410, ")", Color_Black);

        DrawMFS32P(255, 410, vmin, 4, 1, Color_Black);
        DrawMFS32P(320, 410, vmax, 4, 1, Color_Black);
    }
    else
    { // 修改中修改中压脚

        val = g_pf_moddis;

        if (pfootf1 == 0x10)
        { //中压脚在下面
            if (g_pf_moddis > 0)
            {
                f = Write_Cmd(C_PFEMOV, 1, g_pf_moddis);
            }
            else
            {
                f = Write_Cmd(C_PFEMOV, 2, (-g_pf_moddis));
            }
        }
        else
        { //中压脚在上面
            if (F_FILETYPE == PAT_MIT)
            {
                f = Write_Cmd(C_PFOOTACTION, g_pf_absval + g_pf_moddis, 0);
            }
            else if (F_FILETYPE == PAT_SEW)
            {
                f = Write_Cmd(C_PFOOTACTION, g_pf_absval, 0);
            }
            Read_Status();
        }

        if (g_updata_pf_valflg)
        { //需更新中压脚当前值、当前花样范围
            g_updata_pf_valflg = 0;
            if (F_FILETYPE == PAT_MIT)
            {
                temp_pf_absval = g_pf_absval;
            }
            else if (F_FILETYPE == PAT_SEW)
            {
                temp_pf_absval = g_pf_absval - g_pf_moddis;
            }
            if (temp_pf_absval > (g_patd.PFmax + g_pfootd.base))
                g_patd.PFmax = temp_pf_absval - g_pfootd.base;
            if (temp_pf_absval < (g_patd.PFmin + g_pfootd.base))
                g_patd.PFmin = temp_pf_absval - g_pfootd.base;
        }
        vmax = PF_ABS_MAX - temp_pf_absval;
        vmin = PF_ABS_MIN - temp_pf_absval;

        Draw24x24Str(24, 66, MEM_TITLE_ADD + (U32)(10) * TitleLengthMax, SheetPage, 10, mCOLOR ? Color_White : Color_Black);  //提示:把机针降到最低
        Draw24x24Str(24, 118, MEM_TITLE_ADD + (U32)(11) * TitleLengthMax, SheetPage, 11, mCOLOR ? Color_White : Color_Black); //A.中压脚升降最大行程[PLP]:
        DrawMFS32P(488, 118, P_PLP, 4, 1, mCOLOR ? Color_White : Color_Black);
        Draw24X24FStr(548, 118, "mm", mCOLOR ? Color_White : Color_Black);
        Draw24x24Str(24, 154, MEM_TITLE_ADD + (U32)(12) * TitleLengthMax, SheetPage, 12, mCOLOR ? Color_White : Color_Black); //B.中压脚修正量(0-8.0mm)
        Draw24X24FStr(522, 154, "-", mCOLOR ? Color_White : Color_Black);
        DrawMFS32P(470, 154, g_patd.PFmin, 4, 1, mCOLOR ? Color_White : Color_Black);
        DrawMFS32P(535, 154, g_patd.PFmax, 3, 1, mCOLOR ? Color_White : Color_Black);

        Draw24x24Str(24, 192, MEM_TITLE_ADD + (U32)(14) * TitleLengthMax, SheetPage, 14, mCOLOR ? Color_White : Color_Black); //C.物料厚度设定(基准值):
        DrawMFS32P(501, 192, g_pfootd.base, 3, 1, mCOLOR ? Color_White : Color_Black);
        Draw24X24FStr(548, 192, "mm", mCOLOR ? Color_White : Color_Black);

        Draw24x24Str(24, 230, MEM_TITLE_ADD + (U32)(16) * TitleLengthMax, SheetPage, 16, mCOLOR ? Color_White : Color_Black); //花样中中压脚当前值
        DrawMFS32P(501, 230, temp_pf_absval, 3, 1, mCOLOR ? Color_White : Color_Black);
        Draw24X24FStr(548, 230, "mm", mCOLOR ? Color_White : Color_Black);

        Draw24x24Str(32, 302, MEM_TITLE_ADD + (U32)(15) * TitleLengthMax, SheetPage, 15, Color_Black); //物料厚度设定(修正量)

        Draw24X24FStr(242, 410, "(", Color_Black);
        Draw24X24FStr(307, 410, "-", Color_Black);
        Draw24X24FStr(372, 410, ")", Color_Black);

        DrawMFS32P(255, 410, vmin, 4, 1, Color_Black);
        DrawMFS32P(320, 410, vmax, 4, 1, Color_Black);
    }

#endif
    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                 SheetPage, rect[0].index[0], rect[0].colorT[0]); //中压脚设置

    //画出方框
    if (para == 1) //从主界面进入
    {
        if ((g_pfootd.base > (PF_ABS_MAX - g_patd.PFmax)) || (g_pfootd.base < PF_ABS_MIN - g_patd.PFmin))
        {
            g_pfootd.base = PF_ABS_MIN - g_patd.PFmin;

            f = Write_Cmd(C_PFOOTACTION, g_pfootd.base, 0);
            Read_Status();
            Write_Cmd(C_PFEST, 1, 2);
            Read_Status();
        }

        val = g_pfootd.base;
        vmax = PF_ABS_MAX - g_patd.PFmax;
        vmin = PF_ABS_MIN - g_patd.PFmin;
        //	printf("g_patd.PFmax = %d g_patd.PFmin = %d  vmax = %d vmin = %d \r\n",g_patd.PFmax,g_patd.PFmin,vmax,vmin);
        if ((val > vmax) || (val < vmin))
            val = vmin;

        for (i = 1; i < RECT_PFOOT_MAX; i++)
        {
            if (i == RECT_PFOOT_PROMPT4 || i == RECT_PFOOT_PROMPT4_STR)
            {
                continue;
            }
            else
            {
                DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
            }
            if (i == RECT_PFOOT_PROMPT5_STR)
            {
                DrawDottedRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorT[0]);
            }
            if (i == RECT_PFOOT_PROMPT1 ||
                i == RECT_PFOOT_PROMPT2 ||
                i == RECT_PFOOT_PROMPT3 ||
                i == RECT_PFOOT_PROMPT5)
            {
                Draw24x24Str(rect[i].xpis + SAFE_DIST4, rect[i].ypis + SAFE_DIST4,
                             MEM_TITLE_ADD + (U32)(rect[i].index[0]) * TitleLengthMax,
                             SheetPage, rect[i].index[0], rect[i].colorT[0]);
            }
        }

        DrawMFS32P(rect[RECT_PFOOT_PROMPT1_STR].xpis + (rect[RECT_PFOOT_PROMPT1_STR].xsize - 4 * 13) / 2,
                   rect[RECT_PFOOT_PROMPT1_STR].ypis + SAFE_DIST4,
                   P_PLP, 4, 1, rect[RECT_PFOOT_PROMPT1_STR].colorT[0]);
        Draw24X24FStr(rect[RECT_PFOOT_PROMPT1_STR].xpis + rect[RECT_PFOOT_PROMPT1_STR].xsize - 13 * 2,
                      rect[RECT_PFOOT_PROMPT1_STR].ypis + SAFE_DIST4,
                      "mm", rect[RECT_PFOOT_PROMPT1_STR].colorT[0]);

        Draw24X24FStr(rect[RECT_PFOOT_PROMPT3_STR].xpis + (rect[RECT_PFOOT_PROMPT3_STR].xsize - 13 * 14) / 2,
                      rect[RECT_PFOOT_PROMPT3_STR].ypis + SAFE_DIST4,
                      g_patd.PFmin > 0 ? "+" : "-", rect[RECT_PFOOT_PROMPT3_STR].colorT[0]);
        DrawMFS32P(rect[RECT_PFOOT_PROMPT3_STR].xpis + (rect[RECT_PFOOT_PROMPT3_STR].xsize - 13 * 12) / 2,
                   rect[RECT_PFOOT_PROMPT3_STR].ypis + SAFE_DIST4,
                   g_patd.PFmin < 0 ? -g_patd.PFmin : g_patd.PFmin, 3, 1, rect[RECT_PFOOT_PROMPT3_STR].colorT[0]);

        Draw24X24FStr(rect[RECT_PFOOT_PROMPT3_STR].xpis + (rect[RECT_PFOOT_PROMPT3_STR].xsize - 13 * 4) / 2,
                      rect[RECT_PFOOT_PROMPT3_STR].ypis + SAFE_DIST4,
                      "-", rect[RECT_PFOOT_PROMPT3_STR].colorT[0]);

        Draw24X24FStr(rect[RECT_PFOOT_PROMPT3_STR].xpis + (rect[RECT_PFOOT_PROMPT3_STR].xsize) / 2,
                      rect[RECT_PFOOT_PROMPT3_STR].ypis + SAFE_DIST4,
                      "+", rect[RECT_PFOOT_PROMPT3_STR].colorT[0]);
        DrawMFS32P(rect[RECT_PFOOT_PROMPT3_STR].xpis + +(rect[RECT_PFOOT_PROMPT3_STR].xsize + 13 * 2) / 2,
                   rect[RECT_PFOOT_PROMPT3_STR].ypis + SAFE_DIST4,
                   g_patd.PFmax, 3, 1, rect[RECT_PFOOT_PROMPT3_STR].colorT[0]);

        Draw24X24FStr(rect[RECT_PFOOT_PROMPT3_STR].xpis + rect[RECT_PFOOT_PROMPT1_STR].xsize - 13 * 2,
                      rect[RECT_PFOOT_PROMPT3_STR].ypis + SAFE_DIST4,
                      "mm", rect[RECT_PFOOT_PROMPT3_STR].colorT[0]);

        // Draw24X24FStr(rect[RECT_PFOOT_PROMPT5].xpis + rect[RECT_PFOOT_PROMPT5].xsize - 13 * (5 + 8),
        //               rect[RECT_PFOOT_PROMPT5].ypis + SAFE_DIST4, "(", rect[RECT_PFOOT_PROMPT5].colorT[0]);
        // DrawMFS32P(rect[RECT_PFOOT_PROMPT5].xpis + rect[RECT_PFOOT_PROMPT5].xsize - 13 * (4 + 8),
        //            rect[RECT_PFOOT_PROMPT5].ypis + SAFE_DIST4, vmin, 4, 1, rect[RECT_PFOOT_PROMPT5].colorT[0]);
        // Draw24X24FStr(rect[RECT_PFOOT_PROMPT5].xpis + rect[RECT_PFOOT_PROMPT5].xsize - 13 * (3 + 4),
        //               rect[RECT_PFOOT_PROMPT5].ypis + SAFE_DIST4, "-", rect[RECT_PFOOT_PROMPT5].colorT[0]);
        // DrawMFS32P(rect[RECT_PFOOT_PROMPT5].xpis + rect[RECT_PFOOT_PROMPT5].xsize - 13 * (1 + 4),
        //            rect[RECT_PFOOT_PROMPT5].ypis + SAFE_DIST4, vmax, 4, 1, rect[RECT_PFOOT_PROMPT5].colorT[0]);
        // Draw24X24FStr(rect[RECT_PFOOT_PROMPT5].xpis + rect[RECT_PFOOT_PROMPT5].xsize - 13 * (1 + 0),
        //               rect[RECT_PFOOT_PROMPT5].ypis + SAFE_DIST4, ")", rect[RECT_PFOOT_PROMPT5].colorT[0]);

        Draw24X24FStr(rect[RECT_PFOOT_PROMPT5].xpis + rect[RECT_PFOOT_PROMPT5].xsize - 13 * (5 + 8),
                      rect[RECT_PFOOT_PROMPT5].ypis + SAFE_DIST4, "(    -    )", rect[RECT_PFOOT_PROMPT5].colorT[0]);
        DrawMFS32P(rect[RECT_PFOOT_PROMPT5].xpis + rect[RECT_PFOOT_PROMPT5].xsize - 13 * (4 + 8),
                   rect[RECT_PFOOT_PROMPT5].ypis + SAFE_DIST4, vmin, 4, 1, rect[RECT_PFOOT_PROMPT5].colorT[0]);
        DrawMFS32P(rect[RECT_PFOOT_PROMPT5].xpis + rect[RECT_PFOOT_PROMPT5].xsize - 13 * (3 + 4),
                   rect[RECT_PFOOT_PROMPT5].ypis + SAFE_DIST4, vmax, 4, 1, rect[RECT_PFOOT_PROMPT5].colorT[0]);
    }
    else if (para == 2) //从打版界面，修改界面进入
    {

        for (i = 1; i < RECT_PFOOT_MAX; i++)
        {
            DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
            if (i == RECT_PFOOT_PROMPT5_STR)
            {
                DrawDottedRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorT[0]);
            }
        }
        for (i = 1; i < RECT_PFOOT_MAX; i++)
        {

            DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
            if (i == RECT_PFOOT_PROMPT5_STR)
            {
                DrawDottedRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorT[0]);
            }
            if (i == RECT_PFOOT_PROMPT1 ||
                i == RECT_PFOOT_PROMPT2 ||
                i == RECT_PFOOT_PROMPT3 ||
                i == RECT_PFOOT_PROMPT4 ||
                i == RECT_PFOOT_PROMPT5)
            {
                Draw24x24Str(rect[i].xpis + SAFE_DIST4, rect[i].ypis + SAFE_DIST4,
                             MEM_TITLE_ADD + (U32)(rect[i].index[1]) * TitleLengthMax,
                             SheetPage, rect[i].index[1], rect[i].colorT[0]);
            }
        }
        DrawMFS32P(rect[RECT_PFOOT_PROMPT1_STR].xpis + (rect[RECT_PFOOT_PROMPT1_STR].xsize - 4 * 13) / 2,
                   rect[RECT_PFOOT_PROMPT1_STR].ypis + SAFE_DIST4,
                   P_PLP, 4, 1, rect[RECT_PFOOT_PROMPT1_STR].colorT[0]);
        Draw24X24FStr(rect[RECT_PFOOT_PROMPT1_STR].xpis + rect[RECT_PFOOT_PROMPT1_STR].xsize - 13 * 2,
                      rect[RECT_PFOOT_PROMPT1_STR].ypis + SAFE_DIST4,
                      "mm", rect[RECT_PFOOT_PROMPT1_STR].colorT[0]);

        DrawMFS32P(rect[RECT_PFOOT_PROMPT2_STR].xpis + (rect[RECT_PFOOT_PROMPT2_STR].xsize - 13 * 14) / 2,
                   rect[RECT_PFOOT_PROMPT2_STR].ypis + SAFE_DIST4,
                   g_patd.PFmin, 4, 1, rect[RECT_PFOOT_PROMPT2_STR].colorT[0]);
        Draw24X24FStr(rect[RECT_PFOOT_PROMPT2_STR].xpis + (rect[RECT_PFOOT_PROMPT2_STR].xsize - 13 * 4) / 2,
                      rect[RECT_PFOOT_PROMPT2_STR].ypis + SAFE_DIST4,
                      "-", rect[RECT_PFOOT_PROMPT2_STR].colorT[0]);
        DrawMFS32P(rect[RECT_PFOOT_PROMPT2_STR].xpis + (rect[RECT_PFOOT_PROMPT2_STR].xsize) / 2,
                   rect[RECT_PFOOT_PROMPT2_STR].ypis + SAFE_DIST4,
                   g_patd.PFmax, 4, 1, rect[RECT_PFOOT_PROMPT2_STR].colorT[0]);
        Draw24X24FStr(rect[RECT_PFOOT_PROMPT2_STR].xpis + rect[RECT_PFOOT_PROMPT2_STR].xsize - 13 * 2,
                      rect[RECT_PFOOT_PROMPT2_STR].ypis + SAFE_DIST4,
                      "mm", rect[RECT_PFOOT_PROMPT2_STR].colorT[0]);
        val = g_pf_dis;

        if (g_updata_pf_valflg)
        { //需更新中压脚当前值、当前花样范围
            g_updata_pf_valflg = 0;
            temp_pf_absval = g_pf_absval;
            if (temp_pf_absval > (g_patd.PFmax + g_pfootd.base))
                g_patd.PFmax = temp_pf_absval - g_pfootd.base;
            if (temp_pf_absval < (g_patd.PFmin + g_pfootd.base))
                g_patd.PFmin = temp_pf_absval - g_pfootd.base;
        }
        vmax = PF_ABS_MAX - temp_pf_absval;
        vmin = PF_ABS_MIN - temp_pf_absval;

        DrawMFS32P(rect[RECT_PFOOT_PROMPT3_STR].xpis + (rect[RECT_PFOOT_PROMPT3_STR].xsize - 3 * 13) / 2,
                   rect[RECT_PFOOT_PROMPT3_STR].ypis + SAFE_DIST4,
                   g_pfootd.base, 3, 1, rect[RECT_PFOOT_PROMPT3_STR].colorT[0]);
        Draw24X24FStr(rect[RECT_PFOOT_PROMPT3_STR].xpis + rect[RECT_PFOOT_PROMPT3_STR].xsize - 13 * 2,
                      rect[RECT_PFOOT_PROMPT3_STR].ypis + SAFE_DIST4,
                      "mm", rect[RECT_PFOOT_PROMPT3_STR].colorT[0]);

        DrawMFS32P(rect[RECT_PFOOT_PROMPT4_STR].xpis + (rect[RECT_PFOOT_PROMPT4_STR].xsize - 3 * 13) / 2,
                   rect[RECT_PFOOT_PROMPT4_STR].ypis + SAFE_DIST4,
                   temp_pf_absval, 3, 1, rect[RECT_PFOOT_PROMPT4_STR].colorT[0]);
        Draw24X24FStr(rect[RECT_PFOOT_PROMPT4_STR].xpis + rect[RECT_PFOOT_PROMPT3_STR].xsize - 13 * 2,
                      rect[RECT_PFOOT_PROMPT4_STR].ypis + SAFE_DIST4,
                      "mm", rect[RECT_PFOOT_PROMPT4_STR].colorT[0]);

        Draw24X24FStr(rect[RECT_PFOOT_PROMPT5].xpis + rect[RECT_PFOOT_PROMPT5].xsize - 13 * (5 + 8),
                      rect[RECT_PFOOT_PROMPT5].ypis + SAFE_DIST4, "(    -    )", rect[RECT_PFOOT_PROMPT5].colorT[0]);
        DrawMFS32P(rect[RECT_PFOOT_PROMPT5].xpis + rect[RECT_PFOOT_PROMPT5].xsize - 13 * (4 + 8),
                   rect[RECT_PFOOT_PROMPT5].ypis + SAFE_DIST4, vmin, 4, 1, rect[RECT_PFOOT_PROMPT5].colorT[0]);
        DrawMFS32P(rect[RECT_PFOOT_PROMPT5].xpis + rect[RECT_PFOOT_PROMPT5].xsize - 13 * (3 + 4),
                   rect[RECT_PFOOT_PROMPT5].ypis + SAFE_DIST4, vmax, 4, 1, rect[RECT_PFOOT_PROMPT5].colorT[0]);
    }
    else
    {

        val = g_pf_moddis;

        if (pfootf1 == 0x10)
        { //中压脚在下面
            if (g_pf_moddis > 0)
            {
                f = Write_Cmd(C_PFEMOV, 1, g_pf_moddis);
            }
            else
            {
                f = Write_Cmd(C_PFEMOV, 2, (-g_pf_moddis));
            }
        }
        else
        { //中压脚在上面
            if (F_FILETYPE == PAT_MIT)
            {
                f = Write_Cmd(C_PFOOTACTION, g_pf_absval + g_pf_moddis, 0);
            }
            else if (F_FILETYPE == PAT_SEW)
            {
                f = Write_Cmd(C_PFOOTACTION, g_pf_absval, 0);
            }
            Read_Status();
        }

        if (g_updata_pf_valflg)
        { //需更新中压脚当前值、当前花样范围
            g_updata_pf_valflg = 0;
            if (F_FILETYPE == PAT_MIT)
            {
                temp_pf_absval = g_pf_absval;
            }
            else if (F_FILETYPE == PAT_SEW)
            {
                temp_pf_absval = g_pf_absval - g_pf_moddis;
            }
            if (temp_pf_absval > (g_patd.PFmax + g_pfootd.base))
                g_patd.PFmax = temp_pf_absval - g_pfootd.base;
            if (temp_pf_absval < (g_patd.PFmin + g_pfootd.base))
                g_patd.PFmin = temp_pf_absval - g_pfootd.base;
        }
        vmax = PF_ABS_MAX - temp_pf_absval;
        vmin = PF_ABS_MIN - temp_pf_absval;

        for (i = 1; i < RECT_PFOOT_MAX; i++)
        {
            DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
            if (i == RECT_PFOOT_PROMPT5_STR)
            {
                DrawDottedRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorT[0]);
            }
        }
        for (i = 1; i < RECT_PFOOT_MAX; i++)
        {

            DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
            if (i == RECT_PFOOT_PROMPT5_STR)
            {
                DrawDottedRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorT[0]);
            }
            if (i == RECT_PFOOT_PROMPT1 ||
                i == RECT_PFOOT_PROMPT2 ||
                i == RECT_PFOOT_PROMPT3 ||
                i == RECT_PFOOT_PROMPT4 ||
                i == RECT_PFOOT_PROMPT5)
            {
                Draw24x24Str(rect[i].xpis + SAFE_DIST4, rect[i].ypis + SAFE_DIST4,
                             MEM_TITLE_ADD + (U32)(rect[i].index[1]) * TitleLengthMax,
                             SheetPage, rect[i].index[1], rect[i].colorT[0]);
            }
        }
        DrawMFS32P(rect[RECT_PFOOT_PROMPT1_STR].xpis + (rect[RECT_PFOOT_PROMPT1_STR].xsize - 4 * 13) / 2,
                   rect[RECT_PFOOT_PROMPT1_STR].ypis + SAFE_DIST4,
                   P_PLP, 4, 1, rect[RECT_PFOOT_PROMPT1_STR].colorT[0]);
        Draw24X24FStr(rect[RECT_PFOOT_PROMPT1_STR].xpis + rect[RECT_PFOOT_PROMPT1_STR].xsize - 13 * 2,
                      rect[RECT_PFOOT_PROMPT1_STR].ypis + SAFE_DIST4,
                      "mm", rect[RECT_PFOOT_PROMPT1_STR].colorT[0]);

        DrawMFS32P(rect[RECT_PFOOT_PROMPT2_STR].xpis + (rect[RECT_PFOOT_PROMPT2_STR].xsize - 13 * 14) / 2,
                   rect[RECT_PFOOT_PROMPT2_STR].ypis + SAFE_DIST4,
                   g_patd.PFmin, 4, 1, rect[RECT_PFOOT_PROMPT2_STR].colorT[0]);
        Draw24X24FStr(rect[RECT_PFOOT_PROMPT2_STR].xpis + (rect[RECT_PFOOT_PROMPT2_STR].xsize - 13 * 4) / 2,
                      rect[RECT_PFOOT_PROMPT2_STR].ypis + SAFE_DIST4,
                      "-", rect[RECT_PFOOT_PROMPT2_STR].colorT[0]);
        DrawMFS32P(rect[RECT_PFOOT_PROMPT2_STR].xpis + (rect[RECT_PFOOT_PROMPT2_STR].xsize) / 2,
                   rect[RECT_PFOOT_PROMPT2_STR].ypis + SAFE_DIST4,
                   g_patd.PFmax, 4, 1, rect[RECT_PFOOT_PROMPT2_STR].colorT[0]);
        Draw24X24FStr(rect[RECT_PFOOT_PROMPT2_STR].xpis + rect[RECT_PFOOT_PROMPT2_STR].xsize - 13 * 2,
                      rect[RECT_PFOOT_PROMPT2_STR].ypis + SAFE_DIST4,
                      "mm", rect[RECT_PFOOT_PROMPT2_STR].colorT[0]);

        DrawMFS32P(rect[RECT_PFOOT_PROMPT3_STR].xpis + (rect[RECT_PFOOT_PROMPT3_STR].xsize - 3 * 13) / 2,
                   rect[RECT_PFOOT_PROMPT3_STR].ypis + SAFE_DIST4,
                   g_pfootd.base, 3, 1, rect[RECT_PFOOT_PROMPT3_STR].colorT[0]);
        Draw24X24FStr(rect[RECT_PFOOT_PROMPT3_STR].xpis + rect[RECT_PFOOT_PROMPT3_STR].xsize - 13 * 2,
                      rect[RECT_PFOOT_PROMPT3_STR].ypis + SAFE_DIST4,
                      "mm", rect[RECT_PFOOT_PROMPT3_STR].colorT[0]);

        DrawMFS32P(rect[RECT_PFOOT_PROMPT4_STR].xpis + (rect[RECT_PFOOT_PROMPT4_STR].xsize - 3 * 13) / 2,
                   rect[RECT_PFOOT_PROMPT4_STR].ypis + SAFE_DIST4,
                   temp_pf_absval, 3, 1, rect[RECT_PFOOT_PROMPT4_STR].colorT[0]);
        Draw24X24FStr(rect[RECT_PFOOT_PROMPT4_STR].xpis + rect[RECT_PFOOT_PROMPT3_STR].xsize - 13 * 2,
                      rect[RECT_PFOOT_PROMPT4_STR].ypis + SAFE_DIST4,
                      "mm", rect[RECT_PFOOT_PROMPT4_STR].colorT[0]);

        Draw24X24FStr(rect[RECT_PFOOT_PROMPT5].xpis + rect[RECT_PFOOT_PROMPT5].xsize - 13 * (5 + 8),
                      rect[RECT_PFOOT_PROMPT5].ypis + SAFE_DIST4, "(    -    )", rect[RECT_PFOOT_PROMPT5].colorT[0]);
        DrawMFS32P(rect[RECT_PFOOT_PROMPT5].xpis + rect[RECT_PFOOT_PROMPT5].xsize - 13 * (4 + 8),
                   rect[RECT_PFOOT_PROMPT5].ypis + SAFE_DIST4, vmin, 4, 1, rect[RECT_PFOOT_PROMPT5].colorT[0]);
        DrawMFS32P(rect[RECT_PFOOT_PROMPT5].xpis + rect[RECT_PFOOT_PROMPT5].xsize - 13 * (3 + 4),
                   rect[RECT_PFOOT_PROMPT5].ypis + SAFE_DIST4, vmax, 4, 1, rect[RECT_PFOOT_PROMPT5].colorT[0]);
    }
    Draw24x24Str(rect[RECT_PFOOT_PROMPT].xpis + SAFE_DIST4, rect[RECT_PFOOT_PROMPT].ypis + SAFE_DIST4,
                 MEM_TITLE_ADD + (U32)(rect[RECT_PFOOT_PROMPT].index[0]) * TitleLengthMax,
                 SheetPage, rect[RECT_PFOOT_PROMPT].index[0], rect[RECT_PFOOT_PROMPT].colorT[0]); //提示:把机针降到最低
    //画出按键显示
    for (i = 2; i < KEY_PFOOT_MAX; i++)
    {
        //无效按键
        //绘制颜色文字按键
        //常规按钮
        DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
    }

    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************
    ViewPage(usepageno); //设置显示缓存
    if ((poldno[pnoindex - 1] == MENU_P1) || (poldno[pnoindex - 1] == MENU_P2))
    { //从主界面进来，发停止运行命令
        E_RUNEN();
        Write_Cmd(C_WRITESTATUS, YREG[SYS_ENABLE], SYS_ENABLE);
    }
    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    Timer_ms = 30720; //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        keydata = get_keydata((KEYPAD *)keyd, keynum, 0); //获取键值

        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理
        //无效按键

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            if ((keyon == KEY_PFOOT_UP) || (keyon == KEY_PFOOT_DOWN)) //带有连续按键功能的按键
            {
            }
            else if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {
            //特定情况下不生效按键

            if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时
            {
                keyon = keydata;
                ToastHide();
                if (keyon == KEY_PFOOT_SCRNSVR) //无按键特效
                {
                }
                //非常规按键-//绘制颜色文字按键
                else
                {
                    DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);
                }
                Times = 0;
                delay = KEYDT; //按键防抖次数
            }
            else if (keyon != keydata) //已有按键按下，不处理新按键信息
            {
                keydata = 0;
            }

            if (Times > delay) //按键防抖
            {
                if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                {
                    beeponf = 1;

                    if (g_keyBellT) //按键时蜂鸣器发声时间
                        Beep_On(g_keyBellT);

                    switch (keyon) //按键按下标题提示语显示
                    {
                    default:
                        DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                        break;
                    }
                    delay = KEYFT;
                }
                else if (beeponf == 1) //第二次进入
                {
                    beeponf = 2;
                    if ((keyon == KEY_PFOOT_UP) || (keyon == KEY_PFOOT_DOWN)) //带有长按连续功能按键的功能
                    {
                        delay = DELAY_MOVE;
                    }
                    else
                        delay = KEYNT;
                }
                else if (beeponf < 20)
                {
                    beeponf++;
                }

                if ((keyon == KEY_PFOOT_UP) || (keyon == KEY_PFOOT_DOWN)) //带有长按连续功能按键的功能
                {
                    keyoff = keyon;
                    key_on_flag1 = 1;
                }
                Times = 0; //当前
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {

            switch (keyoff)
            {
            case KEY_PFOOT_SCRNSVR:
                pno = MENU_SCRNSVR;
                break;
            case KEY_PFOOT_BACK:
                if (para == 3)
                { //修改
                    pno = MENU_MODIFYADD;
                    g_updata_pf_valflg = 1;
                    if (pfootf == 0x10)
                    { //中压脚在下面
                        if (val > 0)
                            Write_Cmd(C_PFEMOV, 2, val);
                        else if (val < 0)
                            Write_Cmd(C_PFEMOV, 1, abs(val));
                    }
                    else
                    { //中压脚在上面
                        //							if(F_FILETYPE==1){
                        //
                        //							}else if(F_FILETYPE==2){
                        f = Write_Cmd(C_PFOOTACTION, temp_pf_absval, 0);
                        Read_Status();
                        //							}
                    }
                }
                else if (para == 2)
                { //打板
                    pno = MENU_CURSOR;
                    pnoindex--;
                    g_pf_dis = val;
                    g_updata_pf_valflg = 0;
                    if (g_pf_dis != 0)
                    {
                        g_pf_mode = 1;
                    }
                }
                else if (para == 1)
                { //基准值

                    if (pfootf != 0)
                    { //中压脚在下面
                        if (val > tmpbase)
                        {
                            Write_Cmd(C_PFEMOV, 2, val - tmpbase);
                        }
                        else if (val < tmpbase)
                        {
                            Write_Cmd(C_PFEMOV, 1, tmpbase - val);
                        }
                    }
                    else
                    {
                        f = Write_Cmd(C_PFOOTACTION, tmpbase, 0);
                    }

                    if (tmpbase != g_pfootd.base)
                    {
                        g_pfootd.base = tmpbase; //还原进来时的基准值
                        f = Write_Cmd(C_PFOOTACTION, g_pfootd.base, 0);
                        Read_Status();
                        Write_Cmd(C_PFEST, 1, 2);
                        Read_Status();
                    }
                    if (pnoindex)
                    {
                        pnoindex--;
                        pno = poldno[pnoindex];
                    }
                    else
                    {
                        pno = plastno;
                    }
                }
                else
                {
                    if (pnoindex)
                    {
                        pnoindex--;
                        pno = poldno[pnoindex];
                    }
                    else
                    {
                        pno = plastno;
                    }
                }
                break;
            case KEY_PFOOT_ENTER:
                if (para == 1)
                { //基准值
                    f = Write_Cmd(C_PFOOTACTION, val, 0);
                    if (f == 0)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 15;
                        break;
                    }
                    if (Read_Status() == 0)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 15;
                        break;
                    }
                    else if (DREG[D_CMDSTATUS] != 100)
                    {
                        //#if Debug
                        //printf("DREG[D_CMDSTATUS] = %d \r\n",DREG[D_CMDSTATUS]);
                        //#endif
                        pno = MENU_RWHELP;
                        hleppara = 16;
                        break;
                    }

                    f = Write_Cmd2(C_PFEST, 1, 2, 0);
                    if (f == 0)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 15;
                        poldno[pnoindex] = MENU_PFOOT;
                        pnoindex++;
                        break;
                    }
                    if (Read_Status() == 0)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 15;
                        break;
                    }
                    else if (DREG[D_CMDSTATUS] != 100)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 16;
                        break;
                    }
                    g_pfootd.base = val;
                    if (F_FILETYPE == PAT_MIT)
                    { //三菱
                        U16 checksum = 0;
                        SREG[25] = g_pfootd.base; //中压脚基准值
                        wdt();
                        for (i = 0; i < ((SREG[2] + 0x40) / 2) + ((((U32)(SREG[5]) << 16) + SREG[4]) / 4) * 3; i++)
                        {
                            if (i != 0x20)
                            {
                                checksum += SREG[i];
                            }
                        }
                        SREG[0x20] = checksum;
                    }
                    else if (F_FILETYPE == PAT_SEW)
                    { //兄弟
                        U16 checksum = 0;

                        Bor_BaseAddr((U16 *)SREG, g_patd.pat_len, &BorPFaddr, &BorLFaddr);
                        SREG[BorPFaddr] = g_pfootd.base; //中压脚基准值

                        wdt();
                        for (i = 0; i < g_patd.pat_len / 2; i++)
                        {
                            if (i != 0x05)
                            {
                                checksum += SREG[i];
                            }
                        }
                        SREG[0x05] = checksum;
                    }
                    if (pnoindex)
                    {
                        pnoindex--;
                        pno = poldno[pnoindex];
                    }
                    else
                    {
                        pno = plastno;
                    }
                }
                else if (para == 2)
                { //打板
                    pno = MENU_CURSOR;
                    pnoindex--;
                    g_pf_dis = val;
                    g_updata_pf_valflg = 0;
                    if (g_pf_dis != 0)
                    {
                        g_pf_mode = 1;
                    }
                }
                else if (para == 3)
                { //修改
                    pno = MENU_MODIFY;
                    pnoindex--;
                    g_updata_pf_valflg = 1;

                    if (F_FILETYPE == PAT_MIT)
                    { //三菱
                        g_pf_dis = val - g_pf_moddis;
                        g_pf_dis_modify = val - g_pf_moddis;
                        g_pf_Set_Offest = val - g_pf_moddis;
                        g_pf_modify_mode = 1; //置中压脚修改标志

                        f = Mit_Modify_Data(10);
                        if (pfootf == 0x10)
                        { //中压脚在下面
                            if (val > 0)
                                Write_Cmd(C_PFEMOV, 2, val);
                            else if (val < 0)
                                Write_Cmd(C_PFEMOV, 1, abs(val));
                        }
                        g_pf_moddis = val;
                    }
                    else if (F_FILETYPE == PAT_SEW)
                    { //兄弟
                        U16 Borcmd;
                        U8 speed;
                        S8 Borpooft, Borpfdis;
                        //#if Debug
                        //printf("g_pf_absval = %d	g_pfootd.base = %d ----------\r\n",g_pf_absval,g_pfootd.base);
                        //#endif
                        if (g_IsPfcmd)
                        { //下一针是中压脚,修改下一针
                            g_jog_point++;
                        }

                        Bor_ModPF((U32 *)&g_jog_point, g_pf_absval - g_pfootd.base, g_patd.pat_len);
                        g_modifyflag = 1;
                        g_Tsavetimes = g_savetimes;
                        g_Tsavetimes++;
                        g_savetimes = g_Tsavetimes;
                        BackupSREG(g_Tsavetimes, 0, g_patd.pat_len, 1);

                        Bor_feedInfo(g_jog_point, g_patd.pat_len, &Borcmd, (S16 *)&g_tmpoxpos, (S16 *)&g_tmpoypos, (S16 *)&g_dxpos, (S16 *)&g_dypos, &speed, &Borpooft, &Borpfdis);
                        g_tmpoxpos += g_dxpos;
                        g_tmpoypos += g_dypos;
                        Comm_Move(g_tmpoxpos, g_tmpoypos, 80, MENU_MODIFY, 1, 0);
                    }
                }
                else
                {
                    if (pnoindex)
                    {
                        pnoindex--;
                        pno = poldno[pnoindex];
                    }
                    else
                    {
                        pno = plastno;
                    }
                }
                break;
            case KEY_PFOOT_PINUP:
                Write_Cmd1(C_NEEDLEUP, 0, 0);
                break;
            case KEY_PFOOT_SPFOOT:
                Send_Pfoot(0, MENU_PFOOT, 0);
                break;
            case KEY_PFOOT_UP:
                if (pfootf == 0)
                {
                    viewToast = 1;
                    g_Toast.vIndex = TOAST_MSG31;
                    break;
                }
                if (val < vmax)
                {
                    val += 1;
                    Write_Cmd(C_PFEMOV, 1, 1);
                    if (Read_Status() == 0)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 15;
                        break;
                    }
                    else if (DREG[D_CMDSTATUS] != 100)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 16;
                        break;
                    }
                    g_pf_absval += 1;
                }

                page_flash = 1;
                //dis_updata1 = 1;
                break;
            case KEY_PFOOT_DOWN:
                if (pfootf == 0)
                {
                    viewToast = 1;
                    g_Toast.vIndex = TOAST_MSG31;
                    break;
                }
                if (val > vmin)
                {
                    val -= 1;
                    Write_Cmd(C_PFEMOV, 2, 1);
                    if (Read_Status() == 0)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 15;
                        break;
                    }
                    else if (DREG[D_CMDSTATUS] != 100)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 16;
                        break;
                    }
                    g_pf_absval -= 1;
                }
                page_flash = 1;
                //dis_updata1 = 1;
                break;

            case KEY_PFOOT_RESET:
                if (pfootf == 0)
                {
                    viewToast = 1;
                    g_Toast.vIndex = TOAST_MSG31;
                    break;
                }
                if (para == 1)
                { //基准值
                    if (val != tmpbase)
                    {
                        if (val > tmpbase)
                        {
                            Write_Cmd(C_PFEMOV, 2, val - tmpbase);
                        }
                        else if (val < tmpbase)
                        {
                            Write_Cmd(C_PFEMOV, 1, tmpbase - val);
                        }
                        val = tmpbase;
                        page_flash = 1;
                    }
                }
                else if (para == 2)
                {
                    if (val != g_pf_dis)
                    {
                        if (val > g_pf_dis)
                        {
                            Write_Cmd(C_PFEMOV, 2, val - g_pf_dis);
                        }
                        else if (val < g_pf_dis)
                        {
                            Write_Cmd(C_PFEMOV, 1, g_pf_dis - val);
                        }
                        val = g_pf_dis;
                        page_flash = 1;
                    }
                }
                else
                { //修改
                    if (val > 0)
                        Write_Cmd(C_PFEMOV, 2, val);
                    else if (val < 0)
                        Write_Cmd(C_PFEMOV, 1, abs(val));

                    val = 0;
                    page_flash = 1;
                }
                break;
            }

            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            if (keyon == KEY_PFOOT_SCRNSVR) //不需要显示的按键
            {
            }
            //非常规按键-//绘制颜色文字按键
            else //常规按键
            {
                DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);
            }

            keyon = 0;
            beeponf = 0;
            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
            Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                         SheetPage, rect[0].index[0], rect[0].colorT[0]); //显示回中压脚设置
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if (Timerms > 1000)
        {
            Timerms = 0;
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1)
        {
            ErrorMsg(MENU_PFOOT);
        }
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*begin]**********************************************************
        if (beeponf == 0)
        {
            U32 wTimeTemp;

            ErrorMsg(MENU_PFOOT);
            if (Timer_ms >= 30000) //30720
            {
                Timer_ms = 0;
            }

            if (S_RUN)
            {

                wTimeTemp = Timer_ms >> 5; //Timer_ms/2^5
                if (wTimeTemp != times50ms)
                {
                    times50ms = wTimeTemp;
                }
            }
            else
            {
            }
        }
        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*end]**********************************************************

        // /[压脚上升下降指令*begin]**********************************************************
        if (pfootf != (U16)(S_PFOOT))
        {
            pfootf = (U16)(S_PFOOT);
            DrawButton(keyd[KEY_PFOOT_SPFOOT], (U16 *)(ADD_ICONBMP),
                       (pfootf == 0) ? keybmpind[KEY_PFOOT_SPFOOT].border[0] : keybmpind[KEY_PFOOT_SPFOOT].border[0],
                       (pfootf == 0) ? (keybmpind[KEY_PFOOT_SPFOOT].icon[0]) : (keybmpind[KEY_PFOOT_SPFOOT].icon[2])); //修改   ADD_ICONBMP
        }
        // /[压脚上升下降指令*end]**********************************************************

        // /[针上升下降图标更新*begin]**********************************************************
        if (needlef != (U8)(S_NEEDLE))
        {
            needlef = (U8)S_NEEDLE; //0x20针在上  0 针在下
            DrawButton(keyd[KEY_PFOOT_PINUP], (U16 *)(ADD_ICONBMP), keybmpind[KEY_PFOOT_PINUP].border[0],
                       (needlef == 0x20) ? keybmpind[KEY_PFOOT_PINUP].icon[0] : keybmpind[KEY_PFOOT_PINUP].icon[1]);
        }
        // /[针上升下降图标更新*end]**********************************************************

        // /[当前数据刷新*begin]**********************************************************
        if (page_flash)
        {
            page_flash = 0;
            DrawFillRect(rect[RECT_PFOOT_PROMPT5_STR].xpis, rect[RECT_PFOOT_PROMPT5_STR].ypis,
                         rect[RECT_PFOOT_PROMPT5_STR].xsize, rect[RECT_PFOOT_PROMPT5_STR].ysize,
                         rect[RECT_PFOOT_PROMPT5_STR].colorB[0]);

            DrawDottedRect(rect[RECT_PFOOT_PROMPT5_STR].xpis, rect[RECT_PFOOT_PROMPT5_STR].ypis,
                           rect[RECT_PFOOT_PROMPT5_STR].xsize, rect[RECT_PFOOT_PROMPT5_STR].ysize,
                           rect[RECT_PFOOT_PROMPT5_STR].colorT[0]);

            DrawMFS32P(rect[RECT_PFOOT_PROMPT5_STR].xpis + (rect[RECT_PFOOT_PROMPT5_STR].xsize - 4 * 13) / 2,
                       rect[RECT_PFOOT_PROMPT5_STR].ypis + SAFE_DIST4,
                       val, 4, 1, rect[RECT_PFOOT_PROMPT5_STR].colorT[0]);
        }
        // /[当前数据刷新*end]**********************************************************

        // /[浮窗提示信息*begin]**********************************************************
        if (viewToast)
        {
            viewToast = 0;
            ToastShow1(TYPE_X12 - TYPE_SIZE18 / 2, TYPE_Y12, TYPE_SIZE18, TOAST_SHOW_5S);
        }
        // /[浮窗提示信息*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if (pno != MENU_PFOOT)
        {
            plastno = MENU_PFOOT;
            break;
        }
        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

#define KEY_LINEF_SCRNSVR 1 //1 屏保
#define KEY_LINEF_BACK 2    //2 返回
#define KEY_LINEF_ENTER 3   //3 确认
#define KEY_LINEF_0 4       //4 0
#define KEY_LINEF_1 5       //5 1
#define KEY_LINEF_2 6       //6 2
#define KEY_LINEF_3 7       //7 3
#define KEY_LINEF_4 8       //8 4
#define KEY_LINEF_5 9       //9 5
#define KEY_LINEF_6 10      //10 6
#define KEY_LINEF_7 11      //11 7
#define KEY_LINEF_8 12      //12 8
#define KEY_LINEF_9 13      //13 9
#define KEY_LINEF_UP 14     //14 +1
#define KEY_LINEF_DOWN 15   //15 -1

#define KEY_LINEF1_UP 16   //17 +1
#define KEY_LINEF1_DOWN 17 //18 -1

#define KEY_LINEF_MAX 18

#define LFTITLEBASE 6

#define RECT_LINEF_BASE_TIT 1 //1 基准值-标题
#define RECT_LINEF_BASE_STR 2 //2 基准值-数值
#define RECT_LINEF_NOW_TIT 3  //3 当前值-标题
#define RECT_LINEF_NOW_STR 4  //4 当前值-数值
#define RECT_LINEF1_NO_TIT 5  //5 编号-标题
#define RECT_LINEF1_NO_STR 6  //6 编号-数值

#define RECT_LINEF_MAX 7
// note: para：0：主界面进入修改 1：无 2:打板中修改 3：花样修改中修改
void Menu_Ctlineforce(U16 para)
{

    U32 i /*, j, k*/;
    U8 err = 0, f = 0;
    U16 times50ms = 0xffff;

    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
                                            /****按键相关参数end****/
    /****标志位相关参数begin****/
    U8 page_flash = 1, disupdata = 1; //page_flash:当前值数据更新 ；disupdata:编号更新
    U16 temp_lineforceVal = 0;
    U16 val = 0, vmax = 0, vmin = 0, n = 0;
    U8 tmp_max = 0;
    S8 lf_dis;
    U32 BorPFaddr = 0, BorLFaddr = 0;
    U8 sewflag = 0;
    U16 S_No = 0;
    U8 setLFNo = 0, setLFDat = 20;
    U8 setLFflag = 0;
    U16 setLF = 0;
    U8 lfmodflag[10] = {0};
    /****标志位相关参数end***/

    const U8 keynum = {KEY_LINEF_MAX};
    const KEYPAD keyd[] = {
        {0, 0, 0, 0},
        {0, 0, 128, 32},                     //1 屏保
        {TYPE_X1, TYPE_Y4, KEY_X1, KEY_Y1},  //2 返回
        {TYPE_X11, TYPE_Y4, KEY_X1, KEY_Y1}, //3 确认

        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},                             //4 0
        {TYPE_X15, TYPE_Y13, KEY_X2, KEY_Y2},                                                         //5 1
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13, KEY_X2, KEY_Y2},                                   //6 2
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13, KEY_X2, KEY_Y2},                             //7 3
        {TYPE_X15, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},                                   //8 4
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},             //9 5
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + KEY_Y2 + SAFE_DIST5, KEY_X2, KEY_Y2},       //10 6
        {TYPE_X15, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},                             //11 7
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2},       //12 8
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 2, KEY_X2, KEY_Y2}, //13 9
        {TYPE_X15 + KEY_X2 + SAFE_DIST5, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2},       //14 +1
        {TYPE_X15 + (KEY_X2 + SAFE_DIST5) * 2, TYPE_Y13 + (KEY_Y2 + SAFE_DIST5) * 3, KEY_X2, KEY_Y2}, //15 -1
        {TYPE_X14 + SAFE_DIST6 * 2 + TYPE_SIZE16 + TYPE_SIZE17, TYPE_Y13, KEY_X2, KEY_Y2},            //16 +1
        {TYPE_X14 + SAFE_DIST6 * 3 + TYPE_SIZE16 + TYPE_SIZE17 + KEY_X2, TYPE_Y13, KEY_X2, KEY_Y2},   //17 -1
    };

    const tydDisSrcIndex keybmpind[] = {
        //title_counter
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},  //1 屏保
        {{KEY_Silver}, {0}, {72}, {2, 0, 0, 0}, {0}}, //2 返回
        {{KEY_Silver}, {0}, {71}, {3, 0, 0, 0}, {0}}, //3 确认

        {{KEY_Silver}, {0}, {91}, {0, 0, 0, 0}, {0}},  //4 0
        {{KEY_Silver}, {0}, {92}, {0, 0, 0, 0}, {0}},  //5 1
        {{KEY_Silver}, {0}, {93}, {0, 0, 0, 0}, {0}},  //6 2
        {{KEY_Silver}, {0}, {94}, {0, 0, 0, 0}, {0}},  //7 3
        {{KEY_Silver}, {0}, {95}, {0, 0, 0, 0}, {0}},  //8 4
        {{KEY_Silver}, {0}, {96}, {0, 0, 0, 0}, {0}},  //9 5
        {{KEY_Silver}, {0}, {97}, {0, 0, 0, 0}, {0}},  //10 6
        {{KEY_Silver}, {0}, {98}, {0, 0, 0, 0}, {0}},  //11 7
        {{KEY_Silver}, {0}, {99}, {0, 0, 0, 0}, {0}},  //12 8
        {{KEY_Silver}, {0}, {100}, {0, 0, 0, 0}, {0}}, //13 9

        {{KEY_Silver}, {0}, {199}, {4, 0, 0, 0}, {0}}, //14 +1
        {{KEY_Silver}, {0}, {201}, {5, 0, 0, 0}, {0}}, //15 -1
        {{KEY_Silver}, {0}, {199}, {4, 0, 0, 0}, {0}}, //16 +1
        {{KEY_Silver}, {0}, {201}, {5, 0, 0, 0}, {0}}, //17 -1

    };

    const RECTPAD rect[RECT_LINEF_MAX] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {6}},

        {TYPE_X14, TYPE_Y13, TYPE_SIZE17, TYPE_SIZE8, {Color_KeyBlue}, {Color_White}, {18}},                                                                                                       //1 基准值-标题
        {TYPE_X14 + SAFE_DIST6 + TYPE_SIZE17, TYPE_Y13 + (TYPE_SIZE8 - TYPE_SIZE5) / 2, TYPE_SIZE16, TYPE_SIZE5, {Color_White, Color_DeepSkyBlue}, {Color_Black, Color_Black}, {0}},               //2 基准值-数值
        {TYPE_X14, TYPE_Y13 + TYPE_SIZE14, TYPE_SIZE17, TYPE_SIZE8, {Color_KeyBlue}, {Color_White}, {19}},                                                                                         //3 当前值-标题
        {TYPE_X14 + SAFE_DIST6 + TYPE_SIZE17, TYPE_Y13 + (TYPE_SIZE8 - TYPE_SIZE5) / 2 + TYPE_SIZE14, TYPE_SIZE16, TYPE_SIZE5, {Color_White, Color_DeepSkyBlue}, {Color_Black, Color_Black}, {0}}, //4 当前值-数值

        {TYPE_X14, TYPE_Y13, TYPE_SIZE17, TYPE_SIZE8, {Color_KeyBlue}, {Color_White}, {20}},                                                                                         //5 编号-标题
        {TYPE_X14 + SAFE_DIST6 + TYPE_SIZE17, TYPE_Y13 + (TYPE_SIZE8 - TYPE_SIZE5) / 2, TYPE_SIZE16, TYPE_SIZE5, {Color_White, Color_DeepSkyBlue}, {Color_Black, Color_Black}, {0}}, //6 编号-数值
    };

    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_LINEFORCE); //设置当前文字显示雷人在P1页面，对应41.bin
    InitScreen();
    initViewStatus();
    updateViewStatus();

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    //读取当前张力基准值
    f = Read_D(D_Address[SYS] + SYS_LFORCESET, 1, (U16 *)(&YREG[SYS_LFORCESET]));
    if (f == 0)
    {
        pno = MENU_RWHELP;
        hleppara = 15;
        return;
    }
    g_tdtensiond.base = YREG[SYS_LFORCESET];
    if ((g_tdtensiond.base < LF_ABS_MIN) || (g_tdtensiond.base > LF_ABS_MAX))
    {
        g_tdtensiond.base = 60;
        err = 1;
    }

    //读取当前张力当前值
    f = Read_D(D_Address[SYS] + SYS_LFORCENOW, 1, (U16 *)(&YREG[SYS_LFORCENOW]));
    if (f == 0)
    {
        pno = MENU_RWHELP;
        hleppara = 15;
        return;
    }
    g_tdtensiond.val = YREG[SYS_LFORCENOW];
    if ((g_tdtensiond.val < LF_ABS_MIN) || (g_tdtensiond.val > LF_ABS_MAX))
    {
        g_tdtensiond.val = 60;
        err = 1;
    }

    if (err)
    {
    }

    //画出方框
    for (i = 1; i < RECT_LINEF_MAX - 2; i++)
    {
        DrawFillRect(rect[i].xpis, rect[i].ypis, rect[i].xsize, rect[i].ysize, rect[i].colorB[0]);
    }
    if (para == 0)
    {
        DrawFillRect(rect[RECT_LINEF_NOW_STR].xpis, rect[RECT_LINEF_NOW_STR].ypis,
                     rect[RECT_LINEF_NOW_STR].xsize, rect[RECT_LINEF_NOW_STR].ysize,
                     rect[RECT_LINEF_NOW_STR].colorB[1]);
        DrawDottedRect(rect[RECT_LINEF_NOW_STR].xpis, rect[RECT_LINEF_NOW_STR].ypis,
                       rect[RECT_LINEF_NOW_STR].xsize, rect[RECT_LINEF_NOW_STR].ysize,
                       rect[RECT_LINEF_NOW_STR].colorT[1]);
    }
    else
    {
        DrawFillRect(rect[RECT_LINEF_BASE_STR].xpis, rect[RECT_LINEF_BASE_STR].ypis,
                     rect[RECT_LINEF_BASE_STR].xsize, rect[RECT_LINEF_BASE_STR].ysize,
                     rect[RECT_LINEF_BASE_STR].colorB[1]);
        DrawDottedRect(rect[RECT_LINEF_BASE_STR].xpis, rect[RECT_LINEF_BASE_STR].ypis,
                       rect[RECT_LINEF_BASE_STR].xsize, rect[RECT_LINEF_BASE_STR].ysize,
                       rect[RECT_LINEF_BASE_STR].colorT[1]);
    }
    if (para == 0) //设定基准值
    {
        if (F_FILETYPE == PAT_MIT) //三菱格式
        {
            val = g_tdtensiond.base; // 修改中设置张力值
            vmax = 100;
            vmin = 20;
            sewflag = 0;

            Draw24x24Str(rect[RECT_LINEF_BASE_TIT].xpis + (rect[RECT_LINEF_BASE_TIT].xsize - 13 * strlen((char *)(MEM_TITLE_ADD + (U32)(rect[RECT_LINEF_BASE_TIT].index[0]) * TitleLengthMax))) / 2,
                         rect[RECT_LINEF_BASE_TIT].ypis + TYPE_SIZE1,
                         MEM_TITLE_ADD + (U32)(rect[RECT_LINEF_BASE_TIT].index[0]) * TitleLengthMax,
                         SheetPage, rect[RECT_LINEF_BASE_TIT].index[0], rect[RECT_LINEF_BASE_TIT].colorT[0]); //花样设定值
            Draw24x24Str(rect[RECT_LINEF_NOW_TIT].xpis + (rect[RECT_LINEF_NOW_TIT].xsize - 13 * strlen((char *)(MEM_TITLE_ADD + (U32)(rect[RECT_LINEF_NOW_TIT].index[0]) * TitleLengthMax))) / 2,
                         rect[RECT_LINEF_NOW_TIT].ypis + TYPE_SIZE1,
                         MEM_TITLE_ADD + (U32)(rect[RECT_LINEF_NOW_TIT].index[0]) * TitleLengthMax,
                         SheetPage, rect[RECT_LINEF_NOW_TIT].index[0], rect[RECT_LINEF_BASE_TIT].colorT[0]); //当前张力值

            DrawMFU32(rect[RECT_LINEF_NOW_STR].xpis + (rect[RECT_LINEF_NOW_STR].xsize - 3 * 12) / 2,
                      rect[RECT_LINEF_NOW_STR].ypis + SAFE_DIST4, g_tdtensiond.val, 3, rect[RECT_LINEF_NOW_STR].colorT[0]);
            DrawMFU32(rect[RECT_LINEF_BASE_STR].xpis + (rect[RECT_LINEF_BASE_STR].xsize - 3 * 12) / 2,
                      rect[RECT_LINEF_BASE_STR].ypis + SAFE_DIST4, g_tdtensiond.base, 3, rect[RECT_LINEF_NOW_STR].colorT[0]);
        }
        else //兄弟格式
        {

            Read_D(D_Address[LFPARA], MAXLREG, (U16 *)(&LREG[CLFDAT]));
            Draw24x24Str(rect[RECT_LINEF1_NO_TIT].xpis + (rect[RECT_LINEF1_NO_TIT].xsize - 13 * strlen((char *)(MEM_TITLE_ADD + (U32)(rect[RECT_LINEF1_NO_TIT].index[0]) * TitleLengthMax))) / 2,
                         rect[RECT_LINEF1_NO_TIT].ypis + TYPE_SIZE1,
                         MEM_TITLE_ADD + (U32)(rect[RECT_LINEF1_NO_TIT].index[0]) * TitleLengthMax,
                         SheetPage, rect[RECT_LINEF1_NO_TIT].index[0], rect[RECT_LINEF_BASE_TIT].colorT[0]); //编号
            Draw24x24Str(rect[RECT_LINEF_NOW_TIT].xpis + (rect[RECT_LINEF_NOW_TIT].xsize - 13 * strlen((char *)(MEM_TITLE_ADD + (U32)(rect[RECT_LINEF_NOW_TIT].index[0]) * TitleLengthMax))) / 2,
                         rect[RECT_LINEF_NOW_TIT].ypis + TYPE_SIZE1,
                         MEM_TITLE_ADD + (U32)(rect[RECT_LINEF_NOW_TIT].index[0]) * TitleLengthMax,
                         SheetPage, rect[RECT_LINEF_NOW_TIT].index[0], rect[RECT_LINEF_BASE_TIT].colorT[0]); //当前张力值
            vmax = 100;
            vmin = 2;
            sewflag = 1;
        }
    }
    else if (para == 1) //暂时没用到
    {
    }
    else // 打版中设置张力值
    {
        val = g_tdtensiond.val; // 修改中设置张力值

        if ((para == 2) && (F_FILETYPE == PAT_SEW))
        {
            g_lineforceValSetNow = Bor_CreatCalLF(g_Ctendaddr, g_CtPatLen); //计算夹线器张力值
            val = g_lineforceValSetNow;
        }
        vmax = 100;
        vmin = 20;

        Draw24x24Str(rect[RECT_LINEF_BASE_TIT].xpis + (rect[RECT_LINEF_BASE_TIT].xsize - 13 * strlen((char *)(MEM_TITLE_ADD + (U32)(rect[RECT_LINEF_BASE_TIT].index[0]) * TitleLengthMax))) / 2,
                     rect[RECT_LINEF_BASE_TIT].ypis + TYPE_SIZE1,
                     MEM_TITLE_ADD + (U32)(rect[RECT_LINEF_BASE_TIT].index[0]) * TitleLengthMax,
                     SheetPage, rect[RECT_LINEF_BASE_TIT].index[0], Color_Black); //花样设定值
        Draw24x24Str(rect[RECT_LINEF_NOW_TIT].xpis + (rect[RECT_LINEF_NOW_TIT].xsize - 13 * strlen((char *)(MEM_TITLE_ADD + (U32)(rect[RECT_LINEF_NOW_TIT].index[0]) * TitleLengthMax))) / 2,
                     rect[RECT_LINEF_NOW_TIT].ypis + TYPE_SIZE1,
                     MEM_TITLE_ADD + (U32)(rect[RECT_LINEF_NOW_TIT].index[0]) * TitleLengthMax,
                     SheetPage, rect[RECT_LINEF_NOW_TIT].index[0], Color_Black); //当前张力值

        DrawMFU32(rect[RECT_LINEF_NOW_STR].xpis + (rect[RECT_LINEF_NOW_STR].xsize - 3 * 12) / 2,
                  rect[RECT_LINEF_NOW_STR].ypis + SAFE_DIST4, g_tdtensiond.base, 3, rect[RECT_LINEF_NOW_STR].colorT[0]);
        DrawMFU32(rect[RECT_LINEF_BASE_STR].xpis + (rect[RECT_LINEF_BASE_STR].xsize - 3 * 12) / 2,
                  rect[RECT_LINEF_BASE_STR].ypis + SAFE_DIST4, g_tdtensiond.val, 3, rect[RECT_LINEF_NOW_STR].colorT[0]);
    }
    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                 SheetPage, rect[0].index[0], rect[0].colorT[0]); //面线张力

    //画出按键显示
    for (i = 2; i < KEY_LINEF_MAX; i++)
    {
        //无效按键
        //绘制颜色文字按键
        if (para == 0 && sewflag == 0 && (i == KEY_LINEF1_UP || i == KEY_LINEF1_DOWN)) //特殊情况下不显示按钮
        {
            continue;
        }
        else if (para > 0 && (i == KEY_LINEF1_UP || i == KEY_LINEF1_DOWN)) //特殊情况下不显示按钮
        {
            continue;
        }
        else //常规按钮
        {
            DrawButton(keyd[i], (U16 *)(ADD_ICONBMP), keybmpind[i].border[0], keybmpind[i].icon[0]);
        }
    }
    DrawF16Str(rect[RECT_LINEF_NOW_STR].xpis + rect[RECT_LINEF_NOW_STR].xsize + SAFE_DIST5,
               rect[RECT_LINEF_NOW_STR].ypis + SAFE_DIST1, "(", rect[RECT_LINEF_NOW_STR].colorT[0]);
    DrawFU32Z(rect[RECT_LINEF_NOW_STR].xpis + rect[RECT_LINEF_NOW_STR].xsize + SAFE_DIST5 + TYPE_SIZE20,
              rect[RECT_LINEF_NOW_STR].ypis + SAFE_DIST1,
              vmin, 2, rect[RECT_LINEF_NOW_STR].colorT[0]);
    DrawF16Str(rect[RECT_LINEF_NOW_STR].xpis + rect[RECT_LINEF_NOW_STR].xsize + SAFE_DIST5 + TYPE_SIZE20 * 3,
               rect[RECT_LINEF_NOW_STR].ypis + SAFE_DIST1, "-", rect[RECT_LINEF_NOW_STR].colorT[0]);
    DrawFU32Z(rect[RECT_LINEF_NOW_STR].xpis + rect[RECT_LINEF_NOW_STR].xsize + SAFE_DIST5 + TYPE_SIZE20 * 4,
              rect[RECT_LINEF_NOW_STR].ypis + SAFE_DIST1,
              vmax, 3, rect[RECT_LINEF_NOW_STR].colorT[0]);
    DrawF16Str(rect[RECT_LINEF_NOW_STR].xpis + rect[RECT_LINEF_NOW_STR].xsize + SAFE_DIST5 + TYPE_SIZE20 * 7,
               rect[RECT_LINEF_NOW_STR].ypis + SAFE_DIST1, ")", rect[RECT_LINEF_NOW_STR].colorT[0]);

    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************
    ViewPage(usepageno);                                                        //设置显示缓存
    if ((poldno[pnoindex - 1] == MENU_P1) || (poldno[pnoindex - 1] == MENU_P2)) //从主界面进来，发停止运行命令
    {
        E_RUNEN();
        Write_Cmd(C_WRITESTATUS, YREG[SYS_ENABLE], SYS_ENABLE);
    }
    if (vmax > 99)
        tmp_max = 100;
    else
        tmp_max = 10;
    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************

    Timer_ms = 30720; //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {

        keydata = get_keydata((KEYPAD *)keyd, keynum, 0); //获取键值

        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理
        if ((keyon == KEY_LINEF1_UP) || (keyon == KEY_LINEF1_DOWN))
        {
            if (sewflag == 0)
            {
                keydata = 0;
            }
            if (para > 0)
            {
                keydata = 0;
            }
        }

        //无效按键

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            if ((keyon == KEY_LINEF_UP) || (keyon == KEY_LINEF_DOWN)) //带有连续按键功能的按键
            {
            }
            else if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata > USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {
            //特定情况下不生效按键

            if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时
            {
                keyon = keydata;
                if (keyon == KEY_LINEF_SCRNSVR) //无按键特效
                {
                }
                //非常规按键-//绘制颜色文字按键
                else
                {
                    DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);
                }
                Times = 0;
                delay = KEYDT; //按键防抖次数
            }
            else if (keyon != keydata) //已有按键按下，不处理新按键信息
            {
                keydata = 0;
            }

            if (Times > delay) //按键防抖
            {
                if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                {
                    beeponf = 1;

                    if (g_keyBellT) //按键时蜂鸣器发声时间
                        Beep_On(g_keyBellT);

                    switch (keyon) //按键按下标题提示语显示
                    {
                    case KEY_LINEF_0:
                    case KEY_LINEF_1:
                    case KEY_LINEF_2:
                    case KEY_LINEF_3:
                    case KEY_LINEF_4:
                    case KEY_LINEF_5:
                    case KEY_LINEF_6:
                    case KEY_LINEF_7:
                    case KEY_LINEF_8:
                    case KEY_LINEF_9:
                        BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
                        DrawMFU32(TITLE_XPOS_C2, SAFE_DIST4, keyon - KEY_LINEF_0, 1, rect[0].colorT[0]);
                        break;
                    default:
                        DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                        break;
                    }
                    delay = KEYFT;
                }
                else if (beeponf == 1) //第二次进入
                {
                    beeponf = 2;
                    if ((keyon == KEY_LINEF_UP) || (keyon == KEY_LINEF_DOWN)) //带有长按连续功能按键的功能
                    {
                        delay = DELAY_MOVE;
                    }
                    else
                        delay = KEYNT;
                }
                else if (beeponf < 20)
                {
                    beeponf++;
                }

                if ((keyon == KEY_LINEF_UP) || (keyon == KEY_LINEF_DOWN)) //带有长按连续功能按键的功能
                {
                    keyoff = keyon;
                    key_on_flag1 = 1;
                }
                Times = 0; //当前
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            if ((keyoff >= KEY_LINEF_0) && (keyoff <= KEY_LINEF_9))
            {
                if (tmp_max > 1)
                    val = (val % tmp_max) * 10 + keyoff - KEY_LINEF_0;
                else
                    val = keyoff - KEY_LINEF_0;
                if (val > vmax)
                {
                    if (tmp_max > 1)
                        val = val % tmp_max;
                    else if (vmax)
                        val = val % vmax;
                    else
                        val = 0;
                }
                page_flash = 1;
            }
            else
            {
                switch (keyoff)
                {
                case KEY_LINEF_SCRNSVR:
                    pno = MENU_SCRNSVR;
                    break;
                case KEY_LINEF_BACK:
                    if (para == 3)
                    {
                        pno = MENU_MODIFYADD;
                    }
                    else if (para == 2)
                    {
                        pno = MENU_CURSOR;
                        pnoindex--;
                    }
                    else
                    {
                        if (pnoindex)
                        {
                            pnoindex--;
                            pno = poldno[pnoindex];
                        }
                        else
                        {
                            pno = plastno;
                        }
                    }
                    break;
                case KEY_LINEF_ENTER:
                    temp_lineforceVal = val;
                    if (temp_lineforceVal > /*100*/ vmax)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 88;
                        poldno[pnoindex] = MENU_LINEFORCE;
                        pnoindex++;
                        break;
                    }
                    if (temp_lineforceVal < /*20*/ vmin)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 89;
                        poldno[pnoindex] = MENU_LINEFORCE;
                        pnoindex++;
                        break;
                    }

                    if (para == 2)
                    { //打板设置张力值
                        if (F_FILETYPE == PAT_MIT)
                        {
                            if (temp_lineforceVal != g_lineforceValSetNow)
                            {
                                lf_dis = (S8)(temp_lineforceVal) - (S8)(g_lineforceValSetNow);
                                g_lineforceValSetNow = temp_lineforceVal;

                                SREG[g_draw_p++] = 0x3a01;
                                SREG[g_draw_p++] = (U8)(lf_dis);
                                SREG[g_draw_p++] = 0;
                                SREG[g_draw_p++] = 0;

                                SREG[g_pat_p++] = 0x3a;
                                SREG[g_pat_p++] = (U8)(lf_dis);

                                SREG[g_line_p++] = g_line_sum++;

                                g_feedc = g_line_p - (SREG[2] + 0x40) / 2; //当前已打版出的针数
                                g_feedsum = g_feedc;
                                g_modifyflag |= 0x01;
                            }
                        }
                        else if (F_FILETYPE == PAT_SEW)
                        {
                            if (temp_lineforceVal != g_lineforceValSetNow)
                            {
                                g_lineforceValSetNow = temp_lineforceVal;
                                g_Ctstaddr = g_Ctendaddr;
                                Bor_doLF((U16 *)SREG, (U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, g_lineforceValSetNow, &g_patd.feed_sum);
                                Bor_CreatBack((U16 *)&g_Ctsavetimes, g_Ctstaddr, g_Ctendaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);
                                g_feedsum = g_patd.feed_sum;
                                g_feedc = g_patd.feed_sum;
                            }
                        }

                        pno = MENU_CURSOR;
                        pnoindex--;
                    }
                    else if (para == 3)
                    { //修改设定张力值
                        if (F_FILETYPE == PAT_MIT)
                        { //三菱
                            if (temp_lineforceVal != g_lineforceValSetNow)
                            {
                                g_lf_dis_modify = (S8)(temp_lineforceVal) - (S8)(g_lineforceValSetNow);
                                g_lineforceValSetNow = temp_lineforceVal;
                                f = Mit_Modify_Data(11);
                                if (f == 0)
                                {
                                }
                            }
                        }
                        else if (F_FILETYPE == PAT_SEW)
                        { //兄弟
                            Bor_ModLF(g_jog_point, temp_lineforceVal, g_patd.pat_len);
                            g_modifyflag = 1;
                            g_Tsavetimes = g_savetimes;
                            g_Tsavetimes++;
                            g_savetimes = g_Tsavetimes;
                            BackupSREG(g_Tsavetimes, 0, g_patd.pat_len, 1);
                        }

                        pno = MENU_MODIFY;
                        pnoindex--;
                    }
                    else
                    { //基准值
                        if (sewflag)
                        { //sew格式
                            //printf("S_No = %d  LREG[LFNOMAX] = %d setLFflag = %d \r\n",S_No,LREG[LFNOMAX],setLFflag);
                            if ((LREG[LFNOMAX] > 0 && S_No == LREG[LFNOMAX]) || (LREG[LFNOMAX] == 0 && setLFflag))
                            { //全部设定
                                //printf("----------\r\n");
                                if (Write_Cmd(C_LF_SET, 10, val) == 0)
                                {
                                    pno = MENU_RWHELP;
                                    hleppara = 16;
                                    poldno[pnoindex++] = MENU_LINEFORCE;
                                    break;
                                }
                                else
                                {
                                    if (Read_Status() == 0)
                                    {
                                        pno = MENU_RWHELP;
                                        hleppara = 15;
                                        poldno[pnoindex++] = MENU_LINEFORCE;
                                        break;
                                    }
                                    else if (DREG[D_CMDSTATUS] != 100)
                                    {
                                        pno = MENU_RWHELP;
                                        hleppara = 16;
                                        poldno[pnoindex++] = MENU_LINEFORCE;
                                        break;
                                    }
                                }
                            }
                            else
                            { //单个逐一设定
                                for (i = 0; i < 10; i++)
                                {
                                    if (lfmodflag[i])
                                    {
                                        if (Write_Cmd(C_LF_SET, i, LREG[LFDAT0 + i]) == 0)
                                        {
                                            pno = MENU_RWHELP;
                                            hleppara = 16;
                                            poldno[pnoindex++] = MENU_LINEFORCE;
                                            return;
                                        }
                                        else
                                        {
                                            if (Read_Status() == 0)
                                            {
                                                pno = MENU_RWHELP;
                                                hleppara = 15;
                                                poldno[pnoindex++] = MENU_LINEFORCE;
                                                return;
                                            }
                                            else if (DREG[D_CMDSTATUS] != 100)
                                            {
                                                pno = MENU_RWHELP;
                                                hleppara = 16;
                                                poldno[pnoindex++] = MENU_LINEFORCE;
                                                return;
                                            }
                                        }
                                    }
                                }
                            }
                            Read_D(D_Address[LFPARA], MAXLREG, (U16 *)(&LREG[CLFDAT]));
                            if (pnoindex)
                            {
                                pnoindex--;
                                pno = poldno[pnoindex];
                            }
                            else
                            {
                                pno = plastno;
                            }

                            break;
                        }

                        if (g_lineforceValSet != temp_lineforceVal)
                        {
                            g_lineforceValSet = temp_lineforceVal;
                            f = Write_Cmd2(C_SETLFORCE, temp_lineforceVal, 0, 0); //向主板发送保存面线张力基准值命令
                            for (n = 0; n < RDTIMES; n++)
                            {
                                Read_D(D_Address[DISP] + D_CMDSTATUS, 1, (U16 *)(&DREG[D_CMDSTATUS])); // 读状态
                                if ((DREG[D_CMDSTATUS]) == 100)
                                    break;
                                DelayMs(WAITTIME);
                            }
                        }

                        g_tdtensiond.base = temp_lineforceVal;
                        if (F_FILETYPE == PAT_MIT)
                        { //三菱
                            U16 checksum = 0;

                            SREG[10] = g_tdtensiond.base; //张力基准值
                            wdt();
                            for (i = 0; i < ((SREG[2] + 0x40) / 2) + ((((U32)(SREG[5]) << 16) + SREG[4]) / 4) * 3; i++)
                            {
                                if (i != 0x20)
                                {
                                    checksum += SREG[i];
                                }
                            }
                            SREG[0x20] = checksum;
                        }
                        else if (F_FILETYPE == PAT_SEW)
                        { //兄弟
                            U16 checksum = 0;

                            Bor_BaseAddr((U16 *)SREG, g_patd.pat_len, &BorPFaddr, &BorLFaddr);
                            SREG[BorLFaddr] = g_tdtensiond.base; //中压脚基准值

                            wdt();
                            for (i = 0; i < g_patd.pat_len / 2; i++)
                            {
                                if (i != 0x05)
                                {
                                    checksum += SREG[i];
                                }
                            }
                            SREG[0x05] = checksum;
                        }
                        if (pnoindex)
                        {
                            pnoindex--;
                            pno = poldno[pnoindex];
                        }
                        else
                        {
                            pno = plastno;
                        }
                    }
                    break;
                case KEY_LINEF_UP:
                    if (val < vmax)
                        val++;
                    page_flash = 1;
                    break;
                case KEY_LINEF_DOWN:
                    if (val > vmin)
                        val--;
                    page_flash = 1;
                    break;

                case KEY_LINEF1_UP:
                    if (LREG[LFNOMAX] > 0)
                    {
                        if (S_No < LREG[LFNOMAX])
                        {
                            S_No++;
                        }
                        else
                        {
                            S_No = 0;
                        }
                        disupdata = 1;
                    }
                    else
                    {
                        if (setLFflag)
                            setLFflag = 0;
                        else
                            setLFflag = 1;
                        disupdata = 1;
                    }
                    break;

                case KEY_LINEF1_DOWN:
                    if (LREG[LFNOMAX] > 0)
                    {
                        if (S_No > 0)
                        {
                            S_No--;
                        }
                        else
                        {
                            S_No = LREG[LFNOMAX];
                        }
                        disupdata = 1;
                    }
                    else
                    {
                        if (setLFflag)
                            setLFflag = 0;
                        else
                            setLFflag = 1;
                        disupdata = 1;
                    }
                    break;
                }
            }
            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {

            if (keyon == KEY_LINEF_SCRNSVR) //不需要显示的按键
            {
            }
            //非常规按键-//绘制颜色文字按键
            else //常规按键
            {
                DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);
            }

            keyon = 0;
            beeponf = 0;
            BmpFillRect(TITLE_XPOS, SAFE_DIST4, LCD_TIME_WIDTH_LIMIT - TITLE_XPOS, TYPE_SIZE4);
            Draw24x24Str(TITLE_XPOS_C2, SAFE_DIST4, MEM_TITLE_ADD + (U32)(rect[0].index[0]) * TitleLengthMax,
                         SheetPage, rect[0].index[0], rect[0].colorT[0]); //显示回面线张力
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if (Timerms > 1000)
        {
            Timerms = 0;
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1)
        {
            // ErrorMsg(MENU_LINEFORCE);
        }
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*begin]**********************************************************
        if (beeponf == 0)
        {
            U32 wTimeTemp;

            // ErrorMsg(MENU_LINEFORCE);
            if (Timer_ms >= 30000) //30720
            {
                Timer_ms = 0;
            }

            if (S_RUN)
            {

                wTimeTemp = Timer_ms >> 5; //Timer_ms/2^5
                if (wTimeTemp != times50ms)
                {
                    times50ms = wTimeTemp;
                }
            }
            else
            {
            }
        }
        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*end]**********************************************************

        // /[编号更新*begin]**********************************************************
        if (disupdata)
        {
            disupdata = 0;
            if (para == 0 && sewflag == 1)
            {

                DrawFillRect(rect[RECT_LINEF1_NO_STR].xpis, rect[RECT_LINEF1_NO_STR].ypis,
                             rect[RECT_LINEF1_NO_STR].xsize, rect[RECT_LINEF1_NO_STR].ysize,
                             rect[RECT_LINEF1_NO_STR].colorB[0]);

                if (LREG[LFNOMAX] > 0)
                {
                    if (S_No == LREG[LFNOMAX])
                    {
                        Draw24X24FStr(rect[RECT_LINEF1_NO_STR].xpis + (rect[RECT_LINEF1_NO_STR].xsize - 12 * 3) / 2,
                                      rect[RECT_LINEF1_NO_STR].ypis + SAFE_DIST4,
                                      "ALL", rect[i].index[0]);
                        val = 0;
                    }
                    else
                    {
                        setLF = getModLfNo(S_No);
                        setLFNo = (setLF >> 8);
                        setLFDat = (setLF & 0xff);

                        DrawMFU32(rect[RECT_LINEF1_NO_STR].xpis + (rect[RECT_LINEF1_NO_STR].xsize - 12 * 2) / 2 - 12,
                                  rect[RECT_LINEF1_NO_STR].ypis + SAFE_DIST4, setLFNo, 1, rect[RECT_LINEF1_NO_STR].colorT[0]);
                        Draw24X24FStr(rect[RECT_LINEF1_NO_STR].xpis + (rect[RECT_LINEF1_NO_STR].xsize - 12 * 2) / 2,
                                      rect[RECT_LINEF1_NO_STR].ypis + SAFE_DIST4,
                                      "/T", rect[i].colorT[0]);
                        DrawMFU32(rect[RECT_LINEF1_NO_STR].xpis + (rect[RECT_LINEF1_NO_STR].xsize - 12 * 2) / 2 + 12 * 2,
                                  rect[RECT_LINEF1_NO_STR].ypis + SAFE_DIST4, setLFDat, 1, rect[RECT_LINEF1_NO_STR].colorT[0]);

                        // DrawLFU32Z(280, 176, setLFNo, 1, Color_White);
                        // Draw32X32FStr(300, 176, "/T", Color_White);
                        // DrawLFU32Z(340, 176, setLFDat, 1, Color_White);

                        val = LREG[LFDAT0 + setLFNo];
                        if (val < 2 || val > 100)
                            val = 60;
                    }
                }
                else
                {
                    if (setLFflag)
                    {
                        Draw24X24FStr(rect[RECT_LINEF1_NO_STR].xpis + (rect[RECT_LINEF1_NO_STR].xsize - 12 * 3) / 2,
                                      rect[RECT_LINEF1_NO_STR].ypis + SAFE_DIST4,
                                      "ALL", rect[i].index[0]);
                        val = 0;
                    }
                    else
                    {
                        setLF = getModLfNo(S_No);
                        setLFNo = (setLF >> 8);
                        setLFDat = (setLF & 0xff);

                        // DrawLFU32Z(280, 176, setLFNo, 1, Color_White);
                        // Draw32X32FStr(300, 176, "/T", Color_White);
                        // DrawLFU32Z(340, 176, setLFDat, 1, Color_White);

                        DrawMFU32(rect[RECT_LINEF1_NO_STR].xpis + (rect[RECT_LINEF1_NO_STR].xsize - 12 * 2) / 2 - 12,
                                  rect[RECT_LINEF1_NO_STR].ypis + SAFE_DIST4, setLFNo, 1, rect[RECT_LINEF1_NO_STR].colorT[0]);
                        Draw24X24FStr(rect[RECT_LINEF1_NO_STR].xpis + (rect[RECT_LINEF1_NO_STR].xsize - 12 * 2) / 2,
                                      rect[RECT_LINEF1_NO_STR].ypis + SAFE_DIST4,
                                      "/T", rect[i].colorT[0]);
                        DrawMFU32(rect[RECT_LINEF1_NO_STR].xpis + (rect[RECT_LINEF1_NO_STR].xsize - 12 * 2) / 2 + 12 * 2,
                                  rect[RECT_LINEF1_NO_STR].ypis + SAFE_DIST4, setLFDat, 1, rect[RECT_LINEF1_NO_STR].colorT[0]);

                        val = LREG[LFDAT0 + setLFNo];
                        if (val < 2 || val > 100)
                            val = 60;
                    }
                }
            }
            page_flash = 1;
        }
        // /[编号更新*end]**********************************************************

        // /[当前数据刷新*begin]**********************************************************
        if (page_flash)
        {
            page_flash = 0;

            if (para == 0)
            {
                DrawFillRect(rect[RECT_LINEF_NOW_STR].xpis, rect[RECT_LINEF_NOW_STR].ypis,
                             rect[RECT_LINEF_NOW_STR].xsize, rect[RECT_LINEF_NOW_STR].ysize,
                             rect[RECT_LINEF_NOW_STR].colorB[1]);
                DrawDottedRect(rect[RECT_LINEF_NOW_STR].xpis, rect[RECT_LINEF_NOW_STR].ypis,
                               rect[RECT_LINEF_NOW_STR].xsize, rect[RECT_LINEF_NOW_STR].ysize,
                               rect[RECT_LINEF_NOW_STR].colorT[1]);
                DrawMFU32(rect[RECT_LINEF_NOW_STR].xpis + (rect[RECT_LINEF_NOW_STR].xsize - 3 * 12) / 2,
                          rect[RECT_LINEF_NOW_STR].ypis + SAFE_DIST4, val, 3, rect[RECT_LINEF_NOW_STR].colorT[1]);
            }
            else
            {
                DrawFillRect(rect[RECT_LINEF_BASE_STR].xpis, rect[RECT_LINEF_BASE_STR].ypis,
                             rect[RECT_LINEF_BASE_STR].xsize, rect[RECT_LINEF_BASE_STR].ysize,
                             rect[RECT_LINEF_BASE_STR].colorB[1]);
                DrawDottedRect(rect[RECT_LINEF_BASE_STR].xpis, rect[RECT_LINEF_BASE_STR].ypis,
                               rect[RECT_LINEF_BASE_STR].xsize, rect[RECT_LINEF_BASE_STR].ysize,
                               rect[RECT_LINEF_BASE_STR].colorT[1]);
                DrawMFU32(rect[RECT_LINEF_BASE_STR].xpis + (rect[RECT_LINEF_BASE_STR].xsize - 3 * 12) / 2,
                          rect[RECT_LINEF_BASE_STR].ypis + SAFE_DIST4, val, 3, rect[RECT_LINEF_BASE_STR].colorT[1]);
            }

            if (sewflag)
            {
                if ((LREG[LFNOMAX] > 0 && S_No < LREG[LFNOMAX]) || (LREG[LFNOMAX] == 0 && setLFflag == 0))
                {
                    LREG[LFDAT0 + setLFNo] = val;
                }
                if (setLFNo < 10)
                    lfmodflag[setLFNo] = 1;
            }
        }
        // /[当前数据刷新*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if (pno != MENU_LINEFORCE)
        {
            plastno = MENU_LINEFORCE;
            break;
        }
        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}

#define KEY_INHELP_EXIT 1  //1 退出
#define KEY_INHELP_ENTER 2 //2 确认
#define KEY_INHELP_ORG 3   //3 回到原点
#define KEY_INHELP_SECT 4  //4 选择点
#define KEY_INHELP_TEST 5  //5 测试 无用

#define KEY_INHELP_MAX 5

#define RECT_INHELP_BG 1   //1 背景
#define RECT_INHELP_BMP1 2 //2 图片1
#define RECT_INHELP_BMP2 3 //3 图片2
#define RECT_INHELP_STR1 4 //4 文字索引1
#define RECT_INHELP_STR2 5 //5 文字索引2

#define RECT_RWHELP_MAX 6

void Menu_CtInHelp(U16 para)
{

    /****按键相关参数begin****/
    U8 beeponf = 0;                         //蜂鸣器 启动标志位
    U16 delay = 0;                          //按键执行延迟的设定时间，与Times进行比较
    U32 keyon = 0, keyoff = 0, keydata = 0; //keyon按键按下，keyoff按键松开，keydata当前按键信息
    /****按键相关参数end****/

    /****标志位相关参数begin****/
    U32 i;
    U8 btn_en;
    U8 flag = 0, f = 0;
    U32 add1, add2, ii, kk;
    U32 dat, dat2;
    U32 n, m;
    U16 checksum;
    U32 ERROR_MSG;
    U32 ERROR_LEN;
    U32 addr1 = 0;
    U8 exflag;
    U32 ctBackSaddr = 0, ctBackEaddr = 0;
    U8 linemaxdisplay = 32; //一行显示最大字符数
    S16 redx = 0, redy = 0;
    U16 Err_MSG1_Sheet1 = 48;
    U16 Err_MSG1_Sheet2 = 49;
    U16 Borcmd;
    S16 tmpxdat1, tmpydat1;
    S8 Borpooft, Borpfdis;
    U16 *BSREG;
    U8 errflag = 0;
    PINMSG mitPinmsg = {0};
    U16 tpoint_num = 0 /*, tfeedsum = 0*/, tfeed = 0, tfeedc /*, bfeedc*/;
    //	U8 isHome =0;
    U32 tmpCreatstaddr, tmpCreatstaddr1;
    U32 CtPatLen, Ctendaddr, Ctstaddr;
    U16 cfeed, tfeed_sum;
    S16 cpx = 0, cpy = 0, cpx0 = 0, cpy0 = 0;
    const U16 vaddr1 = TYPE_Y2 + SAFE_DIST6 + SAFE_DIST4,
              vaddr2 = TYPE_Y2 + SAFE_DIST6 * 3 + TYPE_SIZE13 + SAFE_DIST4;
    const U16 disPosStr_X = TYPE_X19 + SAFE_DIST4;
    const U8 l1 = 3, l2 = 5;
    U8 mut = 2;

    const U16 vTestColor = Color_White;
    //const U16 bgColor = Color_Blue;
    /****标志位相关参数end***/

    const U8 keynum = {KEY_INHELP_MAX};
    const KEYPAD keyd[] = {
        {0, 0, 0, 0},

        {TYPE_X33, TYPE_Y30, KEY_X1, KEY_Y1}, //1 返回
        {TYPE_X34, TYPE_Y30, KEY_X1, KEY_Y1}, //2 确认
        {TYPE_X34, TYPE_Y30, KEY_X1, KEY_Y1}, //3 回原点
        {TYPE_X6, TYPE_Y30, KEY_X1, KEY_Y1},  //4 选择点
        {0, 0, 0, 0},                         //5 测试 无用

    };

    const tydDisSrcIndex keybmpind[] = {
        {{KEY_Silver}, {0}, {0}, {0, 0, 0, 0}, {0}},
        {{KEY_Silver}, {0}, {72, 0, 0, Color_Gray}, {0, 0, 0, 0}, {0}},  //1 返回
        {{KEY_Silver}, {0}, {71, 70, 0, Color_Gray}, {0, 0, 0, 0}, {0}}, //2 确认
        {{KEY_Silver}, {0}, {3, 0, 0, Color_Gray}, {0, 0, 0, 0}, {0}},   //3 回原点
        {{KEY_Silver}, {0}, {363, 0, 0, Color_Gray}, {0, 0, 0, 0}, {0}}, //4 选择点

    };

    const RECTPAD rect[] = {
        //方框
        {0, 0, 0, 0, {Color_Black}, {Color_White}, {0}},

        {TYPE_X18, TYPE_Y2, 700, TYPE_SIZE24, {Color_Gray, Color_Black}, {Color_White}, {0}},                                        //1 背景
        {TYPE_X18 + SAFE_DIST6, TYPE_Y2 + SAFE_DIST6, TYPE_SIZE12, TYPE_SIZE12, {Color_Blue}, {Color_White}, {68}},                  //2 图片1
        {TYPE_X18 + SAFE_DIST6, TYPE_Y2 + SAFE_DIST6 * 3 + TYPE_SIZE13, TYPE_SIZE12, TYPE_SIZE12, {Color_Blue}, {Color_White}, {0}}, //3 图片2
        {TYPE_X19, TYPE_Y2 + SAFE_DIST6, 560, TYPE_SIZE13, {Color_Blue}, {Color_White}, {0}},                                        //4 文字索引1
        {TYPE_X19, TYPE_Y2 + SAFE_DIST6 * 3 + TYPE_SIZE13, 560, 160, {Color_Blue}, {Color_White}, {0}},                              //5 文字索引2
    };

    // /[语言显示相关文件路径设置与页面初始化*begin]************************************************
    SetLanguage(MENU_INHELP); //设置当前文字显示雷人在P1页面，对应40.bin
    // InitScreen();
    initViewStatus();
    updateViewStatus();

    if (P_LAN)
    {
        UADD_ERROR_MSG = ADD_ERROR_MSG1_E;
        UADD_PROG_MSG7 = ADD_ERROR_MSG2_E;
        ERROR_MSG = 40;  //450 * TIT_MAXLENGTH_E;
        ERROR_LEN = 115; //TIT_MAXLENGTH_E;
    }
    else
    {
        UADD_ERROR_MSG = ADD_ERROR_MSG1;
        UADD_PROG_MSG7 = ADD_ERROR_MSG2;
        ERROR_MSG = 24; //30;
        ERROR_LEN = 74; //105;
    }

    dat = para % 10;
    g_logorun = 50;

    // /[语言显示相关文件路径设置与页面初始化*end]************************************************

    // /[显示相关标志位信息读取*begin]**********************************************************
    g_savemodify = 0;

#if MOVEUNIT == 1
    mut = 1;
#endif
    // /[显示相关标志位信息读取*end]**********************************************************

    // /[绘制初始显示页面*begin]**************************************************************
    DrawColor_Gray1(0, 0, LCD_WIDTH, LCD_HEIGHT);
    DrawDFrame(rect[RECT_INHELP_BG].xpis + SAFE_DIST2, rect[RECT_INHELP_BG].ypis + SAFE_DIST2,
               rect[RECT_INHELP_BG].xsize, rect[RECT_INHELP_BG].ysize, SAFE_DIST3, rect[RECT_INHELP_BG].colorB[1]);
    DrawFillRect(rect[RECT_INHELP_BG].xpis, rect[RECT_INHELP_BG].ypis,
                 rect[RECT_INHELP_BG].xsize, rect[RECT_INHELP_BG].ysize, rect[RECT_INHELP_BG].colorB[0]);

    DrawFPBMPNEW(rect[RECT_INHELP_BMP1].xpis, rect[RECT_INHELP_BMP1].ypis,
                 64, 58, MEM_BMPGIF, rect[RECT_INHELP_BMP1].index[0]);
    g_logorun = 100;
    DrawFillRect(rect[RECT_INHELP_STR1].xpis, rect[RECT_INHELP_STR1].ypis,
                 rect[RECT_INHELP_STR1].xsize, rect[RECT_INHELP_STR1].ysize,
                 rect[RECT_INHELP_STR1].colorB[0]);
    DrawFillRect(rect[RECT_INHELP_STR2].xpis, rect[RECT_INHELP_STR2].ypis,
                 rect[RECT_INHELP_STR2].xsize, rect[RECT_INHELP_STR2].ysize,
                 rect[RECT_INHELP_STR2].colorB[0]);

    switch (dat)
    {
    case 0: //回原点
        Draw24x24MulStr(disPosStr_X, vaddr1,
                        (uint *)(USE_ERROR_MSG + ERROR_LEN * 25), linemaxdisplay, Err_MSG1_Sheet1, 25, l1, vTestColor);
        Draw24x24MulStr(disPosStr_X, vaddr2,
                        (uint *)(USE_ERROR_MSG + ERROR_LEN * 25 + ERROR_MSG), linemaxdisplay, Err_MSG1_Sheet2, 25, l2, vTestColor);
        if ((plastno == MENU_CURSOR) || (plastno == MENU_CONVERT) || (plastno == MENU_MODIFY))
            flag = 0;
        else
        {
            flag = 1;
        }
        btn_en = 4; // 原点
        if ((plastno == MENU_CONVERT) || (plastno == MENU_MODIFY))
            btn_en += 2;
        break;

    case 1: // EXIT
        btn_en = 2;
        if (((g_input_method == 4) || (g_input_method == 5)) && (g_dxpos == 0) && (g_dypos == 0))
        {
            Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27), linemaxdisplay, Err_MSG1_Sheet1, 27, l1, vTestColor);             //输入坐标错误!
            Draw24x24MulStr(disPosStr_X, vaddr2, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27 + ERROR_MSG), linemaxdisplay, Err_MSG1_Sheet2, 27, l2, vTestColor); //坐标超出加工范围!
            flag = 0;
        }
        else if ((g_point_num < 3) && (g_input_method == 6))
        {
            Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 109), linemaxdisplay, Err_MSG1_Sheet1, 109, l1, vTestColor); //输入坐标少于三个!
            flag = 0;
        }
        else if ((g_point_num > SPLINESUM_MAX) && ((g_dxpos != 0) || (g_dypos != 0)))
        {
            Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 110), linemaxdisplay, Err_MSG1_Sheet1, 110, l1, vTestColor); //坐标超过三百个!
            flag = 0;
        }
        else if (g_DrawOcclude == 1)
        {
            Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 111), linemaxdisplay, Err_MSG1_Sheet1, 111, l1, vTestColor);             //不能指定多重重针
            Draw24x24MulStr(disPosStr_X, vaddr2, (uint *)(USE_ERROR_MSG + ERROR_LEN * 111 + ERROR_MSG), linemaxdisplay, Err_MSG1_Sheet2, 111, l2, vTestColor); //重叠重针只可用于圆形,曲线,多边形等封闭图形
            flag = 0;
            btn_en = 1;
            g_DrawOcclude = 2;
        }
        else
        {
            if (g_input_method == 3)
                Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 105), linemaxdisplay, Err_MSG1_Sheet1, 25, l1, vTestColor); //可以制作折线资料吗?
            else if (g_input_method == 4)
                Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 103), linemaxdisplay, Err_MSG1_Sheet1, 103, l1, vTestColor); //可以制作圆资料吗?
            else if (g_input_method == 5)
                Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 102), linemaxdisplay, Err_MSG1_Sheet1, 102, l1, vTestColor); //可以制作圆弧资料吗?
            else if (g_input_method == 6)
                Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 104), linemaxdisplay, Err_MSG1_Sheet1, 104, l1, vTestColor); //可以制作曲线资料吗?

            flag = 1;
            if (g_input_method == 6)
            {
                flag = 2;
                btn_en += 16;
            }
        }
        // 确定
        if (flag)
            btn_en += 1;
        break;

    case 2:                                                                                                                                              // 坐标超出加工范围!
        Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27), linemaxdisplay, Err_MSG1_Sheet1, 27, l1, vTestColor);             //输入坐标错误!
        Draw24x24MulStr(disPosStr_X, vaddr2, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27 + ERROR_MSG), linemaxdisplay, Err_MSG1_Sheet1, 27, l2, vTestColor); //坐标超出加工范围!
        if (((g_input_method == 1) || (F_FILETYPE == PAT_SEW)) && (plastno == MENU_CURSOR))
        {
            if (Read_xyposi())
            {
                if (F_FILETYPE == PAT_MIT)
                {
                    g_dxpos = g_xabspos - g_tmpoxpos;
                    g_dypos = g_yabspos - g_tmpoypos;
                }
                else if (F_FILETYPE == PAT_SEW)
                {
                    g_dxpos = g_xabspos - g_tmpoxpos / 2;
                    g_dypos = g_yabspos - g_tmpoypos / 2;
                }
            }
        }
        else
        {
            if (F_FILETYPE == PAT_MIT)
            {
                TMP_SREG[0] = g_draw_p - g_temp_draw_p;
                add1 = 1;
                for (ii = g_temp_draw_p; ii < g_draw_p; ii++)
                {
                    TMP_SREG[add1++] = SREG[ii];
                    SREG[ii] = 0;
                    wdt();
                }

                g_reorigin = 0;
                AnaPattern(0, F_FILETYPE, 0);
                wdt();
                Mit_CreateAllData();
                g_temp_oxpos = g_oxpos;
                g_temp_oypos = g_oypos;

                g_point_num = TMP_SREG[0] / 4;
                add1 = 1;
                if (g_point_num == 0)
                {
                    g_point_num = 1;
                }
                else if (g_point_num > 1)
                {
                    g_array4[0][0] = g_point_num - 1;
                    TMP_SREG[0] -= 4;
                    for (ii = 1; ii < g_point_num; ii++)
                    {
                        g_array4[ii][0] = TMP_SREG[ii * 4 - 1];
                        g_array4[ii][1] = TMP_SREG[ii * 4];
                        wdt();
                    }
                    for (ii = TMP_SREG[0]; ii > 0; ii--)
                        SREG[g_draw_p++] = TMP_SREG[add1++];
                }
                g_temp_draw_p = g_draw_p - TMP_SREG[0];
                wdt();
                g_dxpos = (S16)(TMP_SREG[add1 + 2]);
                g_dypos = (S16)(TMP_SREG[add1 + 3]);
                if (((g_input_method == 3) || (g_input_method == 6)) && (g_feed_flag))
                {
                    g_tmpoxpos -= g_dxpos;
                    g_tmpoypos -= g_dypos;
                }
            }
        }
        btn_en = 2; // EXIT
        break;

    case 3:
        Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 112), linemaxdisplay, Err_MSG1_Sheet1, 112, l1, vTestColor); //已经没有输入坐标可取消了!
        Draw24x24MulStr(disPosStr_X, vaddr2, (uint *)(USE_ERROR_MSG + ERROR_LEN * 112 + ERROR_MSG), linemaxdisplay, Err_MSG1_Sheet2, 112, l2, vTestColor);
        btn_en = 2;
        break;

    case 4:                                                                                                                                              // 坐标超出加工范围!
        Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27), linemaxdisplay, Err_MSG1_Sheet1, 27, l1, vTestColor);             //输入坐标错误!
        Draw24x24MulStr(disPosStr_X, vaddr2, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27 + ERROR_MSG), linemaxdisplay, Err_MSG1_Sheet1, 27, l2, vTestColor); //坐标超出加工范围!te);
        if ((plastno == MENU_MODIFY1) || (plastno == MENU_MODIFYADD))
        {
            if (F_FILETYPE == PAT_MIT)
            { //三菱
                AnaPattern(0, F_FILETYPE, 0);
                if (plastno == MENU_MODIFY1)
                {
                    if (Read_xyposi())
                    {
                        //printf("g_xabspos = %d  g_yabspos = %d  g_tmpox = %d g_tmpoy = %d \r\n",g_xabspos,g_yabspos,g_tmpox,g_tmpoy);
                        g_dxpos = g_xabspos - g_tmpox;
                        g_dypos = g_yabspos - g_tmpoy;
                    }
                }
            }
        }
        btn_en = 2; // EXIT
        break;      // 坐标超出加工范围!

    case 6:                                                                                                                                              // 原点
        Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 25), linemaxdisplay, Err_MSG1_Sheet1, 25, l1, vTestColor);             //请按回原点键
        Draw24x24MulStr(disPosStr_X, vaddr2, (uint *)(USE_ERROR_MSG + ERROR_LEN * 25 + ERROR_MSG), linemaxdisplay, Err_MSG1_Sheet1, 25, l2, vTestColor); //按回原点键后请稍等片刻等待压脚回到原点
        btn_en = 8;
        break;

    case 7:                                                                                                                                              // 坐标超出加工范围!
    case 8:                                                                                                                                              // 坐标超出加工范围!
        Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27), linemaxdisplay, Err_MSG1_Sheet1, 27, l1, vTestColor);             //输入坐标错误!
        Draw24x24MulStr(disPosStr_X, vaddr2, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27 + ERROR_MSG), linemaxdisplay, Err_MSG1_Sheet1, 27, l2, vTestColor); //坐标超出加工范围!
        // EXIT
        btn_en = 2;

        break;
    default: // EXIT
        btn_en = 2;
        break;
    }

    if (btn_en & 0x1)
    { // ENTER = 1;
        DrawButton(keyd[KEY_INHELP_ENTER], (U16 *)(ADD_ICONBMP),
                   keybmpind[KEY_INHELP_ENTER].border[0], keybmpind[KEY_INHELP_ENTER].icon[0]);
    }
    else if (btn_en & 0xc)
    { // ORG = 4 8;
        DrawButton(keyd[KEY_INHELP_ORG], (U16 *)(ADD_ICONBMP),
                   keybmpind[KEY_INHELP_ORG].border[0], keybmpind[KEY_INHELP_ORG].icon[0]);
    }
    if (btn_en & 0x2)
    { // EXIT  = 2;
        DrawButton(keyd[KEY_INHELP_EXIT], (U16 *)(ADD_ICONBMP),
                   keybmpind[KEY_INHELP_EXIT].border[0], keybmpind[KEY_INHELP_EXIT].icon[0]);
    }
    if (btn_en & 0x10)
    { // SECT = 16;
        DrawButton(keyd[KEY_INHELP_SECT], (U16 *)(ADD_ICONBMP),
                   keybmpind[KEY_INHELP_SECT].border[0], keybmpind[KEY_INHELP_SECT].icon[0]);
    }
    // /[绘制初始显示页面*end]**********************************************************

    // /[运行状态信息与需要执行的数据信息读取*begin]**********************************************************

    ViewPage(usepageno); //设置显示缓存

    // /[运行状态信息与需要执行的数据信息读取*end]**********************************************************
    Timer_ms = 30720; //0x7800
    Timerms = 0;
    Timer_ms1 = 0;
    while (1)
    {
        if (F_FILETYPE == PAT_MIT)
        { //三菱
            if ((flag == 0) && (dat == 0))
            {
                flag = 1;
                add1 = SREG[g_draw_p - 4];
                add2 = SREG[g_pat_p - 2];
                if ((add1 != 0x1f01) && (add1 != 0x1e01) && (add2 != 0x1f) && (add2 != 0x1e))
                {
                    SREG[g_draw_p++] = 0x1f01;
                    SREG[g_draw_p++] = 0;
                    SREG[g_draw_p++] = 0;
                    SREG[g_draw_p++] = 0;
                    SREG[g_line_p++] = g_line_sum++;
                    SREG[g_pat_p++] = 0x1f;
                    SREG[g_pat_p++] = 0;
                    g_feedc++;
                    g_feedsum++;
                }
                add1 = (SREG[2] + 0x40) / 2;
                add2 = add1 + ((((U32)(SREG[5]) << 16) + SREG[4]) / 4);
                dat2 = g_line_p - add1;
                g_line_p = g_draw_p;
                for (ii = 0; ii < dat2; ii++)
                {
                    SREG[g_line_p++] = SREG[add1 + ii];
                    kk++;
                }
                g_pat_p = g_line_p;
                for (ii = 0; ii < dat2; ii++)
                {
                    SREG[g_pat_p++] = SREG[add2++];
                    SREG[g_pat_p++] = SREG[add2++];
                }
                // ****************************************
                for (add2 = g_pat_p; add2 < MAXSREG; add2++)
                {
                    SREG[add2] = 0;
                }
                SREG[2] = g_draw_p * 2 - 0x40;
                SREG[4] = (U16)(dat2 * 4);
                SREG[5] = (U16)((dat2 * 4) >> 16);

                ///////////////////////////////////////////保存中压脚设定高度
                if (((plastno == MENU_WRITE1) || (plastno == MENU_CURSOR)) && (g_modifyflag))
                {
                    ///////////////////////////////////////////保存电子夹线器基准高度
                    f = Read_D(D_Address[SYS] + SYS_LFORCESET, 1, (U16 *)(&YREG[SYS_LFORCESET])); //读电子夹线器基准高度
                    if (f == 0)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 15;
                        break;
                    }
                    SREG[0x0a] = YREG[SYS_LFORCESET];

                    f = Read_D(D_Address[SYS] + SYS_PFOOTSET, 1, (U16 *)(&YREG[SYS_PFOOTSET])); //读设定中压脚修正量
                    if (f == 0)
                    {
                        pno = MENU_RWHELP;
                        hleppara = 15;
                        break;
                    }

                    SREG[0x19] = YREG[SYS_PFOOTSET] << 8;
                }
                i = ((SREG[2] + 0x40) / 2) + ((((U32)(SREG[5]) << 16) + SREG[4]) / 4) * 3;
                checksum = 0;

                for (ii = 0; ii < i; ii++)
                {
                    if (ii != 0x20)
                        checksum += SREG[ii];
                }
                SREG[0x20] = checksum;
                g_patd.pat_add = (SREG[2] + 0x40 + ((((U32)(SREG[5]) << 16) + SREG[4]) / 2)) / 2;
                g_init_flag = 1;
                g_data_flash = 1;
            }
        }

        keydata = get_keydata((KEYPAD *)keyd, keynum, 0); //获取键值

        // /[按键键值返回预处理*begin]**********************************************************

        //特定情况下不生效按键预处理
        if (keydata == KEY_INHELP_EXIT)
        {
            if ((btn_en & 0x2) == 0)
                keydata = 0;
        }
        else if (keydata == KEY_INHELP_ENTER)
        {
            if (btn_en & 0x1)
                keydata = KEY_INHELP_ENTER;
            else if (btn_en & 0xc)
                keydata = KEY_INHELP_ORG;
            else
                keydata = 0;
        }
        else if (keydata == KEY_INHELP_SECT)
        {
            if ((btn_en & 0x10) == 0)
                keydata = 0;
        }

        if (keydata == 0xff) //按键松开后的键值预处理
        {
            //带有连续按键功能的按键
            if ((keyon) && (beeponf)) //降按键按下时的键值传给按键松开键值
            {
                keyoff = keyon;
            }
            keydata = 0;
        }
        else if (keydata >= USESCREENSAVER) //按键按下的键值预处理    与提示性信息处理
        {
            //特定情况下不生效按键

            if (keyon == 0) //按键按下键值赋值与按键按下效果显示(当前没有按键按下时
            {
                keyon = keydata;
                //无按键特效
                //非常规按键-//绘制颜色文字按键
                //常规按键
                DrawButtonOn(keyd[keyon], keybmpind[keyon].border[0]);

                Times = 0;
                delay = KEYDT; //按键防抖次数
            }
            else if (keyon != keydata) //已有按键按下，不处理新按键信息
            {
                keydata = 0;
            }

            if (Times > delay) //按键防抖
            {
                if (beeponf == 0) //蜂鸣器标志位 //第一次进入
                {
                    beeponf = 1;

                    if (g_keyBellT) //按键时蜂鸣器发声时间
                        Beep_On(g_keyBellT);

                    switch (keyon) //按键按下标题提示语显示
                    {
                    default:
                        DrawFMenuStr(keybmpind[keyon].titleStr[0]);
                        break;
                    }

                    delay = KEYFT;
                }
                else if (beeponf == 1) //第二次进入
                {
                    beeponf = 2;
                }
                else if (beeponf < 20)
                {
                    beeponf++;
                }

                //带有长按连续功能按键的功能
                Times = 0;
            }
        }
        else //按键没有按下
        {
            key_on_flag1 = 0;
        }

        // /[按键键值返回预处理*end]**********************************************************

        // /[按键松开键值处理*begin]**********************************************************
        if (keyoff)
        {
            switch (keyoff)
            {
            case KEY_INHELP_EXIT:
                if (F_FILETYPE == PAT_MIT)
                { //三菱
                    if (errflag == 1 || para == 8)
                    {
                        pno = MENU_CURSOR;
                        plastno = MENU_INHELP;
                        pnoindex--;
                        break;
                    }
                    pnoindex--;
                    pno = poldno[pnoindex];
                    if ((plastno == MENU_CONVERT) || (plastno == MENU_MODIFY))
                    {
                        g_reorigin = 0;
                        Mit_CreateAllData();
                        plastno = MENU_INHELP;
                    }
                    else if (plastno == MENU_CONVERT1)
                    {
                        g_para1 = 0;
                        plastno = MENU_CONVERT;
                    }
                    else if (plastno == MENU_MODIFY1)
                    {
                        plastno = MENU_MODIFYADD;
                    }
                    else
                    {
                        plastno = MENU_INHELP;
                    }
                }
                else if (F_FILETYPE == PAT_SEW)
                { //兄弟
                    pnoindex--;
                    pno = poldno[pnoindex];
                    if ((g_input_method == 4) || (g_input_method == 5))
                    {
                        g_array4[0][0]--;
                    }
                }
                break;

            case KEY_INHELP_ENTER:
                if (dat == 1)
                {
                    if (F_FILETYPE == PAT_MIT)
                    {
                        if (g_DrawOcclude == 2)
                        {
                            pnoindex--;
                            pno = poldno[pnoindex];
                            plastno = MENU_INHELP;
                            break;
                        }
                        if (g_ct_insert_flag == 2)
                        { //段插入
                            //for(i=0;i<MAXSREG2;i++){
                            //	NEWSREG[i] = SREG[i];
                            //}
                            //bfeedc = g_feedc;
                            tpoint_num = g_point_num;
                            g_jog_stpoint = g_feedc;
                            g_jog_enpoint = g_feedc;
                            // tfeedsum = g_patd.feed_sum;
                            tfeed = g_feedc;
                            g_array4[g_point_num][0] = g_dxpos; //记录控制点的绝对坐标
                            g_array4[g_point_num][1] = g_dypos;
                            g_array5[g_point_num][0] = g_dxpos; //记录控制点相对坐标
                            g_array5[g_point_num][1] = g_dypos;
                            //printf("*g_init_flag = %d  g_draw_p = %d  g_line_p = %d g_pat_p = %d\r\n",g_init_flag,g_draw_p,g_line_p,g_pat_p);
                            //printf("*g_init_flag = %d  g_patd.draw_add  = %d  g_patd.line_add = %d g_patd.pat_add  = %d\r\n",g_init_flag,g_patd.draw_add ,g_patd.line_add,g_patd.pat_add );
                            //
                            //printf("0 g_feed_flag = %d  g_input_method = %d  g_point_num = %d \r\n",g_feed_flag,g_input_method,g_point_num);
                            g_nolimt = 1;
                            mit_CtToMod();
                            AnaPattern(0, PAT_MIT, 0);

                            g_point_num = tpoint_num;
                            //printf("1 g_feed_flag = %d  g_input_method = %d  g_point_num =%d\r\n",g_feed_flag,g_input_method,g_point_num);
                            if (g_input_method == 4)
                            { //圆
                                g_selectmode = 4;
                            }
                            else if (g_input_method == 5)
                            { //圆弧
                                g_selectmode = 2;
                            }
                            else if (g_input_method == 3)
                            { //折线
                                g_selectmode = 1;
                            }
                            else if (g_input_method == 6)
                            { //曲线
                                g_selectmode = 3;
                            }

                            g_point_num++;
                            g_temp_point_num = g_point_num;

                            f = Mit_Modify_Data(20);
                            //for(i=0;i<2*g_patd.feed_sum;i++){
                            //	printf("--SREG[%d] = %04x \r\n",52000+i,SREG[52000+i]);
                            //}
                            //printf("f = %d tfeed = %d g_ctAddpins = %d  \r\n",f,tfeed,g_ctAddpins);
                            //g_feedc = tfeed + g_ctAddpins ;
                            //mitPinmsg = mit_getPinsMsg((U16*)SREG,52000,g_feedc);
                            //printf("00g_patd.pat_add =%d  px = %d py =%d  dx = %d  dy = %d speed = %02x g_oxpos = %d  g_oypos = %d g_feedc = %d\r\n",g_patd.pat_add,mitPinmsg.posx,mitPinmsg.posy,mitPinmsg.dx,mitPinmsg.dy,mitPinmsg.speed,g_oxpos,g_oypos,g_feedc);

                            mit_ModToCt();
                            AnaPattern(0, PAT_MIT, 0);

                            //for(i=0;i<2*g_patd.feed_sum;i++){
                            //	printf("-*-SREG[%d] = %04x \r\n",52000+i,SREG[52000+i]);
                            //}

                            //printf("-- g_patd.feed_sum = %d g_ctAddpins = %d tfeedc = %d\r\n",g_patd.feed_sum,g_ctAddpins,tfeed);
                            g_feed_flag = 1;
                            //g_ctAddpins = g_patd.feed_sum-tfeedsum;
                            g_feedsum = g_patd.feed_sum;
                            g_feedc = tfeed + g_ctAddpins;
                            tfeedc = g_feedc;
                            //g_feedc = g_patd.feed_sum;
                            mitPinmsg = mit_getPinsMsg((U16 *)SREG, 52000, g_feedc);
                            //printf("g_patd.pat_add =%d  px = %d py =%d  dx = %d  dy = %d speed = %02x g_oxpos = %d  g_oypos = %d g_feedc = %d g_patd.feed_sum =%d\r\n",g_patd.pat_add,mitPinmsg.posx,mitPinmsg.posy,mitPinmsg.dx,mitPinmsg.dy,mitPinmsg.speed,g_oxpos,g_oypos,g_feedc,g_patd.feed_sum);

                            //--绘制空送回到原来位置
                            g_dxpos = g_inoxpos - mitPinmsg.posx;
                            g_dypos = g_inoypos - mitPinmsg.posy;
                            if (g_dxpos != 0 || g_dypos != 0 || 1)
                            {
                                g_point_num = 1;
                                g_nolimt = 1;
                                //g_feedc = 97;

                                g_array4[g_point_num][0] = g_dxpos; //记录控制点的绝对坐标
                                g_array4[g_point_num][1] = g_dypos;
                                g_array5[g_point_num][0] = g_dxpos; //记录控制点相对坐标
                                g_array5[g_point_num][1] = g_dypos;
                                g_point_num++;
                                g_temp_point_num = g_point_num;
                                //printf("0 g_patd.feed_sum = %d \r\n",g_patd.feed_sum);
                                mit_CtToMod();
                                //printf("1 g_patd.feed_sum = %d \r\n",g_patd.feed_sum);
                                AnaPattern(0, PAT_MIT, 0);
                                //printf("2 g_patd.feed_sum = %d g_feedsum = %d \r\n",g_patd.feed_sum,g_feedsum);
                                //if(g_input_method==6){	//曲线同向多重缝需要处理一下
                                //
                                //}
                                //for(i=0;i<2*g_patd.feed_sum;i++){
                                //	printf("-*-SREG[%d] = %04x \r\n",52000+i,SREG[52000+i]);
                                //}

                                g_nolimt = 0;

                                //printf("2 g_patd.feed_sum = %d g_feedsum = %d g_feedc = %d\r\n",g_patd.feed_sum,g_feedsum,g_feedc);
                                /*if(g_input_method==6)*/ mit_upInsetPs(g_feedsum - g_patd.feed_sum, mitPinmsg.posx, mitPinmsg.posy);
                                //printf("g_feedc = %d\r\n",g_feedc);
                                tfeedc = g_feedc;
                                g_jog_stpoint = g_feedc;
                                g_jog_enpoint = g_feedc;
                                f = Mit_Modify_Data(21);
                                mit_ModToCt();

                                AnaPattern(0, PAT_MIT, 0);

                                g_feedc = tfeedc;
                                g_feedsum = g_patd.feed_sum;
                            }
                            else
                            {

                                g_nolimt = 0;
                            }
                            g_dxpos = 0;
                            g_dypos = 0;

                            g_oxpos = mitPinmsg.posx;
                            g_oypos = mitPinmsg.posy;
                            Send_Pfoot(1, MENU_CURSOR, 1); //压脚升

                            Comm_Move(g_oxpos, g_oypos, 120, MENU_CURSOR, 0, 0);
                            dis_data((g_feed_flag == 0) ? 0 : 0x5a, 0);

                            g_maxX = g_patd.patmX;
                            g_minX = g_patd.patiX;
                            g_maxY = g_patd.patmY;
                            g_minY = g_patd.patiY;

                            g_ct_insert_flag = 1;
                            g_ct_status_flag = 0x7cfdf;
                            g_ct_status_flag |= bit19;
                            g_feedsum = g_patd.feed_sum;

                            g_array4[0][0] = 0;
                            g_point_num = 1;
                            g_ct_insert_flag = 3;

                            if (f == 0)
                            {
                                // DrawFillRect(keyd[KEY_INHELP_EXIT].xpis, keyd[KEY_INHELP_EXIT].ypis, keyd[KEY_INHELP_EXIT].xsize, keyd[KEY_INHELP_EXIT].ysize, keybmpind[KEY_INHELP_EXIT].icon[3]);
                                DrawFillRect(keyd[KEY_INHELP_ENTER].xpis, keyd[KEY_INHELP_ENTER].ypis, keyd[KEY_INHELP_ENTER].xsize, keyd[KEY_INHELP_ENTER].ysize, keybmpind[KEY_INHELP_ENTER].icon[3]);
                                DrawFillRect(rect[RECT_INHELP_STR1].xpis, rect[RECT_INHELP_STR1].ypis,
                                             rect[RECT_INHELP_STR1].xsize, rect[RECT_INHELP_STR1].ysize,
                                             rect[RECT_INHELP_STR1].colorB[0]);
                                DrawFillRect(rect[RECT_INHELP_STR2].xpis, rect[RECT_INHELP_STR2].ypis,
                                             rect[RECT_INHELP_STR2].xsize, rect[RECT_INHELP_STR2].ysize,
                                             rect[RECT_INHELP_STR2].colorB[0]);
                                Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27), linemaxdisplay, Err_MSG1_Sheet1, 27, 2, vTestColor);             //输入坐标错误!
                                Draw24x24MulStr(disPosStr_X, vaddr2, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27 + ERROR_MSG), linemaxdisplay, Err_MSG1_Sheet2, 27, 2, vTestColor); //坐标超出加工范围!
                                btn_en = 2;

                                errflag = 1;
                                keyon = 0;

                                //									for(i=0;i<MAXSREG2;i++){
                                //										SREG[i] = NEWSREG[i];
                                //									}
                                //									printf("g_feedc = %d  bfeedc = %d \r\n",g_feedc,bfeedc);
                                //									AnaPattern(0,0,0);
                                //									g_feedsum = g_patd.feed_sum;
                                //									g_feedc = bfeedc;
                                //									mitPinmsg = mit_getPinsMsg((U16*)SREG,52000,g_feedc);
                                //									g_oxpos = mitPinmsg.posx;
                                //									g_oypos = mitPinmsg.posy;
                                //									Send_Pfoot(1,MENU_CURSOR,1);	//压脚升
                                //
                                //									Comm_Move(g_oxpos,g_oypos,120,MENU_CURSOR,0,0);
                                errflag = 1;
                                break;
                            }
                            pno = MENU_CURSOR;
                            plastno = MENU_INHELP;
                            pnoindex--;
                            break;
                        }

                        if (g_jogmethod)
                        { //花样轨迹
                            cpx0 = g_tmpoxpos + g_dxpos;
                            cpy0 = g_tmpoypos + g_dypos;
                            cpx = cpx0;
                            cpy = cpy0;
                        }
                        dat2 = Mit_Create_Data(1);

                        if (dat2 == 0xfe)
                        { //折线或曲线不是封闭图形
                            g_DrawOcclude = 1;
                            pno = MENU_INHELP;
                            hleppara = 1;
                            plastno = MENU_CURSOR;
                        }
                        else if (dat2 == 0)
                        {
                            dat = para % 10;
                            DrawFillRect(rect[RECT_INHELP_STR1].xpis, rect[RECT_INHELP_STR1].ypis,
                                         rect[RECT_INHELP_STR1].xsize, rect[RECT_INHELP_STR1].ysize,
                                         rect[RECT_INHELP_STR1].colorB[0]);
                            DrawFillRect(rect[RECT_INHELP_STR2].xpis, rect[RECT_INHELP_STR2].ypis,
                                         rect[RECT_INHELP_STR2].xsize, rect[RECT_INHELP_STR2].ysize,
                                         rect[RECT_INHELP_STR2].colorB[0]);
                            Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27), linemaxdisplay, Err_MSG1_Sheet1, 27, 2, vTestColor);             //输入坐标错误!
                            Draw24x24MulStr(disPosStr_X, vaddr2, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27 + ERROR_MSG), linemaxdisplay, Err_MSG1_Sheet2, 27, 2, vTestColor); //坐标超出加工范围!

                            TMP_SREG[0] = g_draw_p - g_temp_draw_p;
                            add1 = 1;
                            for (ii = g_temp_draw_p; ii < g_draw_p; ii++)
                            {
                                TMP_SREG[add1++] = SREG[ii];
                                SREG[ii] = 0;
                            }

                            g_reorigin = 0;
                            AnaPattern(0, PAT_MIT, 0);
                            Mit_CreateAllData();
                            g_temp_oxpos = g_oxpos;
                            g_temp_oypos = g_oypos;

                            g_point_num = TMP_SREG[0] / 4;
                            add1 = 1;
                            if (g_point_num == 0)
                            {
                                g_point_num = 1;
                            }
                            else if (g_point_num > 1)
                            {
                                g_array4[0][0] = g_point_num - 1;
                                TMP_SREG[0] -= 4;
                                for (ii = 1; ii < g_point_num; ii++)
                                {
                                    g_array4[ii][0] = TMP_SREG[ii * 4 - 1];
                                    g_array4[ii][1] = TMP_SREG[ii * 4];
                                }
                                for (ii = TMP_SREG[0]; ii > 0; ii--)
                                    SREG[g_draw_p++] = TMP_SREG[add1++];
                            }

                            g_temp_draw_p = g_draw_p - TMP_SREG[0];
                            g_dxpos = (S16)(TMP_SREG[add1 + 2]);
                            g_dypos = (S16)(TMP_SREG[add1 + 3]);
                            if (((g_input_method == 3) || (g_input_method == 6)) && (g_feed_flag))
                            {
                                g_tmpoxpos -= g_dxpos;
                                g_tmpoypos -= g_dypos;
                            }
                            btn_en = 2;
                            dat = 2;
                            // DrawFillRect(keyd[KEY_INHELP_EXIT].xpis, keyd[KEY_INHELP_EXIT].ypis, keyd[KEY_INHELP_EXIT].xsize, keyd[KEY_INHELP_EXIT].ysize, keybmpind[KEY_INHELP_EXIT].icon[3]);
                            DrawFillRect(keyd[KEY_INHELP_ENTER].xpis, keyd[KEY_INHELP_ENTER].ypis, keyd[KEY_INHELP_ENTER].xsize, keyd[KEY_INHELP_ENTER].ysize, keybmpind[KEY_INHELP_ENTER].icon[3]);
                            keyon = 0;
                        }
                        else
                        {
                            pno = MENU_CURSOR;
                            plastno = MENU_INHELP;
                            pnoindex--;
                            if ((U8)(S_PFOOT) == 0x10)
                            {                                  //压脚在下面，先抬起压脚
                                Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                            }
                            if (g_jogmethod)
                            { //花样轨迹
                                cfeed = mitFindPinAndPos(g_patd.feed_sum, g_feedsum, &cpx, &cpy);
                                if ((cpx != cpx0) || (cpy != cpy0))
                                {
                                    Comm_Move(cpx, cpy, 120, MENU_CURSOR, 0, 0);
                                }
                                mitP2Pmove(cfeed, g_feedsum, MENU_CURSOR);
                            }
                            else
                            {
                                Comm_Move(g_oxpos, g_oypos, 120, MENU_CURSOR, 0, 0);
                            }

                            AnaPattern(0, PAT_MIT, 0);

                            g_maxX = g_patd.patmX;
                            g_minX = g_patd.patiX;
                            g_maxY = g_patd.patmY;
                            g_minY = g_patd.patiY;
                        }
                        g_disxpos = g_oxpos;
                        g_disypos = g_oypos;
                    }
                    else if (F_FILETYPE == PAT_SEW)
                    {
                        if (g_DrawOcclude == 2)
                        {
                            pnoindex--;
                            pno = poldno[pnoindex];
                            plastno = MENU_INHELP;
                            break;
                        }
                        if (g_ct_insert_flag == 2)
                        { //段插入
                            tmpCreatstaddr = g_Ctendaddr;
                            tmpCreatstaddr1 = g_Ctendaddr;
                            g_ctAddpins = 0;
                            tfeed = g_feedc;
                            tfeed_sum = g_patd.feed_sum;
                            for (i = 0; i < MAXBLKSREG; i++)
                            {
                                BLKSREG[i] = SREG[i];
                            }
                            wdt();
                            g_blkInsetlen = g_CtPatLen;

                            ctBackSaddr = g_Ctstaddr;
                            ctBackEaddr = g_Ctendaddr;

                            redx = (S16)g_array4[g_point_num - 1][0] - ((S16)g_array4[1][0] - mut * (S16)g_array5[1][0]);
                            redy = (S16)g_array4[g_point_num - 1][1] - ((S16)g_array4[1][1] - mut * (S16)g_array5[1][1]);
                            //#if Debug
                            //for(ii=0;ii<g_point_num;ii++){
                            //	printf("-g_array4[%d][0] = %d,g_array4[%d][1] = %d\r\n",ii,(S16)g_array4[ii][0],ii,(S16)g_array4[ii][1]);
                            //}
                            //printf("redx = %d,redy = %d \r\n",redx,redy);
                            //#endif
                            if ((g_bt_mode == 2) && (g_input_method != 4))
                            { //有重缝
                                if ((redx * redx + redy * redy) <= (10 * 10))
                                { //起始点和终点距离小于0.5mm,将终点坐标修正到起始点
                                    g_array4[g_point_num - 1][0] = ((S16)g_array4[1][0] - mut * (S16)g_array5[1][0]);
                                    g_array4[g_point_num - 1][1] = ((S16)g_array4[1][1] - mut * (S16)g_array5[1][1]);
                                    g_oxpos = (S16)g_array4[g_point_num - 1][0];
                                    g_oypos = (S16)g_array4[g_point_num - 1][1];
                                }
                            }
                            else
                            {
                                if ((redx * redx + redy * redy) <= (4 * 4))
                                { //起始点和终点距离小于0.2mm,将终点坐标修正到起始点
                                    g_array4[g_point_num - 1][0] = ((S16)g_array4[1][0] - mut * (S16)g_array5[1][0]);
                                    g_array4[g_point_num - 1][1] = ((S16)g_array4[1][1] - mut * (S16)g_array5[1][1]);
                                    g_oxpos = (S16)g_array4[g_point_num - 1][0];
                                    g_oypos = (S16)g_array4[g_point_num - 1][1];
                                }
                            }
                            if ((g_bt_mode == 2) && (g_input_method != 4))
                            { //有重缝，先判断是否闭合
                                for (ii = 0; ii < (g_array4[0][0] + 1); ii++)
                                { //先将曲线坐标点计算出来
                                    if (ii == 0)
                                    {
                                        PATCRRRD[ii][0] = (S16)g_array4[ii + 1][0] - mut * (S16)g_array5[ii + 1][0];
                                        PATCRRRD[ii][1] = (S16)g_array4[ii + 1][1] - mut * (S16)g_array5[ii + 1][1];
                                    }
                                    else
                                    {
                                        PATCRRRD[ii][0] = (S16)g_array4[ii][0];
                                        PATCRRRD[ii][1] = (S16)g_array4[ii][1];
                                    }
                                }

                                if (Bor_ctlIsocclu(g_array4[0][0] + 1) == 0)
                                { //先判断是否闭合
                                    g_DrawOcclude = 1;
                                    pno = MENU_INHELP;
                                    hleppara = 1;
                                    plastno = MENU_CURSOR;
                                    break;
                                }
                                else
                                {
                                    g_DrawOcclude = 0;
                                }
                            }

                            exflag = 0; //清除附加功能标志，记录有无速度、中压脚功能
                            if (g_oldspeed != g_speed)
                            { //修改速度
                                tmpCreatstaddr1 = g_Ctendaddr;
                                Bor_doSpeed((U16 *)SREG, (U32 *)&tmpCreatstaddr1, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, g_speed, &g_patd.feed_sum);
                                g_oldspeed = g_speed;
                                exflag |= 0x01; //标记速度修改
                            }

                            if ((g_pf_dis != 0) && g_pf_mode)
                            { //	中压脚
                                tmpCreatstaddr1 = g_Ctendaddr;

                                Bor_doPF((U16 *)SREG, (U32 *)&tmpCreatstaddr1, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, g_pf_absval - g_pfootd.base, &g_patd.feed_sum);
                                g_updata_pf_valflg = 1;
                                exflag |= 0x02; //标记中压脚修改
                                g_pf_mode = 0;
                            }

                            exflag = 0; //清除附加功能标志，记录有离边，重缝，Z缝、倒缝功能
                            if (g_para_offset == 3)
                            { //离边
                                exflag |= 0x01;
                            }
                            else if ((g_para_offset == 1) || (g_para_offset == 2) || (g_para_offset == 4) || (g_para_offset == 5))
                            { //多重缝
                                exflag |= 0x02;
                            }

                            if (g_zig_zag)
                            { //Z缝
                                exflag |= 0x04;
                            }

                            if (g_bt_mode)
                            { //倒缝
                                exflag |= 0x08;
                            }
                            g_nolimt = 1;
                            tmpCreatstaddr1 = g_Ctendaddr;
                            //printf("11  g_ctAddpins = %d g_patd.feed_sum = %d \r\n",g_ctAddpins,g_patd.feed_sum);
                            if ((g_input_method == 6) && ((g_para_offset == 1) || (g_para_offset == 2) || (g_para_offset == 4) || (g_para_offset == 5)))
                            { //多重缝
                                ISEWADD sewInfo = {0};
                                S16 Xposmax, Xposmin, Yposmax, Yposmin;

                                BSREG = (U16 *)&BLKBUF[MAXBLKBUF - 2 - MAXBLKSREG];
                                for (i = 0; i < MAXBLKSREG; i++)
                                {
                                    BSREG[i] = SREG[i];
                                }
                                Bor_CtBefDatAny((U32 *)&Ctstaddr, (U32 *)&CtPatLen, (U8 *)&g_oldspeed, 2);

                                wdt();

                                Ctendaddr = Ctstaddr;
                                tmpCreatstaddr1 = Ctendaddr;
                                dat2 = Bor_CreatData((U32 *)&tmpCreatstaddr1, (U32 *)&Ctendaddr, 0, 0, 0, 0, g_pitch, (U32 *)&CtPatLen, g_input_method + 1, exflag);
                                if (dat2)
                                {
                                    f = Bor_AnaInfo((U16 *)BSREG, g_CtPatLen, &sewInfo);

                                    Bor_MoveData(BSREG, g_CtPatLen, Ctendaddr - Ctstaddr, g_Ctendaddr);
                                    for (i = 0; i < Ctendaddr - Ctstaddr; i++)
                                    {
                                        BSREG[g_Ctendaddr + i] = SREG[Ctstaddr + i];
                                    }
                                    g_CtPatLen += (Ctendaddr - Ctstaddr) * 2;
                                    g_Ctendaddr += (Ctendaddr - Ctstaddr);

                                    sewInfo.ptsize += (Ctendaddr - Ctstaddr) * 2;
                                    BSREG[sewInfo.lenaddr] = (((sewInfo.ptsize >> 16) & 0xff) << 8) | ((sewInfo.ptsize >> 24) & 0xff);
                                    BSREG[sewInfo.lenaddr + 1] = (((sewInfo.ptsize >> 0) & 0xff) << 8) | ((sewInfo.ptsize >> 8) & 0xff);

                                    wdt();
                                }
                                for (i = 0; i < MAXBLKSREG; i++)
                                {
                                    SREG[i] = BSREG[i];
                                }
                                Bor_CalPatLim((U16 *)SREG, g_CtPatLen, &Xposmax, &Xposmin, &Yposmax, &Yposmin, &g_patd.feed_sum);
                                //g_maxX = Xposmax;
                                //g_minX = Xposmin;
                                //g_maxY = Yposmax;
                                //g_minY = Yposmin;
                                wdt();
                            }
                            else
                            {
                                dat2 = Bor_CreatData((U32 *)&tmpCreatstaddr1, (U32 *)&g_Ctendaddr, 0, 0, 0, 0, g_pitch, (U32 *)&g_CtPatLen, g_input_method + 1, exflag);
                            }

                            //printf("dat2 = %d  g_ctAddpins = %d g_patd.feed_sum = %d\r\n",dat2,g_ctAddpins,g_patd.feed_sum);
                            g_ctAddpins = g_patd.feed_sum - tfeed_sum;
                            if (g_input_method == 6)
                            { //曲线
                                g_Ctendaddr = sew_getPinAddr((U16 *)SREG, g_CtPatLen, g_feedc + g_ctAddpins, 0);
                            }
                            g_nolimt = 0;
                            //printf("dat2 = %d  g_ctAddpins = %d ctAddpins = %d g_patd.feed_sum = %d\r\n",dat2,g_ctAddpins,g_patd.feed_sum,ctAddpins);
                            if (dat2)
                            {
                                g_feedc += g_ctAddpins;
                                Bor_feedInfo(g_feedc, g_CtPatLen, &Borcmd, (S16 *)&g_oxpos, (S16 *)&g_oypos, (S16 *)&tmpxdat1, (S16 *)&tmpydat1, (U8 *)&g_oldspeed, &Borpooft, &Borpfdis);
                                g_oxpos += tmpxdat1;
                                g_oypos += tmpydat1;
                                //printf("--g_feedc = %d g_oxpos = %d g_oypos = %d  -g_inoxpos = %d g_inoypos = %d \r\n",g_feedc,g_oxpos,g_oypos,g_inoxpos,g_inoypos);
                                if (g_oldspeed == 0)
                                    g_oldspeed = 0x60;
                                else if (g_oldspeed == 1)
                                    g_oldspeed = 0x40;
                                else if (g_oldspeed == 2)
                                    g_oldspeed = 0x20;
                                else
                                    g_oldspeed = 0x0;

                                //空送回来
                                dat2 = sew_UpFeed((U16 *)&SREG, g_inoxpos - g_oxpos, g_inoypos - g_oypos, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen);
                                //printf("--dat2 = %d  g_ctAddpins = %d g_patd.feed_sum = %d\r\n",dat2,g_ctAddpins,g_patd.feed_sum);
                            }
                            if ((dat2 == 1) || (dat2 == 2))
                            { //成功
                                g_para_offset = 0;
                                g_zig_zag = 0;
                                g_bt_mode = 0;

                                if ((U8)(S_PFOOT) == 0x10)
                                {                                  //压脚在下面，先抬起压脚
                                    Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                }
                                Comm_Move(g_oxpos, g_oypos, 50, MENU_CURSOR, 1, 1);

                                g_Ctsavetimes = 0;
                                g_blkInset = 1;
                                g_Ctstaddr = sew_getPinAddr((U16 *)SREG, g_CtPatLen, g_feedc, 1);
                                Bor_CreatBack((U16 *)&g_Ctsavetimes, g_Ctstaddr, g_Ctstaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);
                                //Bor_CreatBack((U16*)&g_Ctsavetimes,g_Ctstaddr,g_Ctendaddr,g_CtPatLen);
                                g_maxX = g_patd.patmX;
                                g_minX = g_patd.patiX;
                                g_maxY = g_patd.patmY;
                                g_minY = g_patd.patiY;

                                g_ct_insert_flag = 1;
                                g_ct_status_flag = 0x7cfdf;
                                g_ct_status_flag |= bit19;
                                g_feedsum = g_patd.feed_sum;

                                g_array4[0][0] = 0;
                                g_point_num = 1;
                                g_ct_insert_flag = 3;
                                pno = MENU_CURSOR;
                                plastno = MENU_INHELP;
                                pnoindex--;
                                //
                            }
                            else
                            { //坐标错误
#if Debug
                                printf("addr1 = %d  g_Ctendaddr = %d \r\n", addr1, g_Ctendaddr);
#endif
                                Bor_CreatUnDO(tmpCreatstaddr, g_Ctendaddr, (U32 *)&g_CtPatLen);
                                g_Ctstaddr = ctBackSaddr;
                                g_Ctendaddr = ctBackEaddr;
                                g_oxpos = g_tmpoxpos + mut * g_dxpos;
                                g_oypos = g_tmpoypos + mut * g_dypos;
                                g_feedc = tfeed;
                                //for(ii=0;ii<g_point_num;ii++){
                                //	printf("-- g_array4[%d][0] = %d,g_array4[%d][1] = %d g_array5[%d][0] = %d,g_array5[%d][1] = %d\r\n",ii,(S16)g_array4[ii][0],ii,(S16)g_array4[ii][1],ii,(S16)g_array5[ii][0],ii,(S16)g_array5[ii][1]);
                                //}
                                // DrawFillRect(keyd[KEY_INHELP_EXIT].xpis, keyd[KEY_INHELP_EXIT].ypis, keyd[KEY_INHELP_EXIT].xsize, keyd[KEY_INHELP_EXIT].ysize, keybmpind[KEY_INHELP_EXIT].icon[3]);
                                DrawFillRect(keyd[KEY_INHELP_ENTER].xpis, keyd[KEY_INHELP_ENTER].ypis, keyd[KEY_INHELP_ENTER].xsize, keyd[KEY_INHELP_ENTER].ysize, keybmpind[KEY_INHELP_ENTER].icon[3]);

                                DrawFillRect(rect[RECT_INHELP_STR1].xpis, rect[RECT_INHELP_STR1].ypis,
                                             rect[RECT_INHELP_STR1].xsize, rect[RECT_INHELP_STR1].ysize,
                                             rect[RECT_INHELP_STR1].colorB[0]);
                                DrawFillRect(rect[RECT_INHELP_STR2].xpis, rect[RECT_INHELP_STR2].ypis,
                                             rect[RECT_INHELP_STR2].xsize, rect[RECT_INHELP_STR2].ysize,
                                             rect[RECT_INHELP_STR2].colorB[0]);
                                Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27), linemaxdisplay, Err_MSG1_Sheet1, 27, 2, vTestColor); //输入坐标错误!
                                if (dat2 == 3)
                                {
                                    Draw24x24MulStr(disPosStr_X, vaddr2, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27 + ERROR_MSG), linemaxdisplay, Err_MSG1_Sheet2, 27, 2, vTestColor); //坐标超出加工范围!
                                }

                                btn_en = 2;
                                dat = 2;

                                keyon = 0;
                                beeponf = 0;
                            }
                            g_disxpos = g_oxpos;
                            g_disypos = g_oypos;

                            g_pf_dis = 0;

                            break;
                        }

                        redx = (S16)g_array4[g_point_num - 1][0] - ((S16)g_array4[1][0] - mut * (S16)g_array5[1][0]);
                        redy = (S16)g_array4[g_point_num - 1][1] - ((S16)g_array4[1][1] - mut * (S16)g_array5[1][1]);
                        //#if Debug
                        //for(ii=0;ii<g_point_num;ii++){
                        //	printf("g_array4[%d][0] = %d,g_array4[%d][1] = %d\r\n",ii,(S16)g_array4[ii][0],ii,(S16)g_array4[ii][1]);
                        //}
                        //printf("redx = %d,redy = %d \r\n",redx,redy);
                        //#endif
                        if ((g_bt_mode == 2) && (g_input_method != 4))
                        { //有重缝
                            if ((redx * redx + redy * redy) <= (10 * 10))
                            { //起始点和终点距离小于0.5mm,将终点坐标修正到起始点
                                g_array4[g_point_num - 1][0] = ((S16)g_array4[1][0] - mut * (S16)g_array5[1][0]);
                                g_array4[g_point_num - 1][1] = ((S16)g_array4[1][1] - mut * (S16)g_array5[1][1]);
                                g_oxpos = (S16)g_array4[g_point_num - 1][0];
                                g_oypos = (S16)g_array4[g_point_num - 1][1];
                            }
                        }
                        else
                        {
                            if ((redx * redx + redy * redy) <= (4 * 4))
                            { //起始点和终点距离小于0.2mm,将终点坐标修正到起始点
                                g_array4[g_point_num - 1][0] = ((S16)g_array4[1][0] - mut * (S16)g_array5[1][0]);
                                g_array4[g_point_num - 1][1] = ((S16)g_array4[1][1] - mut * (S16)g_array5[1][1]);
                                g_oxpos = (S16)g_array4[g_point_num - 1][0];
                                g_oypos = (S16)g_array4[g_point_num - 1][1];
                            }
                        }
                        if ((g_bt_mode == 2) && (g_input_method != 4))
                        { //有重缝，先判断是否闭合
                            for (ii = 0; ii < (g_array4[0][0] + 1); ii++)
                            { //先将曲线坐标点计算出来
                                if (ii == 0)
                                {
                                    PATCRRRD[ii][0] = (S16)g_array4[ii + 1][0] - mut * (S16)g_array5[ii + 1][0];
                                    PATCRRRD[ii][1] = (S16)g_array4[ii + 1][1] - mut * (S16)g_array5[ii + 1][1];
                                }
                                else
                                {
                                    PATCRRRD[ii][0] = (S16)g_array4[ii][0];
                                    PATCRRRD[ii][1] = (S16)g_array4[ii][1];
                                }
                            }

                            if (Bor_ctlIsocclu(g_array4[0][0] + 1) == 0)
                            { //先判断是否闭合
                                g_DrawOcclude = 1;
                                pno = MENU_INHELP;
                                hleppara = 1;
                                plastno = MENU_CURSOR;
                                break;
                            }
                            else
                            {
                                g_DrawOcclude = 0;
                            }
                        }

                        exflag = 0; //清除附加功能标志，记录有无速度、中压脚功能
                        ctBackSaddr = g_Ctstaddr;
                        ctBackEaddr = g_Ctendaddr;
                        g_blkInset = 0;
                        //#if Debug
                        //printf("g_array4[0][0]+ = %d \r\n",g_array4[0][0]);
                        //#endif

                        if (g_oldspeed != g_speed)
                        { //修改速度
                            g_Ctstaddr = g_Ctendaddr;
                            addr1 = g_Ctstaddr;
                            Bor_doSpeed((U16 *)SREG, (U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, g_speed, &g_patd.feed_sum);
                            g_oldspeed = g_speed;
                            exflag |= 0x01; //标记速度修改
                        }

                        if ((g_pf_dis != 0) && g_pf_mode)
                        { //	中压脚
                            g_Ctstaddr = g_Ctendaddr;
                            if (exflag == 0)
                            {
                                addr1 = g_Ctstaddr;
                            }

                            Bor_doPF((U16 *)SREG, (U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, (U32 *)&g_CtPatLen, g_pf_absval - g_pfootd.base, &g_patd.feed_sum);
                            g_updata_pf_valflg = 1;
                            exflag |= 0x02; //标记中压脚修改
                            g_pf_mode = 0;
                        }

                        g_Ctstaddr = g_Ctendaddr;
                        if (exflag == 0)
                        {
                            addr1 = g_Ctstaddr;
                        }

                        exflag = 0; //清除附加功能标志，记录有离边，重缝，Z缝、倒缝功能
                        if (g_para_offset == 3)
                        { //离边
                            exflag |= 0x01;
                        }
                        else if ((g_para_offset == 1) || (g_para_offset == 2) || (g_para_offset == 4) || (g_para_offset == 5))
                        { //多重缝
                            exflag |= 0x02;
                        }

                        if (g_zig_zag)
                        { //Z缝
                            exflag |= 0x04;
                        }

                        if (g_bt_mode)
                        { //倒缝
                            exflag |= 0x08;
                        }

                        dat2 = Bor_CreatData((U32 *)&g_Ctstaddr, (U32 *)&g_Ctendaddr, 0, 0, 0, 0, g_pitch, (U32 *)&g_CtPatLen, g_input_method + 1, exflag);

                        if ((dat2 == 1) || (dat2 == 2))
                        { //成功
                            g_para_offset = 0;
                            g_zig_zag = 0;
                            g_bt_mode = 0;
                            if (dat2 == 1)
                            { //成功
                                Bor_CreatBack((U16 *)&g_Ctsavetimes, addr1, g_Ctendaddr, g_oxpos, g_oypos, g_oldspeed, g_pf_absval - g_pfootd.base, g_pf_dis, g_lineforceValSetNow, g_patd.orgX, g_patd.orgY);
                                g_maxX = g_patd.patmX;
                                g_minX = g_patd.patiX;
                                g_maxY = g_patd.patmY;
                                g_minY = g_patd.patiY;
                            }
                            if ((g_oxpos != (g_tmpoxpos + mut * g_dxpos)) || (g_oypos != (g_tmpoypos + mut * g_dypos)))
                            { //生成花样后，花样结束点坐标和平台移动最后坐标不同
                                if ((U8)(S_PFOOT) == 0x10)
                                {                                  //压脚在下面，先抬起压脚
                                    Send_Pfoot(1, MENU_CURSOR, 1); //压脚升
                                }
                                if (g_jogmethod)
                                { //花样轨迹移动
                                    cpx = g_tmpoxpos + mut * g_dxpos;
                                    cpy = g_tmpoypos + mut * g_dypos;
                                    cfeed = sewFindPinAndPos(g_CtPatLen, g_feedsum, g_patd.feed_sum, &cpx, &cpy);
                                    if ((cpx != (g_tmpoxpos + mut * g_dxpos)) || (cpy != (g_tmpoypos + mut * g_dypos)))
                                    {
                                        Comm_Move(cpx, cpy, 80, MENU_CURSOR, 1, 1);
                                    }
                                    //	DelayMs(5000);
                                    //Beep_On(500);

                                    sewP2Pmove(g_CtPatLen, cfeed, g_patd.feed_sum, MENU_CURSOR);
                                }
                                else
                                {
                                    Comm_Move(g_oxpos, g_oypos, 80, MENU_CURSOR, 1, 1);
                                }
                            }
                            g_dxpos = 0;
                            g_dypos = 0;
                            g_ct_status_flag = 0;
                            g_feedsum = g_patd.feed_sum;
                            g_feedc = g_patd.feed_sum;
                            g_array4[0][0] = 0;
                            g_point_num = 1;

                            pno = MENU_CURSOR;
                            plastno = MENU_INHELP;
                            pnoindex--;
                        }
                        else
                        { //坐标错误
                            if (dat2 == 0)
                            {
                                dat = para % 10;
                            }
                            Bor_CreatUnDO(addr1, g_Ctendaddr, (U32 *)&g_CtPatLen);
                            g_Ctstaddr = ctBackSaddr;
                            g_Ctendaddr = ctBackEaddr;
                            g_oxpos = g_tmpoxpos + mut * g_dxpos;
                            g_oypos = g_tmpoypos + mut * g_dypos;

                            // DrawFillRect(keyd[KEY_INHELP_EXIT].xpis, keyd[KEY_INHELP_EXIT].ypis, keyd[KEY_INHELP_EXIT].xsize, keyd[KEY_INHELP_EXIT].ysize, keybmpind[KEY_INHELP_EXIT].icon[3]);
                            DrawFillRect(keyd[KEY_INHELP_ENTER].xpis, keyd[KEY_INHELP_ENTER].ypis, keyd[KEY_INHELP_ENTER].xsize, keyd[KEY_INHELP_ENTER].ysize, keybmpind[KEY_INHELP_ENTER].icon[3]);

                            DrawFillRect(rect[RECT_INHELP_STR1].xpis, rect[RECT_INHELP_STR1].ypis,
                                         rect[RECT_INHELP_STR1].xsize, rect[RECT_INHELP_STR1].ysize,
                                         rect[RECT_INHELP_STR1].colorB[0]);
                            DrawFillRect(rect[RECT_INHELP_STR2].xpis, rect[RECT_INHELP_STR2].ypis,
                                         rect[RECT_INHELP_STR2].xsize, rect[RECT_INHELP_STR2].ysize,
                                         rect[RECT_INHELP_STR2].colorB[0]);
                            Draw24x24MulStr(disPosStr_X, vaddr1, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27), linemaxdisplay, Err_MSG1_Sheet1, 27, 2, vTestColor); //输入坐标错误!
                            if (dat2 == 3)
                            {
                                Draw24x24MulStr(disPosStr_X, vaddr2, (uint *)(USE_ERROR_MSG + ERROR_LEN * 27 + ERROR_MSG), linemaxdisplay, Err_MSG1_Sheet2, 27, 2, vTestColor); //坐标超出加工范围!
                            }
                            btn_en = 2;
                            dat = 2;

                            keyon = 0;
                            beeponf = 0;
                        }
                        g_disxpos = g_oxpos;
                        g_disypos = g_oypos;

                        g_pf_dis = 0;
                    }
                }
                else
                {
                    pno = MENU_CURSOR;
                    plastno = MENU_INHELP;
                    pnoindex--;
                }
                break;

            case KEY_INHELP_ORG:
                if (g_endtype == 1 || g_endtype == 2 || g_endtype == 3 || plastno == MENU_MODIFY || plastno == MENU_CONVERT || plastno == MENU_CONVERT1 || plastno == MENU_CURSOR || plastno == MENU_ZIGZAG)
                {
                    f = Go_Home(MENU_INHELP, 1); //0
                    g_jog_stpoint = 0;
                }
                else
                {
                    f = Go_Home(MENU_INHELP, 0); //DisTestData(100,100,f,btn_en,1,Color_Red);
                    g_jog_point = 0;
                    g_jog_stpoint = 0;
                }

                if (f)
                {
                    if (btn_en & 0x8)
                    {
                        if (plastno == MENU_CONVERT1)
                        {
                            //pnoindex -= 2;pno = poldno[pnoindex];
                            pnoindex -= 1;
                            pno = MENU_CONVERT;
                        }
                        else
                        {
                            pnoindex -= 3;
                            pno = poldno[pnoindex];
                            g_jog_point = 0;
                        }
                    }
                    else
                    {
                        if (plastno == MENU_INPUT)
                        {
                            pno = MENU_CURSOR;
                        }
                        else if (g_modifyflag)
                        {
                            if (F_FILETYPE == PAT_MIT)
                            {
                                HREG[4] = ((((SREG[2] + 0x40) / 2) + ((((U32)(SREG[5]) << 16) + SREG[4]) / 4) * 3) * 2) & 0xffff;
                                HREG[5] = (((((SREG[2] + 0x40) / 2) + ((((U32)(SREG[5]) << 16) + SREG[4]) / 4) * 3) * 2) >> 16) & 0xffff;
                            }
                            g_savemodify = 1;
                            pno = MENU_WRITE1;

                            //								isHome = (U8)(S_HOME)|(U8)(S_NEWHOME);
                            //								if((isHome&0x02)||(isHome&0x04)){
                            //
                            //								}else{ //没有回到机械原点位置
                            //									pno = MENU_RWHELP;hleppara = 160;poldno[pnoindex++] = MENU_WRITE1;break;
                            //								}
                        }
                        else
                        {
                            pno = poldno[0];
                            pnoindex = 0;
                            if ((pno == MENU_P1) || (pno == MENU_P2))
                            {
                                DREG[D_COMMAND] = C_YABANUP; //压板抬起
                                DREG[D_CMDSTATUS] = 0;
                                Write_D(D_Address[DISP] + D_COMMAND, 2, (U16 *)(&DREG[D_COMMAND]));
                                for (i = 0; i < RDTIMES; i++)
                                {
                                    Read_D(D_Address[DISP] + D_CMDSTATUS, 1, (U16 *)(&DREG[D_CMDSTATUS])); // 读状态
                                    if ((DREG[D_CMDSTATUS]) == 100)
                                        break;
                                    DelayMs(WAITTIME);
                                }
                            }

                            if (g_pfootd.oldbase != g_pfootd.base)
                            { //还原原来基准值
                                g_pfootd.base = g_pfootd.oldbase;
                                //设置中压脚基准值
                                f = Write_Cmd(C_PFOOTACTION, g_pfootd.base, 0);
                                Read_Status();
                                Write_Cmd2(C_PFEST, 1, 2, 0);
                                Read_Status();
                            }
                            if (g_tdtensiond.base != g_tdtensiond.oldbase)
                            { //还原原来基准值
                                g_tdtensiond.base = g_tdtensiond.oldbase;
                                f = Write_Cmd2(C_SETLFORCE, g_tdtensiond.base, 0, 0); //向主板发送保存面线张力基准值命令
                                Read_Status();
                            }

                            if ((g_ImageDis == 1) || (plastno == MENU_MODIFY) || (plastno == MENU_CONVERT))
                            {
                                Read_D(D_Address[HEAD], D_Length[HEAD], (U16 *)(&F_IND_NO)); // 读当前花样文件信息

                                m = F_IND_NO;
                                n = (m - MINFILENO) * FileIndexSize;
                                if ((IREG2[n] == 0xffff) && (IREG2[n + 1] == 0xffff))
                                { //内存索引表没此花样
                                    m = g_selectdisno;
                                }
                                if ((m >= MINFILENO) && (m <= MAXFILENO))
                                {
                                    n = (m - MINFILENO) * FileIndexSize;
                                    m = (((U32)(IREG2[n + 1]) << 16) + IREG2[n]) / 2;
                                    n = 0; // 如果读花样失败，初始化SREG寄存器
                                    if ((m >= 0x40) && (m <= MAXSREG))
                                    {
                                        n = Read_D(D_Address[PTDATA], m, (U16 *)(&SREG[0])); // 读当前花样数据
                                        if (n)
                                        {
                                            coldstart = 0;
                                            g_init_flag = 1;
                                            g_selectdisno = F_IND_NO;
                                            g_data_flash = 1;
                                        }
                                    }
                                }
                                g_ImageDis = 0;
                            }
                        }
                    }
                    plastno = MENU_INHELP;
                }
                break;

            case KEY_INHELP_SECT:
                pnoindex--;
                pno = MENU_CURSOR;
                plastno = MENU_INHELP;
                pnoindex--;
                if (F_FILETYPE == PAT_MIT)
                {
                    if (g_point_num < SPLINESUM_MAX + 1)
                    { //设置段落点
                        SREG[g_draw_p - 4] &= 0xfcff;
                        SREG[g_draw_p - 4] += 0x200;
                    }
                }
                else if (F_FILETYPE == PAT_SEW)
                {
                    if (g_point_num < SPLINESUM_MAX + 1)
                    {
                        g_array4[0][0]++;
                        g_array4[g_point_num][0] = g_oxpos;
                        g_array4[g_point_num][1] = g_oypos;
                        g_array5[g_point_num][0] = g_dxpos;
                        g_array5[g_point_num][1] = g_dypos;
                        g_point_num++;
                    }
                }
                break;

            case KEY_INHELP_TEST:

                break;
            }
            keyoff = 0;
        }
        // /[按键松开键值处理*end]**********************************************************

        // /[按键弹起显示信息处理*begin]**********************************************************
        if ((keyon) && (keydata == 0)) //按键弹起显示信息处理
        {
            //不需要显示的按键
            //非常规按键-//绘制颜色文字按键
            //常规按键
            DrawButtonOff(keyd[keyon], keybmpind[keyon].border[0]);

            keyon = 0;
            beeponf = 0;
        }
        // /[按键弹起显示信息处理*end]**********************************************************

        // /[定时1s信息处理*begin]**********************************************************
        if (Timerms > 1000)
        {
            Timerms = 0;
        }
        // /[定时1s信息处理*end]**********************************************************

        // /[连续功能按键信息处理时，及时检测报警信息*begin]**********************************************************
        if (key_on_flag1)
        {
        }
        // /[连续功能按键信息处理时，及时检测报警信息*end]**********************************************************

        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*begin]**********************************************************
        if (beeponf == 0)
        {
        }
        // /[蜂鸣器未响信息处理,包含跳针信息，花样更新*end]**********************************************************

        // /[按钮更新*begin]**********************************************************

        // /[按钮更新*end]**********************************************************

        // /[页面切换*begin]**********************************************************
        if ((pno != MENU_INHELP) || (g_DrawOcclude == 1))
        {
            break;
        }
        // /[页面切换*end]**********************************************************

        updateViewStatus();

        wdt();
    }
}
